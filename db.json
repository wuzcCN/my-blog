[{"title":"SpringMVC","url":"/2022/11/23/SpringMVC/","content":"\n## SpringMVC\n\n**MVC模式**\n\nMVC是软件工程中的一种软件架构模式，它是一种分离业务逻辑与显示界面的开发思想。\n\nM（model）模型：处理业务逻辑，封装实体 \n\nV（view） 视图：展示内容 \n\nC（controller）控制器：负责调度分发（1.接收请求、2.调用模型、3.转发到视图） \n\n**SpringMVC概述**\n\nSpringMVC 是一种基于 Java 的实现 MVC 设计模式的轻量级 Web 框架，属于SpringFrameWork 的 后续产品，已经融合在 Spring Web Flow 中。\n\nSpringMVC 已经成为目前最主流的MVC框架之一，并且随着Spring3.0 的发布，全面超越 Struts2， 成为最优秀的 MVC 框架。它通过一套注解，让一个简单的 Java 类成为处理请求的控制器，而无须实现任何接口。同时它还支持 RESTful 编程风格的请求。\n\nSpringMVC的框架就是封装了原来Servlet中的共有行为；例如：参数封装，视图转发等。\n\n## SpringMVC快速入门\n\n需求 客户端发起请求，服务器接收请求，执行逻辑并进行视图跳转。\n\n步骤分析：\n\n1. 创建web项目，导入SpringMVC相关坐标 \n\n2. 配置SpringMVC前端控制器 DispathcerServlet \n\n3. 编写Controller类和视图页面 \n4. 配置SpringMVC核心文件 spring-mvc.xml \n\n> 创建web项目，导入SpringMVC相关坐标\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n\n    <groupId>com.aaa</groupId>\n    <artifactId>SpringMvc</artifactId>\n    <version>1.0-SNAPSHOT</version>\n    <properties>\n        <maven.compiler.source>8</maven.compiler.source>\n        <maven.compiler.target>8</maven.compiler.target>\n        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n    </properties>\n    <!-- 设置为web工程 -->\n    <packaging>war</packaging>\n    <dependencies>\n        <!--springMVC坐标-->\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-webmvc</artifactId>\n            <version>5.1.5.RELEASE</version>\n        </dependency>\n        <!--servlet坐标-->\n        <dependency>\n            <groupId>javax.servlet</groupId>\n            <artifactId>javax.servlet-api</artifactId>\n            <version>3.1.0</version>\n            <scope>provided</scope>\n        </dependency>\n        <!--jsp坐标-->\n        <dependency>\n            <groupId>javax.servlet.jsp</groupId>\n            <artifactId>jsp-api</artifactId>\n            <version>2.2</version>\n            <scope>provided</scope>\n        </dependency>\n    </dependencies>\n</project>\n```\n\n> 配置SpringMVC前端控制器DispathcerServlet  web.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\"\n         version=\"4.0\">\n    <!--前端控制器-->\n    <servlet>\n        <servlet-name>dispatcherServlet</servlet-name>\n        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n        <init-param>\n            <param-name>contextConfigLocation</param-name>\n            <param-value>classpath:spring-mvc.xml</param-value>\n        </init-param>\n        <load-on-startup>2</load-on-startup>\n    </servlet>\n    <servlet-mapping>\n        <servlet-name>dispatcherServlet</servlet-name>\n        <url-pattern>/</url-pattern>\n    </servlet-mapping>\n</web-app>\n```\n\n> 编写Controller类和视图页面 com.aaa.controller.\n\n```java\n@Controller\npublic class UserController {\n    @RequestMapping(\"/quick\")\n    public String quick() {\n        System.out.println(\"quick running.....\");\n        return \"/WEB-INF/pages/success.jsp\";\n    }\n}\n```\n\nwebapp/WEB-INF/pages/ success.jsp\n\n```jsp\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n<html>\n<head>\n    <title>success</title>\n</head>\n<body>\n    <h3>请求成功！</h3>\n</body>\n</html>\n```\n\n> 配置SpringMVC核心文件spring-mvc.xml\n\n```xml\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\nhttp://www.springframework.org/schema/beans/spring-beans.xsd\nhttp://www.springframework.org/schema/context\nhttp://www.springframework.org/schema/context/spring-context.xsd\">\n    <!--配置注解扫描-->\n    <context:component-scan base-package=\"com.aaa.controller\"/>\n</beans>\n```\n\n> 访问web项目\n\n如果报错：Cannot access defaults field of Properties\n\n在pom文件中配置\n\n```xml\n<build>\n    <plugins>\n        <plugin>\n            <groupId>org.apache.maven.plugins</groupId>\n            <artifactId>maven-war-plugin</artifactId>\n            <version>3.3.1</version>\n        </plugin>\n    </plugins>\n</build>\n```\n\n## SpringMVC组件概述\n\n**SpringMVC的执行流程**\n\n1. 用户发送请求至前端控制器DispatcherServlet。\n\n2. DispatcherServlet收到请求调用HandlerMapping处理器映射器。 \n\n3. 处理器映射器找到具体的处理器(可以根据xml配置、注解进行查找)，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。 \n\n4. DispatcherServlet调用HandlerAdapter处理器适配器。\n\n5. HandlerAdapter经过适配调用具体的处理器(Controller，也叫后端控制器)。 \n\n6. Controller执行完成返回ModelAndView。 \n\n7. HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet。 \n\n8. DispatcherServlet将ModelAndView传给ViewReslover视图解析器。 \n\n9. ViewReslover解析后返回具体View。 \n\n10. DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。 \n\n11. DispatcherServlet将渲染后的视图响应响应用户。\n\n**SpringMVC组件解析**\n\n1. 前端控制器：DispatcherServlet \n\n   用户请求到达前端控制器，它就相当于 MVC 模式中的 C，DispatcherServlet 是整个流程控制的 中心，由它调用其它组件处理用户的请求，DispatcherServlet 的存在降低了组件之间的耦合性。 \n\n2. 处理器映射器：HandlerMapping \n\n   HandlerMapping 负责根据用户请求找到 Handler 即处理器，SpringMVC 提供了不同的映射器 实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。 \n\n3. 处理器适配器：HandlerAdapter \n\n   通过 HandlerAdapter 对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。 \n\n4. 处理器：Handler【**开发者编写**】\n\n   它就是我们开发中要编写的具体业务控制器。由 DispatcherServlet 把用户请求转发到 Handler。由Handler 对具体的用户请求进行处理。 \n\n5. 视图解析器：ViewResolver \n\n   View Resolver 负责将处理结果生成 View 视图，View Resolver 首先根据逻辑视图名解析成物理视图名，即具体的页面地址，再生成 View 视图对象，最后对 View 进行渲染将处理结果通过页面展示给 用户。 \n\n6. 视图：View 【**开发者编写**】 \n\n   SpringMVC 框架提供了很多的 View 视图类型的支持，包括：jstlView、freemarkerView、 pdfView等。最常用的视图就是 jsp。一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展 示给用户，需要由程序员根据业务需求开发具体的页面。 \n\n> 在controller中的返回值 ，只需要写上success就可以访问\n\n> spring-mvc.xml\n\n```xml\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:mvc=\"http://www.springframework.org/schema/mvc\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\nhttp://www.springframework.org/schema/beans/spring-beans.xsd\nhttp://www.springframework.org/schema/mvc\nhttp://www.springframework.org/schema/mvc/spring-mvc.xsd\nhttp://www.springframework.org/schema/context\nhttp://www.springframework.org/schema/context/spring-context.xsd\">\n    <!--配置注解扫描-->\n    <context:component-scan base-package=\"com.aaa.controller\"/>\n    <!--处理器映射器和处理器适配器功能增强-->\n    <mvc:annotation-driven></mvc:annotation-driven>\n    <!--视图解析器-->\n    <bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\">\n        <property name=\"prefix\" value=\"/WEB-INF/pages/\"></property>\n        <property name=\"suffix\" value=\".jsp\"></property>\n    </bean>\n</beans>\n```\n\n> Controller类\n\n```java\n@Controller\npublic class UserController {\n    @RequestMapping(\"/quick\")\n    public String quick() {\n        System.out.println(\"quick running.....\");\n        return \"success\";\n    }\n}\n```\n\n**SpringMVC注解解析**\n\nSpringMVC基于Spring容器，所以在进行SpringMVC操作时，需要将Controller存储到Spring容器 中，如果使用@Controller注解标注的话，就需要使用：\n\n```xml\n<!--配置注解扫描-->\n<context:component-scan base-package=\"com.aaa.controller\"/>\n```\n\n```java\n@Controller\n@RequestMapping(\"/user\") //一级访问目录\npublic class UserController {\n    /*\n        /一级访问目录/二级访问目录\n        http://localhost:8080/springmvc_war/user/quick    \n        path : 或者写value 都可以,同样是设置方法的映射地址\n        method：用来限定请求的方式 RequestMethod.POST:\n        只能以post的请求方式访问该访问，其他请求方式会报错\n        params：用来限定请求参数的条件 \n        params={\"accountName\"} 表示请求参数中必须有accountName\n     */\n    @RequestMapping(path = \"/quick\",method = RequestMethod.GET,params = {\"accountName\"})\n    public String quick() {\n        System.out.println(\"quick running.....\");\n        return \"success\";\n    }\n}\n```\n\n@RequestMapping 作用：用于建立请求 URL 和处理请求方法之间的对应关系\n\n位置：\n\n- 类上：请求URL的第一级访问目录。此处不写的话，就相当于应用的根目录。写的话需要以/开头。它出现的目的是为了使我们的URL可以按照模块化管理:\n  - 用户模块\n    - /user/add\n    - /user/update\n    - /user/delete\n  - 账户模块\n    - /account/add\n    - /account/update\n    - /account/delete\n- 方法上：请求URL的第二级访问目录，和一级目录组成一个完整的 URL 路径。\n  - 属性：\n    - value：用于指定请求的URL。它和path属性的作用是一样的\n    - method：用来限定请求的方式\n    - params：用来限定请求参数的条件\n\n例如：params={\"accountName\"} 表示请求参数中必须有accountName\n\nparams={\"money!=100\"} 表示请求参数中money不能是100\n\n## SpringMVC的请求\n\n**请求参数类型介绍**\n\n客户端请求参数的格式是： name=value&name=value……\n\n服务器要获取请求的参数的时候要进行类型转换，有时还需要进行数据的封装\n\nSpringMVC可以接收如下类型的参数：\n\n- 基本类型参数\n\n- 对象类型参数 \n\n- 数组类型参数  \n\n- 集合类型参数\n\n### 获取基本类型参数\n\nController中的业务方法的参数名称要与请求参数的name一致，参数值会自动映射匹配。并且能自动做类型转换；自动的类型转换是指从String向其他类型的转换。\n\n> 创建文件 requestParam.jsp\n\n> 注：创建在 WEB-INF 下，这里是安全目录 只可以通过controller转发访问，不可以直接访问\n\n```jsp\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n<html>\n<head>\n    <title>Title</title>\n</head>\n<body>\n<%--${pageContext.request.contextPath}动态的来获取当前的项目路径 springmvc_war  a标签的请求方式：get请求--%>\n<a href=\"${pageContext.request.contextPath}/user/simpleParam?id=1&username=fyh\">\n    基本类型\n</a>\n</body>\n</html>\n```\n\n> 在controller 中，写上接口\n\n> 注意：参数名字和请求一样\n\n```java\npublic interface UserControllerDao {\n\t@RequestMapping(\"/simpleParam\")\n    public String simpleParam(Integer id,String username) {\n        System.out.println(id);\n        System.out.println(username);\n        return \"requestParam\";\n    }\n}\n```\n\n### 获取对象类型参数\n\nController中的业务方法参数的POJO属性名与请求参数的name一致，参数值会自动映射匹配。\n\n```jsp\n\t<form action=\"${pageContext.request.contextPath}/user/pojoParam\" method=\"post\">\n        编号：<input type=\"text\" name=\"id\"> <br>\n        用户名：<input type=\"text\" name=\"username\"> <br>\n        <input type=\"submit\" value=\"对象类型\">\n    </form>\n```\n\n```java\npublic class User {\n    private int id;\n    private String username;\n\n    @Override\n    public String \n    toString() {\n        return \"User{\" +\n                \"id=\" + id +\n                \", username='\" + username + '\\'' +\n                '}';\n    }\n\n    public int getId() {\n        return id;\n    }\n\n    public void setId(int id) {\n        this.id = id;\n    }\n\n    public String getUsername() {\n        return username;\n    }\n\n    public void setUsername(String username) {\n        this.username = username;\n    }\n}\n```\n\n```java\n\t@RequestMapping(\"/pojoParam\")\n    public String pojoParam(User user) {\n        System.out.println(user);\n        return \"requestParam\";\n    }\n```\n\n### 中文乱码过滤器\n\n当post请求时，数据会出现乱码，我们可以设置一个过滤器来进行编码的过滤，web.xml中加上过滤器的配置\n\n```xml\n<!--配置全局过滤的filter-->\n    <filter>\n        <filter-name>CharacterEncodingFilter</filter-name>\n        <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>\n        <init-param>\n            <param-name>encoding</param-name>\n            <param-value>UTF-8</param-value>\n        </init-param>\n    </filter>\n    <filter-mapping>\n        <filter-name>CharacterEncodingFilter</filter-name>\n        <url-pattern>/*</url-pattern>\n    </filter-mapping>\n```\n\n### 获取数组类型参数\n\nController中的业务方法数组名称与请求参数的name一致，参数值会自动映射匹配。\n\n```java\n\t@RequestMapping(\"/arrayParam\")\n    public String arrayParam(Integer[] ids) {\n        System.out.println(Arrays.toString(ids));\n        return \"requestParam\";\n    }\n```\n\n```jsp\n\t<form action=\"${pageContext.request.contextPath}/user/arrayParam\">\n        编号：<br>\n        <input type=\"checkbox\" name=\"ids\" value=\"1\">1<br>\n        <input type=\"checkbox\" name=\"ids\" value=\"2\">2<br>\n        <input type=\"checkbox\" name=\"ids\" value=\"3\">3<br>\n        <input type=\"checkbox\" name=\"ids\" value=\"4\">4<br>\n        <input type=\"checkbox\" name=\"ids\" value=\"5\">5<br>\n        <input type=\"submit\" value=\"数组类型\">\n    </form>\n```\n\n### 获取集合（复杂）类型参数\n\n获得集合参数时，要将集合参数包装到一个POJO中才可以。\n\n```jsp\n\t<form action=\"${pageContext.request.contextPath}/user/queryParam\" method=\"post\">\n        搜索关键字：<input type=\"text\" name=\"keyword\"> <br>\n        user对象：\n        <input type=\"text\" name=\"user.id\" placeholder=\"编号\">\n        <input type=\"text\" name=\"user.username\" placeholder=\"姓名\"><br>\n        list集合<br>\n        第一个元素：\n        <input type=\"text\" name=\"userList[0].id\" placeholder=\"编号\">\n        <input type=\"text\" name=\"userList[0].username\" placeholder=\"姓名\"><br>\n        第二个元素：\n        <input type=\"text\" name=\"userList[1].id\" placeholder=\"编号\">\n        <input type=\"text\" name=\"userList[1].username\" placeholder=\"姓名\"><br>\n        map集合<br>\n        第一个元素：\n        <input type=\"text\" name=\"userMap['u1'].id\" placeholder=\"编号\">\n        <input type=\"text\" name=\"userMap['u1'].username\" placeholder=\"姓名\"><br>\n        第二个元素：\n        <input type=\"text\" name=\"userMap['u2'].id\" placeholder=\"编号\">\n        <input type=\"text\" name=\"userMap['u2'].username\" placeholder=\"姓名\"><br>\n        <input type=\"submit\" value=\"复杂类型\">\n    </form>\n```\n\n```java\npublic class QueryVo {\n    private String keyword;\n    private User user;\n    private List<User> userList;\n    private Map<String, User> userMap;\n   \t//get/set toString\n}\n```\n\n```java\n\t@RequestMapping(\"/queryParam\")\n    public String queryParam(QueryVo queryVo) {\n        System.out.println(queryVo);\n        return \"requestParam\";\n    }\n```\n\n### 自定义类型转换器\n\nSpringMVC 默认已经提供了一些常用的类型转换器；例如：客户端提交的字符串转换成int型进行参数设置，日期格式类型要求为：yyyy/MM/dd 不然的话会报错，对于特有的行为，SpringMVC提供了自定义类型转换器方便开发者自定义处理。\n\n```jsp\n\t<form action=\"${pageContext.request.contextPath}/user/converterParam\">\n        生日：<input type=\"text\" name=\"birthday\">\n        <input type=\"submit\" value=\"自定义类型转换器\">\n    </form>\n```\n\n```java\npublic class DateConverter implements Converter<String , Date> {\n\n    @Override\n    public Date convert(String dateStr) {\n        //将日期字符串转换成日期对象返回\n        SimpleDateFormat format = new SimpleDateFormat(\"yyyy-MM-dd\");\n        Date date = null;\n        try {\n            date = format.parse(dateStr);\n        } catch (ParseException e) {\n            e.printStackTrace();\n        }\n        return date;\n    }\n}\n```\n\n> 在spring-mvc.xml中配置\n\n```xml\n<!--处理器映射器和适配器增强-->\n    <mvc:annotation-driven conversion-service=\"conversionService\"></mvc:annotation-driven>\n    <!--自定义转换器配置-->\n    <bean id=\"conversionService\"\n          class=\"org.springframework.context.support.ConversionServiceFactoryBean\">\n        <property name=\"converters\">\n            <set>\n                <bean class=\"com.aaa.converter.DateConverter\"></bean>\n            </set>\n        </property>\n    </bean>\n```\n\n```java\n\t@RequestMapping(\"/converterParam\")\n    public String converterParam(Date birthday) {\n        System.out.println(birthday);\n        return \"requestParam\";\n    }\n```\n\n### 相关注解\n\n当请求的参数name名称与Controller的业务方法参数名称不一致时,就需要通过@RequestParam注解显示的绑定\n\n```xml\n<a href=\"${pageContext.request.contextPath}/user/findByPage?pageNo=2\">分页查询</a>\n```\n\n```java\n\t/* @RequestParam() 注解\n    defaultValue 设置参数默认值\n    name 匹配页面传递参数的名称\n    required 设置是否必须传递参数，默认值为true；如果设置了默认值，值自动改为false*/\n    @RequestMapping(\"/findByPage\")\n    public String findByPage(@RequestParam(name = \"pageNo\", defaultValue = \"1\")Integer pageNum, @RequestParam(defaultValue = \"5\") Integer pageSize) {\n        System.out.println(pageNum);\n        System.out.println(pageSize);\n        return \"requestParam\";\n    }\n```\n\n> @RequestHeader 获取请求头的数据\n\n```java\n\t@RequestMapping(\"/requestHead\")\n    public String requestHead(@RequestHeader(\"cookie\") String cookie) {\n        System.out.println(cookie);\n        return \"requestParam\";\n    }\n```\n\n> @CookieValue 获取cookie中的数据\n\n```java\n\t@RequestMapping(\"/cookieValue\")\n    public String cookieValue(@CookieValue(\"JSESSIONID\") String jesessionId) {\n        System.out.println(jesessionId);\n        return \"requestParam\";\n    }\n```\n\n### 获取Servlet相关API\n\nSpringMVC支持使用原始ServletAPI对象作为控制器方法的参数进行注入，常用的对象\n\n```java\n@RequestMapping(\"/servletAPI\")\n    public String servletAPI(HttpServletRequest request, HttpServletResponse response, HttpSession session) {\n        System.out.println(request);\n        System.out.println(response);\n        System.out.println(session);\n        return \"requestParam\";\n    }\n```\n\n## SpringMVC的响应\n\n### 返回字符串逻辑视图\n\n直接返回字符串：此种方式会将返回的字符串与视图解析器的前后缀拼接后跳转到指定页面\n\n```java\n\t@RequestMapping(\"/returnString\")\n    public String returnString(){\n        return \"requestParam\";\n    }\n```\n\n### 原始ServletAPI\n\n我们可以通过request、response对象实现响应\n\n```java\n@RequestMapping(\"/returnString\")\n    public void returnString(HttpServletResponse response) throws IOException {\n        //通过response直接响应数据\n        response.setContentType(\"text/html;charset=utf-8\");\n        response.getWriter().write(\"xiao\");\n    }\n```\n\n```java\n@RequestMapping(\"/returnVoid\")\n    public void returnVoid(HttpServletRequest request, HttpServletResponse response)\n            throws Exception {\n    //通过request实现转发\n    request.getRequestDispatcher(\"/WEB-INF/pages/success.jsp\").forward(request,response);\n    }\n```\n\n```java\n@RequestMapping(\"/returnVoid\")\n    public void returnVoid(HttpServletRequest request, HttpServletResponse response)\n            throws Exception {\n\t//通过response实现重定向\n    response.sendRedirect(request.getContextPath() + \"/index.jsp\");\n    }\n```\n\n```jsp\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n<html>\n<head>\n    <title>Title</title>\n</head>\n<body>\n    <h3>Hello ......</h3>\n</body>\n</html>\n```\n\n### 转发和重定向\n\n企业开发我们一般使用返回字符串逻辑视图实现页面的跳转，这种方式其实就是请求转发。\n\n> 我们也可以写成，forward转发，如果用了forward，则路径必须写成实际视图url，不能写逻辑视图，相当于\n\n```java\nrequest.getRequestDispatcher(\"url\").forward(request,response)\n```\n\n使用请求转发，既可以转发到jsp，也可以转发到其他的控制器方法。\n\n```java\n\t@RequestMapping(\"/forward\")\n    public String forward() {\n        System.out.println(\"forward...\");\n        return \"forward:/WEB-INF/pages/success.jsp\";\n    }\n```\n\n> Redirect重定向\n\n我们可以不写虚拟目录，springMVC框架会自动拼接，并且将Model中的数据拼接到url地址上\n\n```java\n\t@RequestMapping(\"/redirect\")\n    public String redirect() {\n        System.out.println(\"redirect...\");\n        return \"redirect:/index.jsp\";\n    }\n```\n\n> 跳转页面时 携带数据\n\n```java\n\n```\n\n> 在 success.jsp 页面中 加入\n\n```jsp\n<h3>请求成功！ ${username}</h3>\n```\n\n### ModelAndView\n\n> 方式一：在Controller中方法创建并返回ModelAndView对象，并且设置视图名称\n\n```java\n@RequestMapping(\"/returnModelAndView1\")\n    public ModelAndView returnModelAndView1() {\n      /*\n      Model:模型 作用封装数据\n      View：视图 作用展示数据\n      */\n        ModelAndView modelAndView = new ModelAndView();\n        //设置模型数据\n        modelAndView.addObject(\"username\", \"fyh\");\n        //设置视图名称\n        modelAndView.setViewName(\"success\");\n        return modelAndView;\n    }\n```\n\n> 方式二：在Controller中方法形参上直接声明ModelAndView，无需在方法中自己创建，在方法中直接使用该对象设置视图，同样可以跳转页面\n\n```java\n\t@RequestMapping(\"/returnModelAndView2\")\n    public ModelAndView returnModelAndView2(ModelAndView modelAndView) {\n        //设置模型数据\n        modelAndView.addObject(\"username\", \"fly\");\n        //设置视图名称\n        modelAndView.setViewName(\"success\");\n        return modelAndView;\n    }\n```\n\n### @SessionAttributes\n\n如果在多个请求之间共用数据，则可以在控制器类上标注一个 @SessionAttributes,配置需要在 session中存放的数据范围，Spring MVC将存放在model中对应的数据暂存到 HttpSession 中。\n\n> 注意：@SessionAttributes只能定义在类上\n\n```java\n@Controller\n@SessionAttributes(\"username\") //向request域存入的key为username时，同步到session域中\n@RequestMapping(\"/user\")\npublic class UserController {\t\n\t\t@RequestMapping(\"/forward1\")\n        public String forward1(Model model) {\n            model.addAttribute(\"username\", \"fly\");\n            return \"forward:/WEB-INF/pages/success.jsp\";\n        }\n}\n```\n\n### 静态资源访问的开启\n\n当有静态资源需要加载时，比如jquery文件，通过谷歌开发者工具抓包发现，没有加载到jquery文 件，原因是SpringMVC的前端控制器DispatcherServlet的url-pattern配置的是 /（缺省）,代表对所有的 静态资源都进行处理操作，这样就不会执行Tomcat内置的DefaultServlet处理，我们可以通过以下两种 方式指定放行静态资源\n\n> 在requestParam.jsp 中添加对jquery的引用\n\n```jsp\n<%--引入jquery.js--%>\n<script src=\"${pageContext.request.contextPath}/js/jquery-3.6.1.js\"/>\n```\n\n> 方式一\n\n```xml\n<!--在springmvc配置文件中指定放行资源-->\n<mvc:resources mapping=\"/js/**\" location=\"/js/\"/>\n<mvc:resources mapping=\"/css/**\" location=\"/css/\"/>\n<mvc:resources mapping=\"/img/**\" location=\"/img/\"/>\n```\n\n> 方式二\n\n```xml\n<!--在springmvc配置文件中开启DefaultServlet处理静态资源-->\n<mvc:default-servlet-handler/>\n```\n\n## ajax异步交互\n\nSpringmvc默认用MappingJackson2HttpMessageConverter对json数据进行转换，需要加入jackson的包；同时使用 <mvc:annotation-driven />\n\n```xml\n\t\t<dependency>\n            <groupId>com.fasterxml.jackson.core</groupId>\n            <artifactId>jackson-databind</artifactId>\n            <version>2.9.8</version>\n        </dependency>\n        <dependency>\n            <groupId>com.fasterxml.jackson.core</groupId>\n            <artifactId>jackson-core</artifactId>\n            <version>2.9.8</version>\n        </dependency>\n        <dependency>\n            <groupId>com.fasterxml.jackson.core</groupId>\n            <artifactId>jackson-annotations</artifactId>\n            <version>2.9.0</version>\n        </dependency>\n```\n\n### @RequestBody\n\n该注解用于Controller的方法的形参声明，当使用ajax提交并指定contentType为json形式时，通过HttpMessageConverter接口转换为对应的POJO对象。\n\n> 新建ajax.jsp\n\n```jsp\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n<html>\n<head>\n  <title>Title</title>\n  <script src=\"${pageContext.request.contextPath}/js/jquery-3.6.1.js\"></script>\n</head>\n<body>\n\n  <button id=\"btn1\">ajax异步提交</button>\n  <script>\n    $(\"#btn1\").click(function () {\n      let url = '${pageContext.request.contextPath}/ajaxRequest';\n      let data = '[{\"id\":1,\"username\":\"张三\"},{\"id\":2,\"username\":\"李四\"}]';\n      $.ajax({\n        type: 'POST',//请求方式\n        url: url,//请求后端的URL地址\n        data: data,//我要携带的数据\n        contentType: 'application/json;charset=utf-8',//请求数据类型 json\n        success: function (resp) {\n          alert(JSON.stringify(resp))//后端返回数据\n        }\n      })\n    })\n  </script>\n\n</body>\n</html>\n```\n\n> 新建AjaxController,注意给类加controller注解\n\n```java\n@Controller\npublic class AjaxController {\n    @RequestMapping(value = \"/ajaxRequest\")\n    public void ajaxRequest(@RequestBody List<User> list) {\n        System.out.println(list);\n    }\n}\n```\n\n### @ResponseBody\n\n该注解用于将Controller的方法返回的对象，通过HttpMessageConverter接口转换为指定格式的数据如：json,xml等，通过Response响应给客户端。\n\n```java\n@Controller\npublic class AjaxController {\n    /*@RequestMapping\n    produces = \"application/json;charset=utf-8\" \n    响应返回数据的mime类型和编码，默认为json*/\n    @RequestMapping(value = \"/ajaxRequest\")\n    @ResponseBody\n    public List<User> ajaxRequest(@RequestBody List<User> list) {\n        System.out.println(list);\n        return list;\n    }\n}\n```\n\n## RESTful\n\n**什么是RESTful**\n\nRestful是一种软件架构风格、设计风格，而不是标准，只是提供了一组设计原则和约束条件。主要用于客户端和服务器交互类的软件，基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存机制等。\n\nRestful风格的请求是使用“url+请求方式”表示一次请求目的的，HTTP 协议里面四个表示操作方式的动词如下：\n\n- GET：读取（Read）\n\n- POST：新建（Create）\n\n- PUT：更新（Update）\n\n- DELETE：删除（Delete）\n\n| 客户端请求 | 原来风格URL地址     | RESTful风格URL地址 |\n| ---------- | ------------------- | ------------------ |\n| 查询所有   | /user/findAll       | GET /user          |\n| 根据ID查询 | /user/findById?id=1 | GET /user/{1}      |\n| 新增       | /user/save          | POST /user         |\n| 修改       | /user/update        | PUT /user          |\n| 删除       | /user/delete?id=1   | DELETE /user/{1}   |\n\n### 代码实现\n\n**@PathVariable**\n\n用来接收RESTful风格请求地址中占位符的值\n\n**@RestController**\n\nRESTful风格多用于前后端分离项目开发，前端通过ajax与服务器进行异步交互，我们处理器通常返回的是json数据所以使用@RestController来替代@Controller和@ResponseBody两个注解。\n\n```java\n@RestController//替代@Controller和@ResponseBody\n//@Controller\npublic class RestFulController {\n    @GetMapping(value = \"/user/{id}\")\n    //相当于 @RequestMapping(value = \"/user/{id}\",method = RequestMethod.GET)\n    //@ResponseBody 返回数据\n    public String get(@PathVariable Integer id) {\n        System.out.println(\"get：\" + id);\n        return \"get:\" + id;\n    }\n    @PostMapping(value = \"/user\")\n    public String post() {\n        return \"post\";\n    }\n    @PutMapping(value = \"/user\")\n    public String put() {\n        return \"put\";\n    }\n    @DeleteMapping(value = \"/user/{id}\")\n    public String delete(@PathVariable Integer id) {\n        return \"delete：\"+ id;\n    }\n}\n```\n\n> @RequestParam用于接收url地址传参或表单传参\n>\n> @RequestBody用于接收json数据\n>\n> @PathVariable用于接收路径参数，使用{参数名称}描述路径参数\n\n> 使用 postman 软件对接口进行测试\n\n## 文件上传\n\n**文件上传三要素**\n\n- 表单项 type=\"file\"\n\n- 表单的提交方式 method=\"POST\"\n\n- 表单的enctype属性是多部分表单形式 enctype=“multipart/form-data\"\n\n**文件上传原理**\n\n1. 当form表单修改为多部分表单时，request.getParameter()将失效\n\n2. 当form表单的enctype取值为 application/x-www-form-urlencoded 时，form表单的正文内容格式是name=value&name=value\n\n3. 当form表单的enctype取值为 mutilpart/form-data 时，请求正文内容就变成多部分形式\n\n### 单文件上传\n\n> 导入fileupload和io坐标\n\n```xml\n\t\t<dependency>\n            <groupId>commons-fileupload</groupId>\n            <artifactId>commons-fileupload</artifactId>\n            <version>1.3.3</version>\n        </dependency>\n        <dependency>\n            <groupId>commons-io</groupId>\n            <artifactId>commons-io</artifactId>\n            <version>2.6</version>\n        </dependency>\n```\n\n> 配置文件上传解析器\n\n```xml\n\t<!--文件上传解析器-->\n    <bean id=\"multipartResolver\"\n          class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\">\n        <!-- 设定文件上传的最大值为5MB，5*1024*1024 -->\n        <property name=\"maxUploadSize\" value=\"5242880\"></property>\n        <!-- 设定文件上传时写入内存的最大值，如果小于这个参数不会生成临时文件，默认为10240 -->\n        <property name=\"maxInMemorySize\" value=\"40960\"></property>\n    </bean>\n```\n\n> 编写文件上传代码\n\n新建fileupload.jsp页面\n\n```jsp\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n<html>\n<head>\n    <title>Title</title>\n</head>\n<body>\n    <form action=\"${pageContext.request.contextPath}/fileUpload\" method=\"post\" enctype=\"multipart/form-data\">\n        名称：<input type=\"text\" name=\"username\"> <br>\n        文件：<input type=\"file\" name=\"filePic\"> <br>\n        <input type=\"submit\" value=\"单文件上传\">\n    </form>\n</body>\n</html>\n```\n\n新建  FileUploadController\n\n```java\n@Controller\npublic class FileUploadController {\n    @RequestMapping(\"/fileUpload\")\n    public String fileUpload(String username, MultipartFile filePic) throws IOException {\n        //上传文件后端需要用MultipartFile接受\n        System.out.println(username);\n        // 获取文件名\n        String originalFilename = filePic.getOriginalFilename();\n        //保存文件\n        filePic.transferTo(new File(\"E:/aaa/\"+originalFilename));\n        //跳转到成功页面\n        return \"success\";\n    }\n}\n```\n\n### 多文件上传\n\n> 修改上传文件 为多文件\n\n```jsp\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n<html>\n<head>\n    <title>Title</title>\n</head>\n<body>\n\t<form action=\"${pageContext.request.contextPath}/filesUploads\" method=\"post\" enctype=\"multipart/form-data\">\n        名称：<input type=\"text\" name=\"username\"> <br>\n        文件1：<input type=\"file\" name=\"filePic\"> <br>\n        文件2：<input type=\"file\" name=\"filePic\"> <br>\n        <input type=\"submit\" value=\"多文件上传\">\n    </form>\n</body>\n</html>\n```\n\n```java\n\t@RequestMapping(\"/filesUploads\")\n    public String filesUpload(String username, MultipartFile[] filePic) throws IOException {\n        System.out.println(username);\n        for (MultipartFile multipartFile : filePic) {\n            // 获取文件名\n            String originalFilename = multipartFile.getOriginalFilename();\n            // 保存到服务器\n            multipartFile.transferTo(new File(\"E:/aaa/\" + originalFilename));\n        }\n        return \"success\";\n    }\n```\n\n## 异常处理\n\n**异常处理的思路**\n\n在Java中，对于异常的处理一般有两种方式:\n\n一种是当前方法捕获处理（try-catch），这种处理方式会造成业务代码和异常处理代码的耦合。\n\n另一种是自己不处理，而是抛给调用者处理（throws），调用者再抛给它的调用者，也就是一直向上抛。\n\n在这种方法的基础上，衍生出了SpringMVC的异常处理机制。系统的dao、service、controller出现都通过throws Exception向上抛出，最后由springmvc前端控制器交由异常处理器进行异常处理。\n\n### 自定义异常处理器\n\n> 创建异常处理器类实现HandlerExceptionResolver\n\n```java\n@Component\npublic class GlobalExceptionResolver implements HandlerExceptionResolver {\n    @Override\n    public ModelAndView resolveException(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) {\n            ModelAndView modelAndView = new ModelAndView();\n            modelAndView.addObject(\"error\", e.getMessage());\n            modelAndView.setViewName(\"error\");\n            return modelAndView;\n    }\n}\n```\n\n> 新建error.jsp页面，在WEB-INF->pages下\n\n```jsp\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n<html>\n<head>\n    <title>Title</title>\n</head>\n<body>\n    error ----> ${error}\n</body>\n</html>\n```\n\n> 配置异常处理器，使用注解或者xml配置\n>\n> 配置注解记得增加扫描包\n\n```xml\n<context:component-scan base-package=\"com.aaa.controller,com.aaa.exception\"/>\n```\n\n### web的处理异常机制\n\n> 新建404页面\n\n```jsp\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n<html>\n<head>\n    <title>Title</title>\n</head>\n<body>\n\t<h3>未能找到目标资源 </h3>\n</body>\n</html>\n```\n\n> 新建500.jsp\n\n```jsp\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n<html>\n<head>\n    <title>Title</title>\n</head>\n<body>\n    <h3>服务器内部错误</h3>\n</body>\n</html>\n```\n\n> 在web.xml 中配置 \n\n```xl\n\t<!--处理404异常-->\n    <error-page>\n        <error-code>404</error-code>\n        <location>/404.jsp</location>\n    </error-page>\n    <!--处理500异常-->\n    <error-page>\n        <error-code>500</error-code>\n        <location>/500.jsp</location>\n    </error-page>\n```\n\n## 拦截器\n\n**拦截器（interceptor）的作用**\n\nSpring MVC 的拦截器类似于 Servlet 开发中的过滤器 Filter，用于对处理器进行预处理和后处理。\n\n将拦截器按一定的顺序联结成一条链，这条链称为拦截器链（InterceptorChain）。在访问被拦截的方法或字段时，拦截器链中的拦截器就会按其之前定义的顺序被调用。\n\n**拦截器和过滤器区别**\n\n| 区别     | 过滤器                                                  | 拦截器                                                       |\n| -------- | ------------------------------------------------------- | ------------------------------------------------------------ |\n| 使用范围 | 是servlet规范中的一部分，任何Java Web 工程都可以使用    | 是SpringMVC框架自己的，只有使用了SpringMVC框架的工程才能用   |\n| 拦截范围 | 在url-pattern中配置了/*之后，可以对所有要访问的资源拦截 | 只会拦截访问的控制器方法，如果访问的是jsp,html.css.image或者is是不会进行拦截的 |\n\n### 快速入门\n\n> 创建拦截器类实现HandlerInterceptor接口\n\n```java\npublic class MyInterceptor1 implements HandlerInterceptor {\n    // 在目标方法(对应的controller方法)执行之前拦截\n    @Override\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) {\n        System.out.println(\"preHendle-1\");\n        return true;\n    }\n    // 在目标方法执行之后,视图对象返回之前执行\n    @Override\n    public void postHandle(HttpServletRequest request, HttpServletResponse\n            response, Object handler, ModelAndView modelAndView) {\n        System.out.println(\"postHandle-11\");\n    }\n    // 在流程都执行完毕后执行\n    @Override\n    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) {\n        System.out.println(\"afterCompletion1\");\n    }\n}\n```\n\n> 在springmvc.xml 中配置拦截器\n\n```xml\n\t<!--配置拦截器-->\n    <mvc:interceptors>\n        <mvc:interceptor>\n            <!--对哪些资源执行拦截操作-->\n            <mvc:mapping path=\"/**\"/>\n            <bean class=\"com.aaa.interceptor.MyInterceptor1\"/>\n        </mvc:interceptor>\n    </mvc:interceptors>\n```\n\n>测试拦截器的拦截效果,编写Controller,发请求到controller,跳转页面\n\n```java\n@Controller\npublic class TargetController {\n    @RequestMapping(\"/target\")\n    public String targetMethod() {\n        System.out.println(\"目标方法执行了...\");\n        return \"success\";\n    }\n}\n```\n\n### 拦截器链\n\n开发中拦截器可以单独使用，也可以同时使用多个拦截器形成一条拦截器链。开发步骤和单个拦截器是一样的，只不过注册的时候注册多个，注意这里注册的顺序就代表拦截器执行的顺序。\n\n> 同上，再编写一个MyInterceptor2操作，测试执行顺序：\n\n```xml\n\t<!--配置拦截器-->\n    <mvc:interceptors>\n        <mvc:interceptor>\n            <!--拦截器路径配置-->\n            <mvc:mapping path=\"/**\"/>\n            <!--自定义拦截器类-->\n            <bean class=\"com.aaa.interceptor.MyInterceptor1\"></bean>\n        </mvc:interceptor>\n        <mvc:interceptor>\n            <!--拦截器路径配置-->\n            <mvc:mapping path=\"/**\"/>\n            <!--自定义拦截器类-->\n            <bean class=\"com.aaa.interceptor.MyInterceptor2\"></bean>\n        </mvc:interceptor>\n    </mvc:interceptors>\n```\n\n| 方法名            | 说明                                                         |\n| ----------------- | ------------------------------------------------------------ |\n| preHandle()       | 方法将在请求处理之前进行调用，该方法的返回值是布尔值Boolean类型的，当它返回为false时，表示请求结束，后续的Interceptor和Controller都不会再执行;当返回值为true时就会继续调用下一个Interceptor的preHandle方法 |\n| postHandle()      | 该方法是在当前请求进行处理之后被调用，前提是preHandle方法的返回值为true时才能被调用，且它会在DispatcherServlet进行视图返回渲染之前被调用，所以我们可以在这个方法中对Controller处理之后的ModelAndView对象进行操作 |\n| afterCompletion() | 该方法将在整个请求结束之后，也就是在DispatcherServlet渲染了对应的视图之后执行，前提是preHandle方法的返回值为true时才能被调用 |\n\n## OSS\n\n**OSS是什么**\n\n阿里云对象存储OSS（Object Storage Service）是一款海量、安全、低成本、高可靠的云存储服务，提供99.9999999999%(12个9)的数据持久性，99.995%的数据可用性。多种存储类型供选择，全面优化存储成本\n\n**查看OSS官方文档**\n\n[对象存储OSS 快速入门 (aliyun.com)](https://help.aliyun.com/document_detail/31882.html)\n\n### 快速入门\n\n[OSS SDK JAVA 快速入门](https://help.aliyun.com/document_detail/32008.html?spm=5176.208357.1107607.21.71e6390fBvXVXH)\n\n> 注册AccessKey（按照官网步骤操作）\n\n![AccessKey](https://image.aobayu.cn/images/AccessKey-1.jpg)\n\n![](https://image.aobayu.cn/images/AccessKey-2.jpg)\n\n> 创建bucket（文件存储的桶）\n\n![](https://image.aobayu.cn/images/Bucket-1.jpg)\n\n![](https://image.aobayu.cn/images/Bucket-2.jpg)\n\n![](https://image.aobayu.cn/images/Bucket-3.jpg)\n\n> 根据官网文档编写上传下载工具类\n\n在Maven项目中加入依赖项\n\n```xml\n<dependency>\n    <groupId>com.aliyun.oss</groupId>\n    <artifactId>aliyun-sdk-oss</artifactId>\n    <version>3.15.1</version>\n</dependency>\n```\n\n编写上传功能\n\n```java\nimport com.aliyun.oss.ClientException;\nimport com.aliyun.oss.OSS;\nimport com.aliyun.oss.OSSClientBuilder;\nimport com.aliyun.oss.OSSException;\nimport java.io.ByteArrayInputStream;\n\npublic class Demo {\n\n    public static void main(String[] args) throws Exception {\n        // Endpoint以华东1（杭州）为例，其它Region请按实际情况填写。\n        String endpoint = \"https://oss-cn-hangzhou.aliyuncs.com\";\n        // 阿里云账号AccessKey拥有所有API的访问权限，风险很高。强烈建议您创建并使用RAM用户进行API访问或日常运维，请登录RAM控制台创建RAM用户。\n        String accessKeyId = \"yourAccessKeyId\";\n        String accessKeySecret = \"yourAccessKeySecret\";\n        // 填写Bucket名称，例如examplebucket。\n        String bucketName = \"examplebucket\";\n        // 填写Object完整路径，例如exampledir/exampleobject.txt。Object完整路径中不能包含Bucket名称。\n        String objectName = \"exampledir/exampleobject.txt\";\n\n        // 创建OSSClient实例。\n        OSS ossClient = new OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret);\n\n        try {\n            //写入的内容\n            String content = \"Hello OSS\";\n            ossClient.putObject(bucketName, objectName, new ByteArrayInputStream(content.getBytes()));\n        } catch (OSSException oe) {\n            System.out.println(\"Caught an OSSException, which means your request made it to OSS, \"\n                    + \"but was rejected with an error response for some reason.\");\n            System.out.println(\"Error Message:\" + oe.getErrorMessage());\n            System.out.println(\"Error Code:\" + oe.getErrorCode());\n            System.out.println(\"Request ID:\" + oe.getRequestId());\n            System.out.println(\"Host ID:\" + oe.getHostId());\n        } catch (ClientException ce) {\n            System.out.println(\"Caught an ClientException, which means the client encountered \"\n                    + \"a serious internal problem while trying to communicate with OSS, \"\n                    + \"such as not being able to access the network.\");\n            System.out.println(\"Error Message:\" + ce.getMessage());\n        } finally {\n            if (ossClient != null) {\n                ossClient.shutdown();\n            }\n        }\n    }\n}\n```\n\n### 工具类\n\n> 为了防止硬编码，使用了配置 project.properties\n\n```properties\n#OSS相关配置\noss.endpoint=https://oss-cn-hangzhou.aliyuncs.com\noss.accessKeyId=LTAI4GEH3ciDi5SVsvFVi6H2\noss.accessKeySecret=l0I6MhbsKPGH1tLmVE25L5naKKO79C\noss.bucketName=demo161\noss.url=https://demo161.oss-cn-hangzhou.aliyuncs.com\n```\n\n> springmvc配置\n\n```xml\n<!--上传配置-->\n    <bean id=\"multipartResolver\" class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\">\n        <!--支持的最大文件大小 单位是字节-->\n        <property name=\"maxUploadSize\" value=\"10240000000\"></property>\n        <!--每个文件大小-->\n        <!--  <property name=\"maxUploadSizePerFile\" value=\"1024000000\"></property>-->\n    </bean>\n```\n\n> 编写上传代码（包含加载配置文件）\n\n```java\npublic class OSSUtil {\n    //实例化Map的子类 Properties\n    private static Properties properties =new Properties();\n\n    static {\n        //任意一个类的Class对象中都存在一个方法getResourceAsStream   可以把properties读成输入字节流\n        InputStream inputStream = OSSUtil.class.getResourceAsStream(\"/project.properties\");\n        try {\n            properties.load(inputStream);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n    /**\n     *\n     * 外部只需要调用 这个方法，就可以完成文件的上传\n     * @param filePath  上传的路径\n     * @param multipartFile  上传的文件\n     * @return 返回文件的路径\n     */\n    public static  String uploadFile(String filePath, MultipartFile multipartFile){\n        InputStream inputStream = null;\n        OSS ossClient = null;\n        try {\n            //   springmvc中提供文件处理对象   multipartFile获取到上传文件的原始名称 filePath=a/b/c/   aaa.png\n            String originalFilename = multipartFile.getOriginalFilename();\n            //获取原文件名称的后缀   aaa.png     suffix=.png\n            String suffix = originalFilename.substring(originalFilename.\n                    lastIndexOf(\".\"));\n            //为了防止后上传的请求与先上传请求的文件名称一致，内容不同，被覆盖，所以一定要让保存到服务器上的文件名称不同\n            //随机生成一个名字\n            String newFileName = UUID.randomUUID()+suffix;\n            //springmvc中提供文件处理对象   multipartFile 直接获取上传文件的输入流\n            inputStream = multipartFile.getInputStream();\n            // 创建OSSClient实例。\n            ossClient = new OSSClientBuilder().build(properties.getProperty(\"oss.endpoint\"),properties.getProperty(\"oss.accessKeyId\"),properties.getProperty(\"oss.accessKeySecret\"));\n            // InputStream inputStream = new FileInputStream(filePath);\n            // 创建PutObject请求。  //filePath+\"/\"+newFileName = a/b/c/8e3f7b40-41bc-4125-bbcf-97b38dad4a2d.docx\n            ossClient.putObject( properties.getProperty(\"oss.bucketName\"), filePath+\"/\"+newFileName, inputStream);\n            //https://testqy1.oss-cn-beijing.aliyuncs.com/a/b/c/8e3f7b40-41bc-4125-bbcf-97b38dad4a2d.docx\n            return properties.getProperty(\"oss.url\")+\"/\"+filePath+\"/\"+newFileName;\n        } catch (Exception oe) {\n            oe.printStackTrace();\n        }  finally {\n            if (ossClient != null) {\n                ossClient.shutdown();\n            }\n            try {\n                if(inputStream!=null){\n                    inputStream.close();\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        return null;\n    }\n\n\n    public static void downloadFile(String filePath, HttpServletResponse response){\n        OSS ossClient = null;\n        BufferedInputStream bufferedInputStream = null;\n        BufferedOutputStream bufferedOutputStream = null;\n        //filePath = https://testqy1.oss-cn-beijing.aliyuncs.com/a/b/c/b57fb665-5619-4aea-8ea9-2da72bbf78df.png\n        //按照官网的文档filePath=a/b/c/b57fb665-5619-4aea-8ea9-2da72bbf78df.png\n        filePath = filePath.replace(properties.getProperty(\"oss.url\"),\"\");\n        String fileName  =  filePath.substring(filePath.lastIndexOf(\"/\")+1);\n        try {\n            // 创建OSSClient实例。\n            ossClient = new OSSClientBuilder().build(properties.getProperty(\"oss.endpoint\")\n                    , properties.getProperty(\"oss.accessKeyId\"),\n                    properties.getProperty(\"oss.accessKeySecret\"));\n            // ossObject包含文件所在的存储空间名称、文件名称、文件元信息以及一个输入流。\n            OSSObject ossObject = ossClient.getObject(properties.getProperty(\"oss.bucketName\"),\n                    filePath);\n            //得到要下载对象得输入流\n            //设置下载文件的头部信息     attachment  附件\n            response.setHeader(\"content-disposition\",\"attachment;filename=\"+ URLEncoder.encode(fileName,\"UTF-8\"));//文件名如果包含中文需要指定编码\n            //字节输出流  下载的本质把服务上的文件对象变成输入流（内存）   然后把输入流的内容输出到相应对象HttpServletResponse的输出流中\n            //套接缓存流，让下载文件速度提高\n            bufferedInputStream =new BufferedInputStream(ossObject.getObjectContent());\n            bufferedOutputStream =new BufferedOutputStream( response.getOutputStream());\n            //定义缓存字节数组\n            byte[]  bytes = new byte[2048];\n            //定义每次读取字节数\n            int readNum = -1;\n            //循环读写\n            while((readNum=bufferedInputStream.read(bytes))!=-1){\n                //System.out.println(readNum+\".............................\");\n                //写入Response输出流\n                bufferedOutputStream.write(bytes,0,readNum);\n            }\n            bufferedOutputStream.flush();\n           /* readNum=bufferedInputStream.read(bytes);\n            while(readNum!=0){\n                readNum=bufferedInputStream.read(bytes);\n            }*/\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                ossClient.shutdown();\n                if(bufferedOutputStream!=null){\n                    bufferedOutputStream.close();\n                }\n                if(bufferedInputStream!=null){\n                    bufferedInputStream.close();\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n\n## SSM\n\n> 需求:使用ssm框架完成对 account 表的增删改查操作。\n\n步骤分析：\n\n1. 准备数据库和表记录 \n\n2. 创建web项目 \n\n3. 编写mybatis在ssm环境中可以单独使用 \n\n4. 编写spring在ssm环境中可以单独使用 \n\n5. spring整合mybatis \n\n6. 编写springMVC在ssm环境中可以单独使用 \n\n7. spring整合springMVC\n\n### 环境搭建\n\n> 准备数据库和表记录\n\n```sql\nCREATE TABLE `account` (\n    `id` int(11) NOT NULL AUTO_INCREMENT,\n    `name` varchar(32) DEFAULT NULL,\n    `money` double DEFAULT NULL, PRIMARY KEY (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8;\n\ninsert into `account`(`id`,`name`,`money`)\nvalues(1,'tom',1000),\n    (2,'jerry',1000);\n```\n\n### 编写mybatis\n\n> 需求：基于mybatis先来实现对account表的查询\n\n相关 pom.xml 配置\n\n```xml\n\t<dependencies>\n        <!--mybatis坐标-->\n        <dependency>\n            <groupId>mysql</groupId>\n            <artifactId>mysql-connector-java</artifactId>\n            <version>5.1.47</version>\n        </dependency>\n        <dependency>\n            <groupId>com.alibaba</groupId>\n            <artifactId>druid</artifactId>\n            <version>1.1.15</version>\n        </dependency>\n        <dependency>\n            <groupId>org.mybatis</groupId>\n            <artifactId>mybatis</artifactId>\n            <version>3.5.1</version>\n        </dependency>\n        <dependency>\n            <groupId>junit</groupId>\n            <artifactId>junit</artifactId>\n            <version>4.12</version>\n        </dependency>\n    </dependencies>\n```\n\nAccount实体 com.aaa.pojo.\n\n```java\npublic class Account {\n    private Integer id;\n    private String name;\n    private Double money;\n    //get set toString\n}\n```\n\nAccountDao接口 com.aaa.dao\n\n```java\npublic interface AccountDao {\n    public List<Account> findAll();\n}\n```\n\nAccountDao.xml映射 resources.com.aaa.dao.\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n<mapper namespace=\"com.aaa.dao.AccountDao\">\n    <select id=\"findAll\" resultType=\"com.aaa.pojo.Account\">\n        select * from account\n    </select>\n</mapper>\n```\n\nmybatis核心配置文件 resources.\n\njdbc.properties\n\n```properties\njdbc.driver=com.mysql.jdbc.Driver\njdbc.url=jdbc:mysql:///spring_db?useSSL=false&useServerPrepStmts=true&characterEncoding=utf-8&serverTimezone=Asia/Shanghai\njdbc.username=root\njdbc.password=123456\n```\n\nSqlMapConfig.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE configuration\n        PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n<configuration>\n    <!--加载properties-->\n    <properties resource=\"jdbc.properties\"></properties>\n    <!--类型别名配置-->\n    <typeAliases>\n        <package name=\"com.aaa.pojo\"/>\n    </typeAliases>\n    <!--环境配置-->\n    <environments default=\"development\">\n        <!--使用MySQL环境-->\n        <environment id=\"development\">\n            <!--使用JDBC类型事务管理器-->\n            <transactionManager type=\"JDBC\"></transactionManager>\n            <!--使用连接池-->\n            <dataSource type=\"POOLED\">\n                <property name=\"driver\" value=\"${jdbc.driver}\"></property>\n                <property name=\"url\" value=\"${jdbc.url}\"></property>\n                <property name=\"username\" value=\"${jdbc.username}\"></property>\n                <property name=\"password\" value=\"${jdbc.password}\"></property>\n            </dataSource>\n        </environment>\n    </environments>\n    <!--加载映射配置-->\n    <mappers>\n        <package name=\"com.aaa.dao\"/>\n    </mappers>\n\n</configuration>\n```\n\n测试代码\n\n```java\npublic class MyBatisTest {\n    @Test\n    public void testMybatis() throws Exception {\n        // 加载核心配置文件\n        InputStream is = Resources.getResourceAsStream(\"SqlMapConfig.xml\");\n        // 获得sqlsession工厂对象\n        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);\n        // 获得sqlsession会话对象\n        SqlSession sqlSession = sqlSessionFactory.openSession();\n        // 获得mapper代理对象\n        AccountDao accountDao = sqlSession.getMapper(AccountDao.class);\n        // 执行\n        List<Account> list = accountDao.findAll();\n        for (Account account : list) {\n            System.out.println(account);\n        }\n        // 释放资源\n        sqlSession.close();\n    }\n}\n```\n\n### 编写spring\n\n相关 pom.xml 配置\n\n```xml\n\t\t<!--spring坐标-->\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-context</artifactId>\n            <version>5.1.5.RELEASE</version>\n        </dependency>\n        <dependency>\n            <groupId>org.aspectj</groupId>\n            <artifactId>aspectjweaver</artifactId>\n            <version>1.8.13</version>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-jdbc</artifactId>\n            <version>5.1.5.RELEASE</version>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-tx</artifactId>\n            <version>5.1.5.RELEASE</version>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-test</artifactId>\n            <version>5.1.5.RELEASE</version>\n        </dependency>\n```\n\nAccountService接口 com.aaa.service.\n\n```java\npublic interface AccountService {\n    public List<Account> findAll();\n}\n```\n\nAccountServiceImpl实现 com.aaa.service.impl.\n\n```java\n@Service\npublic class AccountServiceImpl implements AccountService {\n    @Override\n    public List<Account> findAll() {\n        System.out.println(\"findAll执行了....\");\n        return null;\n    }\n}\n```\n\nspring核心配置文件 applicationContext.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:tx=\"http://www.springframework.org/schema/tx\"\n       xmlns:aop=\"http://www.springframework.org/schema/aop\"\n       xsi:schemaLocation=\" http://www.springframework.org/schema/beans \nhttp://www.springframework.org/schema/beans/spring-beans.xsd \nhttp://www.springframework.org/schema/context \nhttp://www.springframework.org/schema/context/spring-context.xsd \nhttp://www.springframework.org/schema/tx \nhttp://www.springframework.org/schema/tx/spring-tx.xsd \nhttp://www.springframework.org/schema/aop \nhttp://www.springframework.org/schema/aop/spring-aop.xsd\">\n\n    <!--注解组件扫描-->\n    <context:component-scan base-package=\"com.aaa.service\"/>\n</beans>\n```\n\n测试代码\n\n```java\n@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration(\"classpath:applicationContext.xml\")\npublic class SpringTest {\n    @Autowired\n    private AccountService accountService;\n\n    @Test\n    public void testSpring() throws Exception {\n        List<Account> list = accountService.findAll();\n        System.out.println(list);\n    }\n}\n```\n\n### spring整合mybatis\n\n**整合思想**\n\n将mybatis接口代理对象的创建权交给spring管理，我们就可以把dao的代理对象注入到service中， 此时也就完成了spring与mybatis的整合了。\n\n> 导入整合包\n\n```xml\n\t\t<!--mybatis整合spring坐标-->\n        <dependency>\n            <groupId>org.mybatis</groupId>\n            <artifactId>mybatis-spring</artifactId>\n            <version>1.3.1</version>\n        </dependency>\n```\n\nspring配置文件applicationContext.xml管理mybatis 注意：此时可以将mybatis主配置文件删除。\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:tx=\"http://www.springframework.org/schema/tx\"\n       xmlns:aop=\"http://www.springframework.org/schema/aop\"\n       xsi:schemaLocation=\" http://www.springframework.org/schema/beans\nhttp://www.springframework.org/schema/beans/spring-beans.xsd\nhttp://www.springframework.org/schema/context\nhttp://www.springframework.org/schema/context/spring-context.xsd\nhttp://www.springframework.org/schema/tx\nhttp://www.springframework.org/schema/tx/spring-tx.xsd\nhttp://www.springframework.org/schema/aop\nhttp://www.springframework.org/schema/aop/spring-aop.xsd\">\n\n    <!--注解组件扫描-->\n    <context:component-scan base-package=\"com.aaa.service\"/>\n\n    <!--spring整合mybatis-->\n    <context:property-placeholder location=\"classpath:jdbc.properties\"/>\n    <bean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\">\n        <property name=\"driverClassName\" value=\"${jdbc.driver}\"/>\n        <property name=\"url\" value=\"${jdbc.url}\"/>\n        <property name=\"username\" value=\"${jdbc.username}\"/>\n        <property name=\"password\" value=\"${jdbc.password}\"/>\n    </bean>\n\n    <!--SqlSessionFactory创建交给spring的IOC容器-->\n    <bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\">\n        <!--数据库环境配置-->\n        <property name=\"dataSource\" ref=\"dataSource\"/>\n        <!--类型别名配置-->\n        <property name=\"typeAliasesPackage\" value=\"com.aaa.pojo\"/>\n        <!--如果要引入mybatis主配置文件，可以通过如下配置-->\n        <!--<property name=\"configLocation\" value=\"classpath:SqlMapConfig.xml\"/>-->\n    </bean>\n    <!--映射接口扫描配置，由spring创建代理对象，交给IOC容器-->\n    <bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\">\n        <property name=\"basePackage\" value=\"com.aaa.dao\"/>\n    </bean>\n</beans>\n```\n\n修改AccountServiceImpl\n\n```java\n@Service\npublic class AccountServiceImpl implements AccountService {\n    @Autowired\n    private AccountDao accountDao;\n    @Override\n    public List<Account> findAll() {\n        return accountDao.findAll();\n    }\n}\n```\n\n### 编写springMVC在\n\n需求：访问到controller里面的方法查询所有账户，并跳转到list.jsp页面进行列表展示\n\n相关 pom.xml 配置\n\n```xml\n<packaging>war</packaging>\t\t\n\n\t\t<!--springMVC坐标-->\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-webmvc</artifactId>\n            <version>5.1.5.RELEASE</version>\n        </dependency>\n        <dependency>\n            <groupId>javax.servlet</groupId>\n            <artifactId>javax.servlet-api</artifactId>\n            <version>3.1.0</version>\n            <scope>provided</scope>\n        </dependency>\n        <dependency>\n            <groupId>javax.servlet.jsp</groupId>\n            <artifactId>jsp-api</artifactId>\n            <version>2.2</version>\n            <scope>provided</scope>\n        </dependency>\n        <dependency>\n            <groupId>jstl</groupId>\n            <artifactId>jstl</artifactId>\n            <version>1.2</version>\n        </dependency>\n```\n\n> 新建 list.jsp 页面 webapp.\n\nspringMVC核心配置文件 spring-mvc.xml\n\n```xml\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:mvc=\"http://www.springframework.org/schema/mvc\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\nhttp://www.springframework.org/schema/beans/spring-beans.xsd\nhttp://www.springframework.org/schema/mvc\nhttp://www.springframework.org/schema/mvc/spring-mvc.xsd\nhttp://www.springframework.org/schema/context\nhttp://www.springframework.org/schema/context/spring-context.xsd\">\n\n    <!--组件扫描-->\n    <context:component-scan base-package=\"com.aaa.controller\"/>\n    <!--mvc注解增强-->\n    <mvc:annotation-driven/>\n    <!--视图解析器-->\n    <bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\">\n        <property name=\"prefix\" value=\"/\"/>\n        <property name=\"suffix\" value=\".jsp\"/>\n    </bean>\n    <!--实现静态资源映射-->\n    <mvc:default-servlet-handler/>\n</beans>\n```\n\nAccountController类 com.aaa.controller.\n\n```java\n@Controller\n@RequestMapping(\"/account\")\npublic class AccountController {\n    //记得创建Account有参构造\n    @RequestMapping(\"/findAll\")\n    public String findAll(Model model) {\n        List<Account> list = new ArrayList<>();\n        list.add(new Account(1,\"张三\",1000d));\n        list.add(new Account(2,\"李四\",1000d));\n        model.addAttribute(\"list\", list);\n        return \"list\";\n    }\n}\n```\n\n前端控制器DispathcerServlet webapp.WEB-INF.web.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\"\n         version=\"4.0\">\n\n    <!--前端控制器-->\n    <servlet>\n        <servlet-name>DispatcherServlet</servlet-name>\n        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n        <init-param>\n            <param-name>contextConfigLocation</param-name>\n            <param-value>classpath:spring-mvc.xml</param-value>\n        </init-param>\n        <load-on-startup>2</load-on-startup>\n    </servlet>\n    <servlet-mapping>\n        <servlet-name>DispatcherServlet</servlet-name>\n        <url-pattern>/</url-pattern>\n    </servlet-mapping>\n    <!--post中文处理-->\n    <filter>\n        <filter-name>CharacterEncodingFilter</filter-name>\n        <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>\n        <init-param>\n            <param-name>encoding</param-name>\n            <param-value>UTF-8</param-value>\n        </init-param>\n    </filter>\n    <filter-mapping>\n        <filter-name>CharacterEncodingFilter</filter-name>\n        <url-pattern>/*</url-pattern>\n    </filter-mapping>\n</web-app>\n```\n\n> Tomcat 运行\n\n### spring整合springMVC\n\n**整合思想**\n\nspring和springMVC其实根本就不用整合，本来就是一家。\n\n但是我们需要做到spring和web容器整合，让web容器启动的时候自动加载spring配置文件，web容器销毁的时候spring的ioc容器也销毁。\n\n**spring和web容器整合**\n\nContextLoaderListener加载【掌握】\n\n可以使用spring-web包中的ContextLoaderListener监听器，可以监听servletContext容器的创建和销毁，来同时创建或销毁IOC容器。\n\nweb.xml\n\n```xml\n\t<!--spring 与 web容器整合-->\n    <listener>\n        <listener-class>\n            org.springframework.web.context.ContextLoaderListener\n        </listener-class>\n    </listener>\n    <context-param>\n        <param-name>contextConfigLocation</param-name>\n        <param-value>classpath:applicationContext.xml</param-value>\n    </context-param>\n```\n\n修改AccountController\n\n```java\n@Controller\n@RequestMapping(\"/account\")\npublic class AccountController {\n    @Autowired\n    private AccountService accountService;\n\n    @RequestMapping(\"/findAll\")\n    public String findAll(Model model) {\n        List<Account> list = accountService.findAll();\n        model.addAttribute(\"list\", list);\n        return \"list\";\n    }\n}\n```\n\n> Tomcat 运行","tags":["SpringMVC"],"categories":["学习之路"]},{"title":"InterviewQuestions","url":"/2022/11/20/InterviewQuestions/","content":"\n## HashMap 解决hash冲突\n\n### hash冲突产生原因\n\nhash冲突是通过对数据进行再压缩，提高效率的一种办法。由于通过hash函数产生的hash值是有限的，当数据比较多时，经过hash函数处理后仍然有不同的数据对应相同的hash值，这就产生了hash冲突。\n\n### 如何解决hash碰撞\n\nJava 中的 HashMap 采用链表法来解决Hash冲突。原理，即具有相同桶下标的键值对使用一个链表储存。当链表变长时，查找和添加（需要确定 key 是否已经存在）都需要遍历这个链表，速度会变慢。JDK 1.8 后加入了链表转换为红黑树的机制，但是红黑树的转换并不是一个廉价的操作，只有当链表长度大于等于 TREEIFY_THRESHOLD（8） 才会 treeify（treeify方法是TreeNode类的一个实例方法，通过TreeNode对象调用，实现该对象打头的链表转换为树结构），而当HashMap的红黑树的元素小于等于6时重新转化为链表结构。实际上并不是只要链表长度大于 8 就会 treeify。当 table.length（桶的个数）小于 MIN_TREEIFY_CAPACITY（64） 时会优先扩容而不是转换为红黑树。\n\n### 红黑树\n\n**二叉搜索树具有以下特点：**\n\n1. 节点的左孩子的值小于节点本身；\n2. 节点的右孩子的值大于节点本身；\n3. 左右子树同样为二叉搜索树；\n\n**最终效果是:**\n\n- 节点左子树的所有节点的值都小于节点本身；\n- 节点右子树的所有节点的值都大于节点本身；\n- 对二叉搜素树的一次中序遍历就是一个递增有序序列\n\n![BinarySearchTree](https://image.aobayu.cn/images/BinarySearchTree.png)**二叉平衡树(AVL)** ：二叉平衡树是在二叉搜素树的基础上加上了限制：任意节点，左右子树的高度差不能超过1。这个约束常常借助左旋和右旋操作实现。\n\n**左旋**：逆时针旋转两个节点，让一个节点被其右子节点取代，而该节点成为右子节点的左子节点\n\n左旋操作步骤如下：\n\n首先断开节点PL与右子节点G的关系，同时将其右子节点的引用指向节点C2；然后断开节点G与左子节点C2的关系，同时将G的左子节点的应用指向节点PL\n\n![L-Spin](https://image.aobayu.cn/images/L-Spin.png)\n\n**右旋**：顺时针旋转两个节点，让一个节点被其左子节点取代，而该节点成为左子节点的右子节点\n\n右旋操作步骤如下：\n\n首先断开节点G与左子节点PL的关系，同时将其左子节点的引用指向节点C2；然后断开节点PL与右子节点C2的关系，同时将PL的右子节点的应用指向节点G\n\n![](https://image.aobayu.cn/images/R-Spin.png)\n\n**红黑树（带有自平衡功能的AVL树）**\n\n红黑树的英文是“Red-Black Tree\"，简称R-B Tree。它是一种不严格的平衡二叉查找树。\n\n**红黑树的规则特性：**\n\n1. 节点分为红色或者黑色；\n2. 根节点必为黑色；\n3. 叶子节点都为黑色，且为null。也就是说，叶子节点不存储数据；\n4. 连接红色节点的两个子节点都为黑色（红黑树不会出现相邻的红色节点）；\n5. 从任意节点出发，到其每个叶子节点的路径中包含相同数量的黑色节点；\n\n![R-B Tree](https://image.aobayu.cn/images/RBTree.png)\n\n### 为什么 HashMap选择红黑树\n\n因为红黑树的特性让它拥有较高的查询性能的同时，避免维持平衡带来的很大开销。\n\n红黑树相比AVL树，在检索的时候效率其实差不多，都是通过平衡来二分查找。但对于插入删除等操作效率提高很多。红黑树不像AVL树一样追求绝对的平衡，他允许局部很少的不完全平衡，这样对于效率影响不大，但省去了很多没有必要的调平衡操作，AVL树调平衡有时候代价较大，所以效率不如红黑树，在现在很多地方底层都是红黑树。\n\n红黑树的高度只比高度平衡的AVL树的高度（log2n）仅仅大了一倍，在性能上却好很多。\n\nHashMap在里面就是链表加上红黑树的一种结构，这样利用了链表对内存的使用率以及红黑树的高效检索，是一种很happy的数据结构。\n\nAVL树是一种高度平衡的二叉树，所以查找的非常高，但是，有利就有弊，AVL树为了维持这种高度的平衡，就要付出更多代价。每次插入、删除都要做调整，就比较复杂、耗时。所以，对于有频繁的插入、删除操作的数据集合，使用AVL树的代价就有点高了。\n\n红黑树只是做到了近似平衡，并不严格的平衡，所以在维护的成本上，要比AVL树要低。\n\n所以，红黑树的插入、删除、查找各种操作性能都比较稳定。对于工程应用来说，要面对各种异常情况，为了支撑这种工业级的应用，我们更倾向于这种性能稳定的平衡二叉查找树。\n\n## 线程和进程的概念\n\n进程是系统中正在运行的一个程序，程序一旦运行就是进程。\n\n进程可以看成程序执行的一个实例。进程是系统资源分配的独立实体，每个进程都拥有独立的地址空间。一个进程无法访问另一个进程的变量和数据结构，如果想让一个进程访问另一个进程的资源，需要使用进程间通信，比如管道，文件，套接字等。\n\n一个进程可以拥有多个线程，每个线程使用其所属进程的栈空间。线程与进程的一个主要区别是，统一进程内的一个主要区别是，同一进程内的多个线程会共享部分状态，多个线程可以读写同一块内存（一个进程无法直接访问另一进程的内存）。同时，每个线程还拥有自己的寄存器和栈，其他线程可以读写这些栈内存。\n\n线程是进程的一个实体，是进程的一条执行路径。\n\n线程是进程的一个特定执行路径。当一个线程修改了进程的资源，它的兄弟线程可以立即看到这种变化。\n\n### 创造进程的三种方式\n\n| 基于什么创建 | 创建的方式         |\n| ------------ | ------------------ |\n| Thread类     | 继承`Thread`类     |\n| Runnable接口 | 实现`Runnable`接口 |\n| callable接口 | 实现`callable`接口 |\n\n**通过Thread类创建**\n\n**步骤**\n\n- 自定义线程类继承`Thread`类\n- 重写`run()`方法，编写线程执行体（当成`main()`方法用）\n- 创建线程对象，调用`start()`方法启动线程\n\n**通过实现Runnable接口来创建线程**\n\n**创建步骤**\n\n- 创建一个实现了`Runnable`接口的类\n- 实现类去实现`Runnable`接口中的抽象方法：`run()`\n- 创建实现类的对象\n- 将此对象作为参数传递到`Thread`类的构造器中，创建`Thread`类的对象\n- 通过`Thread`类的对象调用`start()`\n- 这里的`start()`首先启动了当前的线程，然后调用了`Runnable`类型的target的`run()`\n\n### 线程的生命周期\n\n**新建状态（New）：**\n\n当线程对象对创建后，即进入了新建状态，如：Thread t = new MyThread();\n\n**就绪状态（Runnable）：**\n\n当调用线程对象的start()方法（t.start();），线程即进入就绪状态。处于就绪状态的线程，只是说明此线程已经做好了准备，随时等待CPU调度执行，并不是说执行了t.start()此线程立即就会执行；\n\n**运行状态（Running）：**\n\n当CPU开始调度处于就绪状态的线程时，此时线程才得以真正执行，即进入到运行状态。注：就   绪状态是进入到运行状态的唯一入口，也就是说，线程要想进入运行状态执行，首先必须处于就绪状态中；\n\n**阻塞状态（Blocked）：**\n\n处于运行状态中的线程由于某种原因，暂时放弃对CPU的使用权，停止执行，此时进入阻塞状态，直到其进入到就绪状态，才 有机会再次被CPU调用以进入到运行状态。根据阻塞产生的原因不同，阻塞状态又可以分为三种：\n\n**等待阻塞：**运行状态中的线程执行wait()方法，使本线程进入到等待阻塞状态；\n\n**同步阻塞 :** 线程在获取synchronized同步锁失败(因为锁被其它线程所占用)，它会进入同步阻塞状态；\n\n**其他阻塞 :** 通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。\n\n**死亡状态（Dead）：**\n\n线程执行完了或者因异常退出了run()方法，该线程结束生命周期。","tags":["InterviewQuestions"],"categories":["学习之路"]},{"title":"Spring","url":"/2022/11/16/Spring/","content":"\n## Spring\n\nSpring是分层的 Java SE/EE应用 full-stack(全栈式) 轻量级开源框架。\n\n提供了表现层 SpringMVC和持久层 Spring JDBC Template以及 业务层 事务管理等众多的企业级应用 技术，还能整合开源世界众多著名的第三方框架和类库，逐渐成为使用最多的Java EE 企业应用开源框架。\n\n**两大核心**：以 IOC（Inverse Of Control：控制反转）和 AOP（Aspect Oriented Programming：面向 切面编程）为内核。\n\n**Spring优势**\n\n- 方便解耦，简化开发\n  - Spring就是一个容器，可以将所有对象创建和关系维护交给Spring管理\n  - 什么是耦合度？对象之间的关系，通常说当一个模块(对象)更改时也需要更改其他模块(对象)，这就是耦合，耦合度过高会使代码的维护成本增加。要尽量解耦\n\n- AOP编程的支持\n  - Spring提供面向切面编程，方便实现程序进行权限拦截，运行监控等功能。\n\n- 声明式事务的支持\n  - 通过配置完成事务的管理，无需手动编程\n\n- 方便测试，降低JavaEE API的使用\n  - Spring对Junit4支持，可以使用注解测试\n\n- 方便集成各种优秀框架\n  - 不排除各种优秀的开源框架，内部提供了对各种优秀框架的直接支持\n\n## 初识IOC\n\n**控制反转（Inverse Of Control）**不是什么技术，而是一种设计思想。它的目的是指导我们设计出更 加松耦合的程序。\n\n> 控制：在java中指的是对象的控制权限（创建、销毁）\n>\n> 反转：指的是对象控制权由原来 由开发者在类中手动控制 反转到 由Spring容器控制 \n\n**自定义IOC容器**\n\n需求：\n\n实现service层与dao层代码解耦合\n\n步骤分析：\n\n1. 创建java项目，导入自定义IOC相关坐标\n\n2. 编写Dao接口和实现类\n\n3. 编写Service接口和实现类\n\n4. 编写测试代码\n\n**实现**\n\n创建java项目，导入自定义IOC相关坐标\n\npom.xml\n\n```xml\n\t<dependencies>\n        <dependency>\n            <groupId>dom4j</groupId>\n            <artifactId>dom4j</artifactId>\n            <version>1.6.1</version>\n        </dependency>\n        <dependency>\n            <groupId>jaxen</groupId>\n            <artifactId>jaxen</artifactId>\n            <version>1.1.6</version>\n        </dependency>\n        <dependency>\n            <groupId>junit</groupId>\n            <artifactId>junit</artifactId>\n            <version>4.12</version>\n        </dependency>\n    </dependencies>\n```\n\n编写Dao接口和实现类 com.aaa.dao.\n\n```java\npublic interface UserDao {\n    public void save();\n}\n```\n\n```java\npublic class UserImpl implements UserDao {\n    @Override\n    public void save() {\n        System.out.println(\"保存成功....\");\n    }\n}\n```\n\n编写Service接口和实现类 com.aaa.service.\n\n```java\npublic interface UserService {\n    public void save();\n}\n```\n\n```java\npublic class UserServiceImpl implements UserService{\n    private UserDao userDao;\n    public void save(){\n        userDao = new UserImpl();\n        userDao.save();\n    }\n}\n```\n\n编写测试代码\n\n```java\npublic class UserTest {\n    @Test\n    public void testSave() throws Exception {\n        UserService userService = new UserServiceImpl();\n        userService.save();\n    }\n}\n```\n\n当前service对象和dao对象耦合度太高，而且每次new的都是一个新的对象，导致服务器压力过大。\n\n> 解耦合的原则是编译期不依赖，而运行期依赖就行了。\n\n把所有需要创建对象的信息定义在配置文件中 resources.beans.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<beans>\n    <bean id=\"userDao\" class=\"com.aaa.dao.impl.UserImpl\"></bean>\n</beans>\n```\n\n编写BeanFactory工具类 com.aaa.utils.\n\n```java\npublic class BeanFactory {\n    /* 声明集合用来保存bean  */\n    private static Map<String, Object> ioc = new HashMap<>();\n\n    static {\n        try {\n            /* 1.读取配置文件 */\n            InputStream in =\n                    BeanFactory.class.getClassLoader().getResourceAsStream(\"beans.xml\");\n            /* 2.解析xml */\n            SAXReader saxReader = new SAXReader();\n            Document document = saxReader.read(in);\n            /* 3.编写xpath表达式 */\n            String xpath = \"//bean\";\n            /* 4.获取所有的bean标签 */\n            List<Element> list = document.selectNodes(xpath);\n            /* 5.遍历并创建对象实例，设置到map集合中 */\n            for (Element element : list) {\n                String id = element.attributeValue(\"id\");\n                String className = element.attributeValue(\"class\");\n                Object object = Class.forName(className).newInstance();\n                ioc.put(id, object);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    // 获取指定id的对象实例\n    public static Object getBean(String beandId) {\n        return ioc.get(beandId);\n    }\n}\n```\n\n修改UserServiceImpl实现类\n\n```java\npublic class UserServiceImpl implements UserService{\n    private UserDao userDao;\n    public void save(){\n        userDao = (UserDao) BeanFactory.getBean(\"userDao\");\n        userDao.save();\n    }\n}\n```\n\n**知识小结**\n\n其实升级后的BeanFactory就是一个简单的Spring的IOC容器所具备的功能。\n\n之前我们需要一个userDao实例，需要开发者自己手动创建 new UserDao();\n\n现在我们需要一个userdao实例，直接从spring的IOC容器获得，对象的创建权交给了spring控制\n\n最终目标：代码解耦合\n\n## Spring快速入门\n\n需求：借助spring的IOC实现service层与dao层代码解耦合\n\n步骤分析：\n\n1. 创建java项目，导入spring开发基本坐标\n\n2. 编写Dao接口和实现类\n\n3. 创建spring核心配置文件\n\n4. 在spring配置文件中配置 UserImpl\n\n5. 使用spring相关API获得Bean实例\n\n**实现**\n\n创建java项目，导入spring开发基本坐标\n\n```xml\n\t<dependencies>\n        <dependency>\n            <groupId>dom4j</groupId>\n            <artifactId>dom4j</artifactId>\n            <version>1.6.1</version>\n        </dependency>\n        <dependency>\n            <groupId>jaxen</groupId>\n            <artifactId>jaxen</artifactId>\n            <version>1.1.6</version>\n        </dependency>\n        <dependency>\n            <groupId>junit</groupId>\n            <artifactId>junit</artifactId>\n            <version>4.12</version>\n        </dependency>\n        <!--spring开发-->\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-context</artifactId>\n            <version>5.1.5.RELEASE</version>\n        </dependency>\n    </dependencies>\n```\n\n编写Dao接口和实现类 com.aaa.dao.\n\n```java\npublic interface UserDao {\n    public void save();\n}\n```\n\n```java\npublic class UserImpl implements UserDao {\n    @Override\n    public void save() {\n        System.out.println(\"保存成功....\");\n    }\n}\n```\n\n创建spring核心配置文件 resources.applicationContext.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n    http://www.springframework.org/schema/beans/spring-beans.xsd\">\n    <!--在spring配置文件中配置 UserDaoImpl-->\n    <bean id=\"userDao\" class=\"com.aaa.dao.impl.UserImpl\"></bean>\n</beans>\n```\n\n使用spring相关API获得Bean实例\n\n```java\n\t@Test\n    public void testSave() throws Exception {\n        /* 配置文件一加载直接创建出来对象 */\n        /* 加载同时保存bean到容器中 */\n        ApplicationContext applicationContext =\n                new ClassPathXmlApplicationContext(\"applicationContext.xml\");\n        /* 直接从容器中获取 */\n        UserDao userDao = (UserDao) applicationContext.getBean(\"userDao\");\n        userDao.save();\n    }\n\t@Test\n    public void testSave2() throws Exception {\n        XmlBeanFactory xmlBeanFactory = new XmlBeanFactory(new \t\tClassPathResource(\"applicationContext.xml\"));\n        /* 使用时才会去初始化创建出来 */\n        UserDao userDao = (UserDao) xmlBeanFactory.getBean(\"userDao\");\n        userDao.save();\n    }\n```\n\n## Spring相关API\n\nSpring的API体系异常庞大，我们现在只关注两个BeanFactory和ApplicationContext\n\n### BeanFactory\n\nBeanFactory是 IOC 容器的核心接口，它定义了IOC的基本功能\n\n> 特点：在第一次调用getBean()方法时，创建指定对象的实例\n\n```java\n\t@Test\n    public void testSave2() throws Exception {\n        /*  核心接口，不会创建bean对象存到容器中 */\n        XmlBeanFactory xmlBeanFactory = new XmlBeanFactory(new ClassPathResource(\"applicationContext.xml\"));\n        /* getBean的时候才真正创建bean对象 */\n        UserDao userDao = (UserDao) xmlBeanFactory.getBean(\"userDao\");\n        userDao.save();\n    }\n```\n\n### ApplicationContext\n\n代表应用上下文对象，可以获得spring中IOC容器的Bean对象\n\n> 特点：在spring容器启动时，加载并创建所有对象的实例\n\n**常用实现类** \n\n1. ClassPathXmlApplicationContext 它是从类的根路径下加载配置文件 推荐使用这种。 \n\n2. FileSystemXmlApplicationContext 它是从磁盘路径上加载配置文件，配置文件可以在磁盘的任意位置。 \n\n3. AnnotationConfigApplicationContext 当使用注解配置容器对象时，需要使用此类来创建 spring 容器。它用来读取注解。\n\n```java\n\t@Test\n    public void test(){\n        /* 获取到了spring上下文对象，借助上下文对象可以获取到IOC容器中的bean对象,\n        加载的同时就创建了bean对象存到容器中 */\n        ApplicationContext classPathXmlApplicationContext = new ClassPathXmlApplicationContext(\"applicationContext.xml\");\n        \n        //ApplicationContext fileSystemXmlApplicationContext = new FileSystemXmlApplicationContext(\"D:\\\\xxx\\\\xxx\\\\src\\\\main\\\\resources\\\\applicationContext.xml\");\n\t\t/*使用上下文对象从IOC容器中获取到了bean对象\n\t\t根据beanid在容器中找对应的bean对象 */\n        //UserDao userDao = (UserDao) fileSystemXmlApplicationContext.getBean(\"userDao\");\n        \n        /*根据类型在容器中进行查询：有可能报错的情况：根据当前类型匹配到多个实例 */\n        UserDao userDao = classPathXmlApplicationContext.getBean(\"userDao\",UserDao.class);\n        /* 调用方法 */\n        userDao.save();\n    }\n```\n\n**常用方法** \n\n1. Object getBean(String name)：根据Bean的id从容器中获得Bean实例，返回是Object，需要强转。\n\n2. <> T getBean(Class<> requiredType)：根据类型从容器中匹配Bean实例，当容器中相同类型的Bean有多个时，则此方法会报错。\n\n3. <> T getBean(String name,Class<> requiredType)：根据Bean的id和类型获得Bean实例，解决容器中相同类型Bean有多个情况。\n\n## Spring配置文件\n\n### Bean标签基本配置 \n\n```xml\n<bean id=\"\" class=\"\" scope=\"\"></bean>\n<!--用于配置对象交由Spring来创建。\n\t基本属性：\n  \tid：Bean实例在Spring容器中的唯一标识\n  \tclass：Bean的全限定名\n\t默认情况下它调用的是类中的无参构造函数，如果没有无参构造函数则不能创建成功-->\n```\n\n**Bean标签范围配置**\n\nscope属性指对象的作用范围，取值如下：\n\n| 取值范围  | 说明                                                         |\n| --------- | ------------------------------------------------------------ |\n| singleton | 默认值，单例的                                               |\n| prototype | 多例的，生成一个新的对象，占内存空间                         |\n| request   | WEB项目中，Spring创建一个Bean的对象，将对象存入到request域中 |\n| session   | WEB项目中，Spring创建一个Bean的对象，将对象存入到session域中 |\n\n- 当scope的取值为singleton时\n  - Bean的实例化个数：1个\n  - Bean的实例化时机：当Spring核心文件被加载时，实例化配置的Bean实例\n\n- Bean的生命周期：\n  - 对象创建：当应用加载，创建容器时，对象就被创建了\n  - 对象运行：只要容器在，对象一直活着\n  - 对象销毁：当应用卸载，销毁容器时，对象就被销毁了\n\n- 当scope的取值为prototype时\n  - Bean的实例化个数：多个\n  - Bean的实例化时机：当调用getBean()方法时实例化Bean\n- Bean的生命周期：\n  - 对象创建：当使用对象时，创建新的对象实例\n  - 对象运行：只要对象在使用中，就一直活着\n  - 对象销毁：当对象长时间不用时，被 Java 的垃圾回收器回收了\n\n### Bean生命周期配置\n\n```xml\n<bean id=\"\" class=\"\" scope=\"\" init-method=\"\" destroy-method=\"\"></bean>\n<!-- init-method：指定类中的初始化方法名称 -->\n<!-- destroy-method：指定类中销毁方法名称 -->\n```\n\n```xml\n<bean id=\"userDao\" class=\"com.aaa.dao.impl.UserImpl\" init-method=\"init\" destroy-method=\"destroy\"></bean>\n```\n\n```java\npublic class UserImpl implements UserDao {\n    @Override\n    public void save() {\n        System.out.println(\"保存成功....\");\n    }\n    public void init(){\n        System.out.println(\"init\");\n    }\n    public void destroy(){\n        System.out.println(\"destroy\");\n    }\n}\n```\n\n### Bean实例化三种方式\n\n**无参构造方法实例化**\n\n默认无参构造方法来创建类对象，如果bean中没有默认无参构造函数，将会创建失败\n\n```xml\n<bean id=\"userDao\" class=\"com.aaa.dao.impl.UserImpl\"/>\n```\n\n**工厂静态方法实例化**\n用静态方法，去创建出来一个bean，手动创建一个bean，不用Spring去创建 com.aaa.utils.StaticFactoryBean\n\n```java\npublic class StaticFactoryBean {\n    public static UserDao createUserDao(){\n        return new UserImpl();\n    }\n}\n```\n\n```xml\n<bean id=\"userDao\" class=\"com.aaa.utils.StaticFactoryBean\" factory-method=\"createUserDao\" />\n```\n\n**工厂普通方法实例化**\n\ncom.aaa.utils.DynamicFactoryBean\n\n```java\npublic class DynamicFactoryBean {\n    public UserDao createUserDao(){\n        return new UserImpl();\n    }\n}\n```\n\n```xml\n<bean id=\"dynamicFactoryBean\" class=\"com.aaa.utils.DynamicFactoryBean\"/>\n<!--FactoryBean 用来创建一类bean id=\"dynamicFactoryBean\"-->\n<bean id=\"userDao2\" factory-bean=\"dynamicFactoryBean\" factory-method=\"createUserDao\"/>\n```\n\n### Bean依赖注入方式\n\n**构造方法**\n\n在UserServiceImpl中创建有参构造\n\n```java\npublic class UserServiceImpl implements UserService{\n    private UserDao userDao;\n    public UserServiceImpl(UserDao userDao) {\n        this.userDao = userDao;\n    }\n    @Override\n    public void save() {\n        userDao.save();\n    }\n}\n```\n\n配置Spring容器调用有参构造时进行注入\n\n```xml\n\t<bean id=\"userDao\" class=\"com.aaa.dao.impl.UserImpl\"/>\n    <bean id=\"userService\" class=\"com.aaa.service.UserServiceImpl\">\n        <!-- <constructor-arg index=\"0\" type=\"com.aaa.dao.UserDao\" ref=\"userDao\"/> -->\n        <constructor-arg name=\"userDao\" ref=\"userDao\"/>\n    </bean>\n```\n\n标签 constructor-arg\n\n- name属性对应的值为构造函数中方法形参的参数名，必须要保持一致。\n- ref属性指向的是spring的IOC容器中其他bean对象。\n\n测试\n\n```java\n\t@Test\n    public void testSave() throws Exception {\n        ApplicationContext classPathXmlApplicationContext =\n            new ClassPathXmlApplicationContext(\"applicationContext.xml\");\n    \tUserService userService =\n            (UserService) classPathXmlApplicationContext.getBean(\"userService\");\n\t\tuserService.save();\n    }\n```\n\n**set方法**\n\n在UserServiceImpl中创建set方法\n\n```java\npublic class UserServiceImpl implements UserService{\n    private UserDao userDao;\n    public void setUserDao(UserDao userDao) {\n        this.userDao = userDao;\n    }\n    @Override\n    public void save() {\n        userDao.save();\n    }\n}\n```\n\n配置Spring容器调用set方法进行注入\n\n```xml\n\t<bean id=\"userDao\" class=\"com.aaa.dao.impl.UserImpl\"/>\n    <bean id=\"userService\" class=\"com.aaa.service.UserServiceImpl\">\n        <constructor-arg name=\"userDao\" ref=\"userDao\"/>\n    </bean>\n```\n\n**P命名空间注入(了解)**\n\nP命名空间注入本质也是set方法注入，但比起上述的set方法注入更加方便，主要体现在配置文件中\n\n需要引入P命名空间\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd\"\n       <!--P命名空间-->\n       xmlns:p=\"http://www.springframework.org/schema/p\">\n```\n\n修改注入方式\n\n```xml\n<bean id=\"userDao\" class=\"com.aaa.dao.impl.UserImpl\"/>\n<bean id=\"userService\" class=\"com.aaa.service.UserServiceImpl\" p:userDao-ref=\"userDao\"/>\n```\n\n### Bean依赖注入的数据类型\n\n除了对象的引用可以注入，普通数据类型和集合都可以在容器中进行注入。 以set方法注入为例，演示普通数据类型和集合数据类型的注入。\n\n**注入普通数据类型**\n\n```java\npublic class User {\n    private String username;\n    private String age;\n    \n    public void setUsername(String username) {\n        this.username = username;\n    }\n    public void setAge(String age) {\n        this.age = age;\n    }\n\n    @Override\n    public String toString() {\n        return \"User{\" +\n                \"username='\" + username + '\\'' +\n                \", age='\" + age + '\\'' +\n                '}';\n    }\n}\n```\n\n```xml\n<!--    注入普通数据类型-->\n    <bean id=\"user\" class=\"com.aaa.domain.User\">\n        <property name=\"username\" value=\"fly\"/>\n        <property name=\"age\" value=\"19\"/>\n    </bean>\n```\n\n```java\n\t@Test\n    public void Save(){\n        ApplicationContext classPathXmlApplicationContext = new ClassPathXmlApplicationContext(\"applicationContext.xml\");\n        User user = classPathXmlApplicationContext.getBean(\"user\", User.class);\n        System.out.println(user);\n    }\n```\n\n**注入集合数据类型**\n\nList集合注入\n\n```java\npublic class UserDaoImpl{\n    private List<Object> list;\n    public void setList(List<Object> list) {\n        this.list=list;\n    }\n    public void save1(){\n        System.out.println(list);\n    }\n}\n```\n\n```xml\n<!--    注入普通数据类型-->\n    <bean id=\"user\" class=\"com.aaa.domain.User\">\n        <property name=\"username\" value=\"fly\"/>\n        <property name=\"age\" value=\"19\"/>\n    </bean>\n<!--    List集合注入-->\n    <bean id=\"userList\" class=\"com.aaa.dao.impl.UserDaoImpl\">\n        <property name=\"list\">\n            <list>\n                <value>fly</value>\n                <!--调用 bean id=\"user\" 数据 -->\n                <ref bean=\"user\"></ref>\n            </list>\n        </property>\n    </bean>\n```\n\n```java\n\t@Test\n    public void Save1(){\n        ApplicationContext classPathXmlApplicationContext = new ClassPathXmlApplicationContext(\"applicationContext.xml\");\n        UserDaoImpl user = classPathXmlApplicationContext.getBean(\"userList\", UserDaoImpl.class);\n        user.save1();\n    }\n```\n\nSet集合注入\n\n```java\npublic class UserDaoImpl{\n\tprivate Set<Object> set;\n    public void setSet(Set<Object> set) {\n        this.set = set;\n    }\n    public void save2() {\n        System.out.println(set);\n        System.out.println(\"保存成功了...\");\n    }\n}\n```\n\n```xml\n\t<bean id=\"userSet\" class=\"com.aaa.dao.impl.UserDaoImpl\">\n        <property name=\"set\">\n            <set>\n                <value>bbb</value>\n            </set>\n        </property>\n    </bean>\n```\n\n```java\n@Test\n    public void Save2(){\n        ApplicationContext classPathXmlApplicationContext = new ClassPathXmlApplicationContext(\"applicationContext.xml\");\n        UserDaoImpl user = classPathXmlApplicationContext.getBean(\"userSet\", UserDaoImpl.class);\n        user.save2();\n    }\n```\n\nArray数组注入\n\n```java\npublic class UserDaoImpl{\n\tprivate Object[] array;\n    public void setArray(Object[] array) {\n        this.array = array;\n    }\n    public void save() {\n        System.out.println(Arrays.toString(array));\n        System.out.println(\"保存成功了...\");\n    }\n}\n```\n\n```xml\n<bean id=\"userArray\" class=\"com.aaa.dao.impl.UserDaoImpl\">\n        <property name=\"array\">\n            <array>\n                <value>ccc</value>\n            </array>\n        </property>\n    </bean>\n```\n\nMap集合注入\n\n```java\npublic class UserDaoImpl{\n\tprivate Map<String, Object> map;\n    public void setMap(Map<String, Object> map) {\n        this.map = map;\n    }\n    public void save() {\n        System.out.println(map);\n        System.out.println(\"保存成功了...\");\n    }\n}\n```\n\n```xml\n\t<bean id=\"userMap\" class=\"com.aaa.dao.impl.UserDaoImpl\">\n        <property name=\"map\">\n            <map>\n                <entry key=\"k1\" value=\"ddd\"/>\n                <entry key=\"k2\" value-ref=\"user\"></entry>\n            </map>\n        </property>\n    </bean>\n```\n\nProperties配置注入\n\n```java\npublic class UserDaoImpl{\n\tprivate Properties properties;\n        public void setProperties(Properties properties) {\n            this.properties = properties;\n        }\n        public void save() {\n            System.out.println(properties);\n            System.out.println(\"保存成功了...\");\n        }\n}\n```\n\n```xml\n\t<bean id=\"userProperties\" class=\"com.aaa.dao.impl.UserDaoImpl\">\n        <property name=\"properties\">\n            <props>\n                <prop key=\"k1\">v1</prop>\n                <prop key=\"k2\">v2</prop>\n                <prop key=\"k3\">v3</prop>\n            </props>\n        </property>\n    </bean>\n```\n\n### 配置文件模块化\n\n实际开发中，Spring的配置内容非常多，这就导致Spring配置很繁杂且体积很大，所以，可以将部分 配置拆解到其他配置文件中，也就是所谓的配置文件模块化。\n\n主从配置文件\n\n```xml\n\t<!-- import 标签导入 applicationContext-into.xml 配置文件-->\n    <import resource=\"applicationContext-into.xml\"/>\n```\n\napplicationContext.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n    http://www.springframework.org/schema/beans/spring-beans.xsd\">\n    <bean id=\"userDao\" class=\"com.aaa.dao.impl.UserImpl\"/>\n\n    <bean id=\"userDaos\" class=\"com.aaa.dao.impl.UserImpl\" init-method=\"init\" destroy-method=\"destroy\" />\n\t<!-- 导入 applicationContext-into.xml 配置文件-->\n    <import resource=\"applicationContext-into.xml\"/>\n</beans>\n```\n\napplicationContext-into.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n    http://www.springframework.org/schema/beans/spring-beans.xsd\">\n    <!--    注入普通数据类型-->\n    <bean id=\"user\" class=\"com.aaa.domain.User\">\n        <property name=\"username\" value=\"fly\"/>\n        <property name=\"age\" value=\"19\"/>\n    </bean>\n    <!--    List集合注入-->\n    <bean id=\"userList\" class=\"com.aaa.dao.impl.UserDaoImpl\">\n        <property name=\"list\">\n            <list>\n                <value>fly</value>\n            </list>\n        </property>\n    </bean>\n</beans>\n```\n\n并列的多个配置文件\n\n```java\nApplicationContext act = new ClassPathXmlApplicationContext(\"beans1.xml\",\"beans2.xml\",\"...\");\n```\n\n```java\nApplicationContext classPathXmlApplicationContext = new ClassPathXmlApplicationContext(\"applicationContext.xml\",\"applicationContext-into.xml\");\n```\n\n> 注意： 同一个xml中不能出现相同名称的bean,如果出现会报错 多个xml如果出现相同名称的bean，不会报错，但是后加载的会覆盖前加载的bean\n\n## IOC实战案例\n\n**DbUtils**\n\nDbUtils是Apache的一款用于简化Dao代码的工具类，它底层封装了JDBC技术。\n\n核心对象\n\n```java\nQueryRunner queryRunner = new QueryRunner(DataSource dataSource)\n```\n\n查询数据库所有账户信息到Account实体中\n\n```java\npublic class DbUtilsTest {\n        @Test\n        public void findAllTest() throws Exception {\n            /* 创建DBUtils工具类，传入连接池 */\n            QueryRunner queryRunner = new QueryRunner(JdbcUtils.getDataSource());\n            /* 编写sql */\n            String sql = \"select * from account\";\n            /* 执行sql */\n            List<Account> list = queryRunner.query(sql,\n                    new BeanListHandler<Account>(Account.class));\n            /* 打印结果 */\n            for (Account account : list) {\n                System.out.println(account);\n            }\n        }\n}\n```\n\n**Spring的DbUtils**\n\n基于Spring的xml配置实现账户的CRUD案例 \n\n步骤分析：\n\n1. 准备数据库环境 \n\n2. 创建java项目，导入坐标 \n\n3. 编写Account实体类 \n\n4. 编写AccountDao接口和实现类 \n\n5. 编写AccountService接口和实现类 \n\n6. 编写spring核心配置文件 \n\n7. 编写测试代码\n\n**准备数据库环境**\n\n```sql\nCREATE DATABASE `spring_db`;\nUSE `spring_db`;\nCREATE TABLE `account` (\n                           `id` int(11) NOT NULL AUTO_INCREMENT,\n                           `name` varchar(32) DEFAULT NULL,\n                           `money` double DEFAULT NULL,\n                           PRIMARY KEY (`id`)\n) ;\ninsert into `account`(`id`,`name`,`money`)\nvalues (1,'tom',1000),\n        (2,'jerry',1000);\n```\n\n**创建java项目，导入坐标**\n\n```xml\n<dependencies>\n\t\t<dependency>\n            <groupId>junit</groupId>\n            <artifactId>junit</artifactId>\n            <version>4.12</version>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-context</artifactId>\n            <version>5.1.5.RELEASE</version>\n        </dependency>\n\n\n        <dependency>\n            <groupId>mysql</groupId>\n            <artifactId>mysql-connector-java</artifactId>\n            <version>5.1.38</version>\n            <scope>runtime</scope>\n        </dependency>\n        <dependency>\n            <groupId>com.alibaba</groupId>\n            <artifactId>druid</artifactId>\n            <version>1.2.8</version>\n        </dependency>\n        <dependency>\n            <groupId>commons-dbutils</groupId>\n            <artifactId>commons-dbutils</artifactId>\n            <version>1.6</version>\n        </dependency>\n</dependencies>\n```\n\n**编写Account实体类**\n\n```java\npublic class Account {\n    private Integer id;\n    private String name;\n    private Double money;\n\n    public Integer getId() {\n        return id;\n    }\n\n    public void setId(Integer id) {\n        this.id = id;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public Double getMoney() {\n        return money;\n    }\n\n    public void setMoney(Double money) {\n        this.money = money;\n    }\n\n    @Override\n    public String toString() {\n        return \"Account{\" +\n                \"id=\" + id +\n                \", name='\" + name + '\\'' +\n                \", money=\" + money +\n                '}';\n    }\n}\n\n```\n\n**编写AccountDao接口和实现类**\n\n```java\npublic interface AccountDao {\n    public List<Account> findAll();\n    public Account findById(Integer id);\n    public void save(Account account);\n    public void update(Account account);\n    public void delete(Integer id);\n}\n```\n\n```java\npublic class AccountDaoImpl implements AccountDao {\n    private QueryRunner queryRunner;\n    public void setQueryRunner(QueryRunner queryRunner) {\n        this.queryRunner = queryRunner;\n    }\n    @Override\n    public List<Account> findAll() {\n        List<Account> list = null;\n        /* 编写sql */\n        String sql = \"select * from account\";\n        try {\n            /* 执行sql */\n            list = queryRunner.query(sql,\n                    new BeanListHandler<Account>(Account.class));\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n        return list;\n    }\n\n    @Override\n    public Account findById(Integer id) {\n        Account account = null;\n        /* 编写sql */\n        String sql = \"select * from account where id = ?\";\n        try {\n            /* 执行sql */\n            account = queryRunner.query(sql,\n                    new BeanHandler<Account>(Account.class), id);\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n        return account;\n    }\n    @Override\n    public void save(Account account) {\n        /* 编写sql */\n        String sql = \"insert into account values(null,?,?)\";\n        /* 执行sql */\n        try {\n            queryRunner.update(sql, account.getName(), account.getMoney());\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n    }\n    @Override\n    public void update(Account account) {\n        /* 编写sql */\n        String sql = \"update account set name = ?,money = ? where id = ?\";\n        /* 执行sql */\n        try {\n            queryRunner.update(sql, account.getName(),\n                    account.getMoney(),account.getId());\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n    }\n    @Override\n    public void delete(Integer id) {\n        /* 编写sql */\n        String sql = \"delete from account where id = ?\";\n        /* 执行sql */\n        try {\n            queryRunner.update(sql, id);\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n**编写AccountService接口和实现类**\n\n```java\npublic interface AccountService {\n    public List<Account> findAll();\n    public Account findById(Integer id);\n    public void save(Account account);\n    public void update(Account account);\n    public void delete(Integer id);\n}\n```\n\n```java\npublic class AccountServiceImpl implements AccountService {\n\n    private AccountDao accountDao;\n    public void setAccountDao(AccountDao accountDao) {\n        this.accountDao = accountDao;\n    }\n    @Override\n    public List<Account> findAll() {\n        return accountDao.findAll();\n    }\n    @Override\n    public Account findById(Integer id) {\n        return accountDao.findById(id);\n    }\n    @Override\n    public void save(Account account) {\n        accountDao.save(account);\n    }\n    @Override\n    public void update(Account account) {\n        accountDao.update(account);\n    }\n    @Override\n    public void delete(Integer id) {\n        accountDao.delete(id);\n    }\n}\n```\n\n**编写spring核心配置文件 applicationContext-db.xml**\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"\nhttp://www.springframework.org/schema/beans\nhttp://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    <!--把数据库连接池交给IOC容器-->\n    <bean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\">\n        <property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\" />\n        <property name=\"url\" value=\"jdbc:mysql://localhost:3306/spring_db?useSSL=false&amp;useServerPrepStmts=true&amp;characterEncoding=utf-8&amp;serverTimezone=Asia/Shanghai\" />\n        <property name=\"username\" value=\"root\" />\n        <property name=\"password\" value=\"123456\" />\n    </bean>\n    <!--把QueryRunner交给IOC容器-->\n    <bean id=\"queryRunner\" class=\"org.apache.commons.dbutils.QueryRunner\">\n        <constructor-arg name=\"ds\" ref=\"dataSource\"></constructor-arg>\n    </bean>\n    <!--把AccountDao交给IOC容器-->\n    <bean id=\"accountDao\" class=\"com.aaa.dao.impl.AccountDaoImpl\">\n        <property name=\"queryRunner\" ref=\"queryRunner\"></property>\n    </bean>\n    <!--把AccountService交给IOC容器-->\n    <bean id=\"accountService\" class=\"com.aaa.service.impl.AccountServiceImpl\">\n        <property name=\"accountDao\" ref=\"accountDao\"></property>\n    </bean>\n</beans>\n```\n\n**编写测试代码**\n\n```java\npublic class AccountTest {\n    ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"applicationContext-db.xml\");\n    AccountService accountService = applicationContext.getBean(AccountService.class);\n    /* 测试保存 */\n    @Test\n    public void testSave() {\n        Account account = new Account();\n        account.setName(\"lucy\");\n        account.setMoney(100d);\n        accountService.save(account);\n    }\n    /* 测试查询 */\n    @Test\n    public void testFindById() {\n        Account account = accountService.findById(3);\n        System.out.println(account);\n    }\n    /* 测试查询所有 */\n    @Test\n    public void testFindAll() {\n        List<Account> accountList = accountService.findAll();\n        for (Account account : accountList) {\n            System.out.println(account);\n        }\n    }\n    /* 测试修改 */\n    @Test\n    public void testUpdate() {\n        Account account = new Account();\n        account.setId(3);\n        account.setName(\"jack\");\n        account.setMoney(2000d);\n        accountService.update(account);\n    }\n    /* 测试删除 */\n    @Test\n    public void testDelete() {\n        accountService.delete(3);\n    }\n}\n```\n\n**抽取jdbc配置文件**\n\napplicationContext.xml加载jdbc.properties配置文件获得连接信息。 首先，需要引入context命名空间和约束路径\n\n```\n\t* 命名空间：\n    xmlns:context=\"http://www.springframework.org/schema/context\"\n    * 约束路径：\n    http://www.springframework.org/schema/context\n    http://www.springframework.org/schema/context/spring-context.xsd\n```\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\nhttp://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\">\n    <context:property-placeholder location=\"classpath:jdbc.properties\"/>\n    <!--把数据库连接池交给IOC容器-->\n    <bean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\">\n        <property name=\"driverClassName\" value=\"${jdbc.driver}\" />\n        <property name=\"url\" value=\"${jdbc.url}\" />\n        <property name=\"username\" value=\"${jdbc.username}\" />\n        <property name=\"password\" value=\"${jdbc.password}\" />\n    </bean>\n```\n\njdbc.properties配置文件\n\n```properties\njdbc.driver=com.mysql.jdbc.Driver\njdbc.url=jdbc:mysql:///spring_db?useSSL=false&useServerPrepStmts=true&characterEncoding=utf-8&serverTimezone=Asia/Shanghai\njdbc.username=root\njdbc.password=123456\n```\n\n## Spring注解开发\n\nSpring是轻代码而重配置的框架，配置比较繁重，影响开发效率，所以注解开发是一种趋势，注解代 替xml配置文件可以简化配置，提高开发效率。 \n\n### Spring常用注解\n\n| 注解            | 说明                                                         |\n| --------------- | ------------------------------------------------------------ |\n| @component      | 使用在类上用于实例化Bean                                     |\n| @Controller     | 使用在web层类上用于实例化Bean                                |\n| @Service        | 使用在service层类上用于实例化Bean                            |\n| @Repository     | 使用在dao层类上用于实例化Bean                                |\n| @Autowired      | 使用在字段上用于根据类型依赖注入                             |\n| @Qualifier      | 结合@Autowired一起使用,根据名称进行依赖注入                  |\n| @Resource       | 相当于@Autowired+@Qualifier，按照名称进行注入                |\n| @value          | 注入普通属性                                                 |\n| @scope          | 标注Bean的作用范围                                           |\n| @PostConstruct  | 使用在方法上标注该方法是Bean的初始化方法                     |\n| @PreDestroy     | 使用在方法上标注该方法是Bean的销毁方法                       |\n| @Configuration  | 用于指定当前类是一个Spring配置类，当创建容器时会从该类上加载注解 |\n| @Bean           | 使用在方法上，标注将该方法的返回值存储到Spring容器中         |\n| @PropertySource | 用于加载properties文件中的配置                               |\n| @ComponentScan  | 用于指定Spring在初始化容器时要扫描的包                       |\n| @lmport         | 用于导入其他配置类                                           |\n\n说明：JDK11以后完全移除了javax扩展导致不能使用@resource注解\n\n**maven引入依赖**\n\n```xml\n\t\t<!--  引入注解依赖-->\n        <dependency>\n            <groupId>javax.annotation</groupId>\n            <artifactId>javax.annotation-api</artifactId>\n            <version>1.3.2</version>\n        </dependency>\n```\n\n使用注解进行开发时，需要在applicationContext.xml中配置组件扫描，作用是指定哪个包及其子包 下的Bean需要进行扫描以便识别使用注解配置的类、字段和方法。\n\n```xml\n<!--注解的组件扫描-->\n<context:component-scan base-package=\"com.aaa\" />\n```\n\n**Bean实例化（IOC）**\n\n使用@Compont或@Repository标识UserDaoImpl需要Spring进行实例化 AccountDaoImpl\n\n```xml\n<bean id=\"userDao\" class=\"com.aaa.dao.impl.AccountDaoImpl\"></bean>\n```\n\n```java\n//@Component(value = \"userDao\")   如果没有写value属性值，Bean的id为：类名首字母小\n@Repository\npublic class AccountDaoImpl implements AccountDao {}\n```\n\n**属性依赖注入（DI）**\n\n使用@Autowired或者@Autowired+@Qulifier或者@Resource进行AccountDaoImpl的注入 不在使用Set方法\n\n```xml\n<bean id=\"userService\" class=\"com.aaa.service.impl.AccountDaoImpl\">\n    <property name=\"queryRunner\" ref=\"queryRunner\"/>\n</bean>\n```\n\n```java\n@Repository\npublic class AccountDaoImpl implements AccountDao {\n    /* <property name=\"userDao\" ref=\"userDaoImpl\"/>\n    \t@Autowired\n    \t@Qualifier(\"userDaoImpl\")\n    \t@Resource(name = \"userDaoImpl\") */\n       \t@Autowired\n    \tprivate QueryRunner queryRunner;\n}\n```\n\n**@Value**\n\n使用@Value进行字符串的注入，结合SPEL表达式获得配置参数\n\n```java\n@Service\npublic class jdbcServiceTest implements Service {\n    @Value(\"注入普通数据\")\n    private String str;\n    @Value(\"${jdbc.driver}\")\n    private String driver;\n}\n```\n\n@Scope\n\n使用@Scope标注Bean的范围\n\n```JAVA\n@Service\n@Scope(\"singleton\")\npublic class ServiceImpl implements Service {}\n```\n\n**Bean生命周期**\n\n使用@PostConstruct标注初始化方法，使用@PreDestroy标注销毁方法\n\n```java\n@PostConstruct\npublic void init(){System.out.println(\"初始化方法....\");}\n@PreDestroy\npublic void destroy(){System.out.println(\"销毁方法.....\");}\n```\n\n### Spring注解整合DbUtils\n\n修改AccountDaoImpl实现类\n\n```java\n//bean实例化\n@Repository\npublic class AccountDaoImpl implements AccountDao {\n    //注入\n    @Autowired\n    private QueryRunner queryRunner;\n    \n    @Override\n    public List<Account> findAll() {\n        List<Account> list = null;\n        /* 编写sql */\n        String sql = \"select * from account\";\n        try {\n            /* 执行sql */\n            list = queryRunner.query(sql,\n                    new BeanListHandler<Account>(Account.class));\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n        return list;\n    }\n\n    @Override\n    public Account findById(Integer id) {\n        Account account = null;\n        /* 编写sql */\n        String sql = \"select * from account where id = ?\";\n        try {\n            /* 执行sql */\n            account = queryRunner.query(sql,\n                    new BeanHandler<Account>(Account.class), id);\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n        return account;\n    }\n    @Override\n    public void save(Account account) {\n        /* 编写sql */\n        String sql = \"insert into account values(null,?,?)\";\n        /* 执行sql */\n        try {\n            queryRunner.update(sql, account.getName(), account.getMoney());\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n    }\n    @Override\n    public void update(Account account) {\n        /* 编写sql */\n        String sql = \"update account set name = ?,money = ? where id = ?\";\n        /* 执行sql */\n        try {\n            queryRunner.update(sql, account.getName(),\n                    account.getMoney(),account.getId());\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n    }\n    @Override\n    public void delete(Integer id) {\n        /* 编写sql */\n        String sql = \"delete from account where id = ?\";\n        /* 执行sql */\n        try {\n            queryRunner.update(sql, id);\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n修改AccountServiceImpl实现类\n\n```java\n//bean实例化\n@Service\npublic class AccountServiceImpl implements AccountService {\n    //注入\n    @Autowired\n    private AccountDao accountDao;\n    \n    @Override\n    public List<Account> findAll() {\n        return accountDao.findAll();\n    }\n    @Override\n    public Account findById(Integer id) {\n        return accountDao.findById(id);\n    }\n    @Override\n    public void save(Account account) {\n        accountDao.save(account);\n    }\n    @Override\n    public void update(Account account) {\n        accountDao.update(account);\n    }\n    @Override\n    public void delete(Integer id) {\n        accountDao.delete(id);\n    }\n}\n```\n\n编写Spring核心配置类 com.aaa.springdao.SpringConfig\n\n```java\n@Configuration\n@ComponentScan(\"com.aaa\")\n@Import(DataSourceConfig.class)\npublic class SpringConfig {\n    @Autowired\n    DataSource dataSource;\n    @Bean(\"queryRunner\")\n    public QueryRunner getQueryRunner() {\n        return new QueryRunner(dataSource);\n    }\n}\n```\n\n编写数据库配置信息类\n\n```java\n@PropertySource(\"classpath:jdbc.properties\")\npublic class DataSourceConfig {\n    @Value(\"${jdbc.driver}\")\n    private String driver;\n    @Value(\"${jdbc.url}\")\n    private String url;\n    @Value(\"${jdbc.username}\")\n    private String username;\n    @Value(\"${jdbc.password}\")\n    private String password;\n\n    @Bean(\"dataSource\")\n    public DataSource getDataSource() {\n        DruidDataSource dataSource = new DruidDataSource();\n        dataSource.setDriverClassName(driver);\n        dataSource.setUrl(url);\n        dataSource.setUsername(username);\n        dataSource.setPassword(password);\n        return dataSource;\n    }\n}\n```\n\n编写测试代码\n\n```java\npublic class TestConfig {\n    ApplicationContext applicationContext =\n            new AnnotationConfigApplicationContext(SpringConfig.class);\n    AccountService accountService =\n            applicationContext.getBean(AccountService.class);\n    /* 测试查询所有 */\n    @Test\n    public void testFindAll1() {\n        List<Account> all = accountService.findAll();\n        System.out.println(all);\n    }\n}\n```\n\n### Spring整合Junit\n\n**普通Junit测试问题**\n\n在普通的测试类中，需要开发者手动加载配置文件并创建Spring容器，然后通过Spring相关API获得 Bean实例；如果不这么做，那么无法从容器中获得对象。 \n\n```java\nApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); \nAccountService accountService = applicationContext.getBean(AccountService.class)\n```\n\n我们可以让SpringJunit负责创建Spring容器来简化这个操作，开发者可以直接在测试类注入Bean实 例；但是需要将配置文件的名称告诉它。\n\n步骤分析：\n\n1. 导入spring集成Junit的坐标\n\n2. 使用@Runwith注解替换原来的运行器\n\n3. 使用@ContextConfiguration指定配置文件或配置类\n\n4. 使用@Autowired注入需要测试的对象\n\n5. 创建测试方法进行测试 \n\n导入spring集成Junit的坐标\n\n```xml\n<!--此处需要注意的是，spring5 及以上版本要求 junit 的版本必须是 4.12 及以上-->\t\n\t\t<dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-test</artifactId>\n            <version>5.1.5.RELEASE</version>\n        </dependency>\n        <dependency>\n            <groupId>junit</groupId>\n            <artifactId>junit</artifactId>\n            <version>4.12</version>\n            <scope>test</scope>\n        </dependency>\n```\n\n使用@Runwith注解替换原来的运行器\n\n```java\n@RunWith(SpringJUnit4ClassRunner.class)\npublic class JnitTest {}\n```\n\n使用@ContextConfiguration指定配置文件或配置类\n\n```java\n@RunWith(SpringJUnit4ClassRunner.class)\n/* 加载spring核心配置类 */\n@ContextConfiguration(classes = {SpringConfig.class})\npublic class JnitTest {}\n```\n\n使用@Autowired注入需要测试的对象\n\n```java\n@RunWith(SpringJUnit4ClassRunner.class)\n/* 加载spring核心配置类 */\n@ContextConfiguration(classes = {SpringConfig.class})\npublic class JnitTest {\n    @Autowired\n    private AccountService accountService;\n}\n```\n\n创建测试方法进行测试\n\n```java\n@RunWith(SpringJUnit4ClassRunner.class)\n/* 加载spring核心配置类 */\n@ContextConfiguration(classes = {SpringConfig.class})\npublic class JnitTest {\n    @Autowired\n    private AccountService accountService;\n    /* 测试查询所有 */\n    @Test\n    public void testFindAll1() {\n        List<Account> all = accountService.findAll();\n        System.out.println(all);\n    }\n}\n```\n\n## Spring转账案例\n\n### 转账案例\n\n需求 使用spring框架整合DBUtils技术，实现用户转账功能 \n\n步骤分析：\n\n1. 创建java项目，导入坐标\n\n2. 编写Account实体类\n\n3. 编写AccountDao接口和实现类\n\n4. 编写AccountService接口和实现类\n\n5. 编写spring核心配置文件\n\n6. 编写测试代码\n\n创建java项目，导入坐标 \n\n```xml\n<dependencies>\n        <dependency>\n            <groupId>junit</groupId>\n            <artifactId>junit</artifactId>\n            <version>4.12</version>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-context</artifactId>\n            <version>5.1.5.RELEASE</version>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-test</artifactId>\n            <version>5.1.5.RELEASE</version>\n        </dependency>\n        <dependency>\n            <groupId>mysql</groupId>\n            <artifactId>mysql-connector-java</artifactId>\n            <version>5.1.38</version>\n            <scope>runtime</scope>\n        </dependency>\n        <dependency>\n            <groupId>com.alibaba</groupId>\n            <artifactId>druid</artifactId>\n            <version>1.2.8</version>\n        </dependency>\n        <dependency>\n            <groupId>commons-dbutils</groupId>\n            <artifactId>commons-dbutils</artifactId>\n            <version>1.6</version>\n        </dependency>\n</dependencies>\n```\n\n编写Account实体类 com.aaa.domain.\n\n```java\npublic class Account {\n    private Integer id;\n    private String name;\n    private Double money;\n\n    public Integer getId() {\n        return id;\n    }\n\n    public void setId(Integer id) {\n        this.id = id;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public Double getMoney() {\n        return money;\n    }\n\n    public void setMoney(Double money) {\n        this.money = money;\n    }\n\n    @Override\n    public String toString() {\n        return \"Account{\" +\n                \"id=\" + id +\n                \", name='\" + name + '\\'' +\n                \", money=\" + money +\n                '}';\n    }\n}\n```\n\n编写AccountDao接口和实现类 com.aaa.dao.\n\n```java\npublic interface AccountDao {\n    /* 转出操作 */\n    public void out(String outUser, Double money);\n    /* 转入操作 */\n    public void in(String inUser, Double money);\n}\n```\n\n```java\n@Repository\npublic class AccountDaoImpl implements AccountDao {\n\n    @Autowired\n    private QueryRunner queryRunner;\n    @Override\n    public void out(String outUser, Double money) {\n        try {\n            queryRunner.update(\"update account set money=money-? where name=?\", money, outUser);\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n    }\n    @Override\n    public void in(String inUser, Double money) {\n        try {\n            queryRunner.update(\"update account set money=money+? where name=?\",money, inUser);\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n    }\n\n}\n```\n\n编写AccountService接口和实现类\n\n```java\npublic interface AccountService {\n    public void transfer(String outUser, String inUser, Double money);\n}\n```\n\n```java\n@Service\npublic class AccountServiceImpl implements AccountService {\n    @Autowired\n    private AccountDao accountDao;\n    @Override\n    public void transfer(String outUser, String inUser, Double money) {\n        accountDao.out(outUser, money);\n        accountDao.in(inUser, money);\n    }\n}\n```\n\n编写spring核心配置文件\n\njdbc.properties\n\n```properties\njdbc.driver=com.mysql.jdbc.Driver\njdbc.url=jdbc:mysql:///spring_db?useSSL=false&useServerPrepStmts=true&characterEncoding=utf-8&serverTimezone=Asia/Shanghai\njdbc.username=root\njdbc.password=123456\n```\n\napplicationContext.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\nhttp://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\">\n    <!--开启组件扫描-->\n    <context:component-scan base-package=\"com.aaa\"/>\n    <!--加载jdbc配置文件-->\n    <context:property-placeholder location=\"classpath:jdbc.properties\"/>\n    <!--把数据库连接池交给IOC容器-->\n    <bean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\">\n        <property name=\"driverClassName\" value=\"${jdbc.driver}\"></property>\n        <property name=\"url\" value=\"${jdbc.url}\"></property>\n        <property name=\"username\" value=\"${jdbc.username}\"></property>\n        <property name=\"password\" value=\"${jdbc.password}\"></property>\n    </bean>\n    <!--把QueryRunner交给IOC容器-->\n    <bean id=\"queryRunner\" class=\"org.apache.commons.dbutils.QueryRunner\">\n        <constructor-arg name=\"ds\" ref=\"dataSource\"></constructor-arg>\n    </bean>\n</beans>\n```\n\n编写测试代码\n\n```java\n@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration(\"classpath:applicationContext.xml\")\npublic class AccountTest {\n    @Autowired\n    private AccountService accountService;\n    @Test\n    public void testTransfer() throws Exception {\n        accountService.transfer(\"tom\", \"jerry\", 100d);\n    }\n}\n```\n\n问题分析：\n\n上面的代码事务在dao层，转出转入操作都是一个独立的事务，但实际开发，应该把业务逻辑控制在 一个事务中，所以应该将事务挪到service层。\n\n### 传统事务\n\n编写线程绑定工具类\n\n```java\n/* 接工具类，从数据源中获取一个连接，并将实现和线程的绑定 */\n@Component\npublic class ConnectionUtils {\n    private ThreadLocal threadLocal = new ThreadLocal<>();\n    @Autowired\n    private DataSource dataSource;\n\n    /*获取当前线程上的连接 return Connection*/\n    public Connection getThreadConnection() {\n        // 1.先从ThreadLocal上获取\n        Connection connection = (Connection) threadLocal.get();\n        // 2.判断当前线程是否有连接\n        if (connection == null) {\n            try {\n                // 3.从数据源中获取一个连接，并存入到ThreadLocal中\n                connection = dataSource.getConnection();\n                threadLocal.set(connection);\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n        }\n        return connection;\n    }\n    /*解除当前线程的连接绑定*/\n    public void removeThreadConnection() {\n        threadLocal.remove();\n    }\n}\n```\n\n编写事务管理器\n\n```java\n/* 事务管理器工具类，包含：开启事务、提交事务、回滚事务、释放资源*/\n@Component\npublic class TransactionManager {\n    @Autowired\n    private ConnectionUtils connectionUtils;\n    public void beginTransaction() {\n        try {\n            connectionUtils.getThreadConnection().setAutoCommit(false);\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n    }\n    public void commit() {\n        try {\n            connectionUtils.getThreadConnection().commit();\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n    }\n    public void rollback() {\n        try {\n            connectionUtils.getThreadConnection().rollback();\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n    }\n    public void release() {\n        try {\n            /* 改回自动提交事务 */\n            connectionUtils.getThreadConnection().setAutoCommit(true);\n            /* 归还到连接池 */\n            connectionUtils.getThreadConnection().close();\n            /* 解除线程绑定 */\n            connectionUtils.removeThreadConnection();\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n修改service层代码\n\n```java\n@Service\npublic class AccountServiceImpl implements AccountService {\n    @Autowired\n    private AccountDao accountDao;\n    @Autowired\n    private TransactionManager transactionManager;\n    @Override\n    public void transfer(String outUser, String inUser, Double money) {\n        try {\n            /* 1.开启事务 */\n            transactionManager.beginTransaction();\n            /* 2.业务操作 */\n            accountDao.out(outUser, money);\n            //int i = 1 / 0;\n            accountDao.in(inUser, money);\n            /* 3.提交事务 */\n            transactionManager.commit();\n        } catch (Exception e) {\n            e.printStackTrace();\n            /* 4.回滚事务 */\n            transactionManager.rollback();\n        } finally {\n            /* 5.释放资源 */\n            transactionManager.release();\n        }\n    }\n}\n```\n\n修改dao层代码\n\n```java\n@Repository\npublic class AccountDaoImpl implements AccountDao {\n\n    @Autowired\n    private QueryRunner queryRunner;\n    @Autowired\n    private ConnectionUtils connectionUtils;\n    @Override\n    public void out(String outUser, Double money) {\n        try {\n            queryRunner.update(connectionUtils.getThreadConnection(),\"update account set money=money-? where name=?\", money, outUser);\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n    }\n    @Override\n    public void in(String inUser, Double money) {\n        try {\n            queryRunner.update(connectionUtils.getThreadConnection(),\"update account set money=money+? where name=?\",money, inUser);\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n问题分析：\n\n上面代码，通过对业务层改造，已经可以实现事务控制了，但是由于我们添加了事务控制，也产生了 一个新的问题： 业务层方法变得臃肿了，里面充斥着很多重复代码。并且业务层方法和事务控制方法耦 合了，违背了面向对象的开发思想。\n\n## Proxy优化转账案例\n\n我们可以将业务代码和事务代码进行拆分，通过动态代理的方式，对业务方法进行事务的增强。这样 就不会对业务层产生影响，解决了耦合性的问题啦！\n\n常用的动态代理技术 \n\n- JDK 代理：基于接口的动态代理技术·：利用拦截器（必须实现invocationHandler）加上反射机制生成 一个代理接口的匿名类，在调用具体方法前调用InvokeHandler来处理，从而实现方法增强\n\n- CGLIB代理：基于父类的动态代理技术：动态生成一个要代理的子类，子类重写要代理的类的所有不是 final的方法。在子类中采用方法拦截技术拦截所有的父类方法的调用，顺势织入横切逻辑，对方法进行增强 ASM \n\n### JDK动态代理方式\n\nJdk工厂类\n\n```java\n@Component\npublic class JdkProxyFactory {\n    @Autowired\n    private AccountService accountService;\n    @Autowired\n    private TransactionManager transactionManager;\n    public AccountService createAccountServiceJdkProxy() {\n        AccountService accountServiceProxy = null;\n\n        accountServiceProxy = (AccountService)\n                Proxy.newProxyInstance(accountService.getClass().getClassLoader(),\n                        accountService.getClass().getInterfaces(), new InvocationHandler(){\n                                    @Override\n                                    public Object invoke(Object proxy, Method method, Object[] args)throws Throwable {\n                                        Object result = null;\n                                        try {\n                                            /* 1.开启事务 */\n                                            transactionManager.beginTransaction();\n                                            /* 2.业务操作 */\n                                            result = method.invoke(accountService, args);\n                                            // 3.提交事务\n                                            transactionManager.commit();\n                                        } catch (Exception e) {\n                                            e.printStackTrace();\n                                            // 4.回滚事务\n                                            transactionManager.rollback();\n                                        } finally {\n                                            // 5.释放资源\n                                            transactionManager.release();\n                                        }\n                                        return result;\n                                    }\n                                });\n        return accountServiceProxy;\n    }\n}\n```\n\n修改service层代码\n\n```java\n@Service\npublic class AccountServiceImpl implements AccountService {\n    @Autowired\n    private AccountDao accountDao;\n    @Override\n    public void transfer(String outUser, String inUser, Double money) {\n        accountDao.out(outUser, money);\n        accountDao.in(inUser, money);\n    }\n}\n```\n\n编写测试代码\n\n```java\n@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration(\"classpath:applicationContext.xml\")\npublic class AccountTest {\n    @Autowired\n    private JdkProxyFactory jdkProxyFactory;\n    @Test\n    public void testTransfer() throws Exception {\n        AccountService accountService = jdkProxyFactory.createAccountServiceJdkProxy();\n        accountService.transfer(\"tom\", \"jerry\", 100d);\n    }\n}\n```\n\n### CGLIB动态代理方式\n\nCglib工厂类\n\n```java\n@Component\npublic class CglibProxyFactory {\n    @Autowired\n    private AccountService accountService;\n    @Autowired\n    private TransactionManager transactionManager;\n    public AccountService createAccountServiceCglibProxy() {\n        AccountService accountServiceProxy = null;\n        /*\n         * 参数一：目标对象的字节码对象\n         * 参数二：动作类，实现增强功能\n         * */\n        accountServiceProxy = (AccountService)\n                Enhancer.create(accountService.getClass(), new MethodInterceptor() {\n                    @Override\n                    public Object intercept(Object o, Method method, Object[] objects,\n                                            MethodProxy methodProxy) throws Throwable {\n                        Object result = null;\n                        try {\n                            // 1.开启事务\n                            transactionManager.beginTransaction();\n                            // 2.业务操作\n                            result = method.invoke(accountService, objects);\n                            // 3.提交事务\n                            transactionManager.commit();\n                        } catch (Exception e) {\n                            e.printStackTrace();\n                            // 4.回滚事务\n                            transactionManager.rollback();\n                        } finally {\n                            // 5.释放资源\n                            transactionManager.release();\n                        }\n                        return result;\n                    }\n                });\n        return accountServiceProxy;\n    }\n}\n```\n\n编写测试代码\n\n```java\n@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration(\"classpath:applicationContext.xml\")\npublic class AccountTest {\n    @Autowired\n    private CglibProxyFactory cglibProxyFactory;\n    @Test\n    public void testTransfer() throws Exception {\n        AccountService accountService = cglibProxyFactory.createAccountServiceCglibProxy();\n        accountService.transfer(\"tom\", \"jerry\", 100d);\n    }\n}\n```\n\n## 初识AOP\n\n### 什么是AOP\n\nAOP 为 Aspect Oriented Programming 的缩写，意思为面向切面编程\n\nAOP 是 OOP（面向对象编程） 的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。\n\n这样做的好处是：\n\n1. 在程序运行期间，在不修改源码的情况下对方法进行功能增强\n\n2. 逻辑清晰，开发核心业务的时候，不必关注增强业务的代码\n\n3. 减少重复代码，提高开发效率，便于后期维护\n\n**AOP底层实现**\n\n实际上，AOP 的底层是通过 Spring 提供的的动态代理技术实现的。在运行期间，Spring通过动态代理技术动态的生成代理对象，代理对象方法执行时进行增强功能的介入，在去调用目标对象的方法，从而完成功能的增强。\n\n**AOP相关术语**\n\nSpring 的 AOP 实现底层就是对上面的动态代理的代码进行了封装，封装后我们只需要对需要关注的部分进行代码编写，并通过配置的方式完成指定目标的方法增强。\n\n在正式讲解 AOP 的操作之前，我们必须理解 AOP 的相关术语，常用的术语如下：\n\n```\n\\* Target（目标对象）：代理的目标对象 //accountServiceiml\n\\* Proxy （代理）：一个类被 AOP 织入增强后，就产生一个结果代理类 //兄弟类或者子类\n\\* Joinpoint（连接点）：所谓连接点是指那些可以被拦截到的点。在spring中,这些点指的是方法，因为 spring只支持方法类型的连接点 //transfer\n\\* Pointcut（切入点）：所谓切入点是指我们要对哪些 Joinpoint 进行拦截的定义\n\\* Advice（通知/增强）：所谓通知是指拦截到 Joinpoint 之后所要做的事情就是通知 分类：前置通知、后置通知、异常通知、最终通知、环绕通知 // 开启事务 提交事务\n\\* Aspect（切面）：是切入点和通知（引介）的结合\n\\* Weaving（织入）：是指把增强应用到目标对象来创建新的代理对象的过程。spring采用动态代理织入，而AspectJ采用编译期织入和类装载期织入\n```\n\n### AOP开发明确事项\n\n**开发阶段（我们做的）**\n\n1. 编写核心业务代码（目标类的目标方法） 切入点\n\n2. 把公用代码抽取出来，制作成通知（增强功能方法） 通知\n\n3. 在配置文件中，声明切入点与通知间的关系，即切面\n\n**运行阶段（Spring框架完成的）**\n\nSpring 框架监控切入点方法的执行。一旦监控到切入点方法被运行，使用代理机制，动态创建目标对象的代理对象，根据通知类别，在代理对象的对应位置，将通知对应的功能织入，完成完整的代码逻辑运行。\n\n**底层代理实现** \n\n在 Spring 中，框架会根据目标类是否实现了接口来决定采用哪种动态代理的方式。\n\n当bean实现接口时，会用JDK代理模式\n\n当bean没有实现接口，用cglib实现（ 可以强制使用cglib（在spring配置中加入<aop:aspectjautoproxy proxyt-target-class=“true”/>）\n\n**知识小结**\n\naop：面向切面编程 \n\naop底层实现：基于JDK的动态代理 和 基于Cglib的动态代理 \n\naop的重点概念： \n\nPointcut（切入点）：真正被增强的方法 \n\nAdvice（通知/ 增强）：封装增强业务逻辑的方法 \n\nAspect（切面）：切点+通知 \n\nWeaving（织入）：将切点与通知结合，产生代理对象的过程\n\n## 基于XML的AOP开发\n\n### 快速入门\n\n步骤分析：\n\n1. 创建java项目，导入AOP相关坐标 \n\n2. 创建目标接口和目标实现类（定义切入点） \n\n3. 创建通知类及方法（定义通知） \n\n4. 将目标类和通知类对象创建权交给spring \n5. 在核心配置文件中配置织入关系，及切面 \n\n6. 编写测试代码\n\n创建java项目，导入AOP相关坐标\n\n```xml\n<dependencies>\n        <!--导入spring的context坐标，context依赖aop-->\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-context</artifactId>\n            <version>5.1.5.RELEASE</version>\n        </dependency>\n        <!-- aspectj的织入（切点表达式需要用到该jar包） -->\n        <dependency>\n            <groupId>org.aspectj</groupId>\n            <artifactId>aspectjweaver</artifactId>\n            <version>1.8.13</version>\n        </dependency>\n        <!--spring整合junit-->\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-test</artifactId>\n            <version>5.1.5.RELEASE</version>\n        </dependency>\n        <dependency>\n            <groupId>junit</groupId>\n            <artifactId>junit</artifactId>\n            <version>4.12</version>\n        </dependency>\n</dependencies>\n```\n\n创建目标接口和目标实现类\n\n```java\npublic interface AccountService {\n    public void transfer();\n}\n```\n\n```java\npublic class AccountServiceImpl implements AccountService {\n\t@Override\n    public void transfer() {\n        System.out.println(\"转账业务...\");\n    }\n}\n```\n\n创建通知类\n\n```java\npublic class MyAdvice {\n    public void before() {\n        System.out.println(\"前置通知...\");\n    }\n}\n```\n\n将目标类和通知类对象创建权交给spring 创建applicationContext.xml 在核心配置文件中配置织入关系，及切面\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:aop=\"http://www.springframework.org/schema/aop\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans \n\thttp://www.springframework.org/schema/beans/spring-beans.xsd \n\thttp://www.springframework.org/schema/aop \n\thttp://www.springframework.org/schema/aop/spring-aop.xsd\">\n\n    <!--目标类交给IOC容器-->\n    <bean id=\"accountService\" class=\"com.aaa.service.impl.AccountServiceImpl\"> </bean>\n    <!--通知类交给IOC容器-->\n    <bean id=\"myAdvice\" class=\"com.aaa.advice.MyAdvice\"></bean>\n    \n    <aop:config>\n        <!--引入通知类-->\n        <aop:aspect ref=\"myAdvice\">\n            <!--配置目标类的transfer方法执行时，使用通知类的before方法进行前置增强-->\n            <aop:before method=\"before\" pointcut=\"execution(public void com.aaa.service.impl.AccountServiceImpl.transfer())\"></aop:before>\n        </aop:aspect>\n    </aop:config>\n</beans>\n```\n\n编写测试代码\n\n```java\n@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration(\"classpath:applicationContext.xml\")\npublic class AopTest {\n    @Autowired\n    private AccountService accountService;\n\n    @Test\n    public void testTransfer() throws Exception {\n        accountService.transfer();\n    }\n}\n```\n\n### XML配置AOP详解\n\n**切点表达式**\n\n表达式语法：\n\n- execution([修饰符] 返回值类型 包名.类名.方法名(参数))\n- 访问修饰符可以省略\n- 返回值类型、包名、类名、方法名可以使用星号 * 代替，代表任意\n- 包名与类名之间一个点 . 代表当前包下的类，两个点 .. 表示当前包及其子包下的类\n- 参数列表可以使用两个点 .. 表示任意个数，任意类型的参数列表\n\n例如：\n\n```xml\nexecution(public void com.aaa.service.impl.AccountServiceImpl.transfer()) \nexecution(void com.aaa.service.impl.AccountServiceImpl.*(..)) \nexecution(* com.aaa.service.impl.*.*(..)) \nexecution(* com.aaa.service..*.*(..))\n```\n\n**切点表达式抽取**\n\n当多个增强的切点表达式相同时，可以将切点表达式进行抽取，在增强中使用 pointcut-ref 属性代替pointcut 属性来引用抽取后的切点表达式。\n\n```xml\n<aop:config>\n    <!--抽取的切点表达式-->\n    <aop:pointcut id=\"myPointcut\" expression=\"execution(* com.aaa.service..*.*(..))\"> \t\t</aop:pointcut>\n    <aop:aspect ref=\"myAdvice\">\n        <aop:before method=\"before\" pointcut-ref=\"myPointcut\"></aop:before>\n    </aop:aspect>\n</aop:config>\n```\n\n**通知类型**\n\n通知的配置语法：\n\n```\n<aop:通知类型 method=\"通知类中方法名\" pointcut=\"切点表达式\"></aop:通知类型>\n```\n\n| 名称     | 标签                   | 说明                                                       |\n| -------- | ---------------------- | ---------------------------------------------------------- |\n| 前置通知 | <aop:before >          | 用于配置前置通知。指定增强的方法在切入点方法之前执行       |\n| 后置通知 | <aop:after-returning > | 用于配置后置通知。指定增强的方法在切入点方法之后执行       |\n| 异常通知 | <aop:after-throwing >  | 用于配置异常通知。指定增强的方法出现异常后执行             |\n| 最终通知 | <aop:after >           | 用于配置最终通知。无论切入点方法执行时是否有异常，都会执行 |\n| 环绕通知 | <aop:around >          | 用于配置环绕通知。开发者可以手动控制增强代码在什么时候执行 |\n\n注意：通常情况下，环绕通知都是独立使用的\n\n## 基于注解的AOP开发\n\n创建java项目，导入AOP相关坐标\n\n```xml\n<dependencies>\n        <!--导入spring的context坐标，context依赖aop-->\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-context</artifactId>\n            <version>5.1.5.RELEASE</version>\n        </dependency>\n        <!-- aspectj的织入（切点表达式需要用到该jar包） -->\n        <dependency>\n            <groupId>org.aspectj</groupId>\n            <artifactId>aspectjweaver</artifactId>\n            <version>1.8.13</version>\n        </dependency>\n        <!--spring整合junit-->\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-test</artifactId>\n            <version>5.1.5.RELEASE</version>\n        </dependency>\n        <dependency>\n            <groupId>junit</groupId>\n            <artifactId>junit</artifactId>\n            <version>4.12</version>\n        </dependency>\n</dependencies>\n```\n\n创建目标接口和目标实现类\n\n```java\npublic interface AccountService {\n    public void transfer();\n}\n```\n\n```java\n@Service\npublic class AccountServiceImpl implements AccountService {\n    @Override\n    public void transfer() {\n        System.out.println(\"转账业务...\");\n    }\n} \n```\n\n创建通知类\n\n```java\n@Component\n@Aspect\npublic class MyAdvice {\n    @Before(\"execution(* com.aaa.aop.*.*())\")\n    public void before() {\n        System.out.println(\"前置通知...\");\n    }\n}\n```\n\n在配置文件中开启组件扫描和 AOP 的自动代理\n\n```xml\n<!--组件扫描-->\n<context:component-scan base-package=\"com.aaa\"/>\n<!--aop的自动代理-->\n<aop:aspectj-autoproxy></aop:aspectj-autoproxy>\n```\n\n```java\n//纯注解配置\n@Configuration\n@ComponentScan(\"com.aaa.aop\")\n@EnableAspectJAutoProxy//替代<aop:aspectj-autoproxy />\npublic class SpringConfig {}\n```\n\n测试类\n\n```java\n@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration(classes = Spring.class)\npublic class AopTest {\n    @Autowired\n    private AccountService accountService;\n\n    @Test\n    public void testTransfer() throws Exception {\n        accountService.transfer();\n    }\n}\n```\n\n切点表达式抽取\n\n```java\npublic class MyAdvice {\n\n    @Pointcut(\"execution(* com.aaa..*.*(..))\")\n    public void myPoint(){}\n\n    @Before(\"MyAdvice.myPoint()\")\n    public void before() {\n        System.out.println(\"前置通知...\");\n    }\n}\n```\n\n**注意：**当前四个通知组合在一起时，执行顺序如下：\n\n@Before -> @After -> @AfterReturning（如果有异常：@AfterThrowing）\n\n## AOP优化转账案例\n\n依然使用前面的转账案例，将两个代理工厂对象直接删除！改为spring的aop思想来实现\n\n### xml配置实现\n\n配置文件 applicationContext.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:aop=\"http://www.springframework.org/schema/aop\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xsi:schemaLocation=\" http://www.springframework.org/schema/beans\nhttp://www.springframework.org/schema/beans/spring-beans.xsd\nhttp://www.springframework.org/schema/aop\nhttp://www.springframework.org/schema/aop/spring-aop.xsd\nhttp://www.springframework.org/schema/context\nhttp://www.springframework.org/schema/context/spring-context.xsd\">\n\n    <!--开启组件扫描-->\n    <context:component-scan base-package=\"com.aaa\"/>\n    <!--加载jdbc配置文件-->\n    <context:property-placeholder location=\"classpath:jdbc.properties\"/>\n    <!--把数据库连接池交给IOC容器-->\n    <bean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\">\n        <property name=\"driverClassName\" value=\"${jdbc.driver}\"></property>\n        <property name=\"url\" value=\"${jdbc.url}\"></property>\n        <property name=\"username\" value=\"${jdbc.username}\"></property>\n        <property name=\"password\" value=\"${jdbc.password}\"></property>\n    </bean>\n    <!--把QueryRunner交给IOC容器-->\n    <bean id=\"queryRunner\" class=\"org.apache.commons.dbutils.QueryRunner\">\n        <constructor-arg name=\"ds\" ref=\"dataSource\"></constructor-arg>\n    </bean>\n    <!--AOP配置-->\n    <aop:config>\n        <!--切点表达式-->\n        <aop:pointcut id=\"myPointcut\" expression=\"execution(* com.aaa.service..*.*(..))\"/>\n        <!-- 切面配置 -->\n        <aop:aspect ref=\"transactionManager\">\n            <aop:before method=\"beginTransaction\" pointcut-ref=\"myPointcut\"/>\n            <aop:after-returning method=\"commit\" pointcut-ref=\"myPointcut\"/>\n            <aop:after-throwing method=\"rollback\" pointcut-ref=\"myPointcut\"/>\n            <aop:after method=\"release\" pointcut-ref=\"myPointcut\"/>\n        </aop:aspect>\n    </aop:config>\n</beans>\n```\n\n事务管理器（通知）\n\n```java\n/* 事务管理器工具类，包含：开启事务、提交事务、回滚事务、释放资源*/\n@Component\npublic class TransactionManager {\n    @Autowired\n    private ConnectionUtils connectionUtils;\n    public void beginTransaction() {\n        try {\n            connectionUtils.getThreadConnection().setAutoCommit(false);\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n    }\n    public void commit() {\n        try {\n            connectionUtils.getThreadConnection().commit();\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n    }\n    public void rollback() {\n        try {\n            connectionUtils.getThreadConnection().rollback();\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n    }\n    public void release() {\n        try {\n            /* 改回自动提交事务 */\n            connectionUtils.getThreadConnection().setAutoCommit(true);\n            /* 归还到连接池 */\n            connectionUtils.getThreadConnection().close();\n            /* 解除线程绑定 */\n            connectionUtils.removeThreadConnection();\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n测试类\n\n```java\n@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration(\"classpath:applicationContext.xml\")\npublic class AccountTest {\n    @Autowired\n    private AccountService accountService;\n\n    @Test\n    public void testTransfer() throws Exception {\n        accountService.transfer(\"tom\", \"jerry\", 100d);\n    }\n}\n```\n\n### 注解配置实现\n\n开启注解支持 <aop:aspectj-autoproxy /> 配置文件 applicationContext.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:aop=\"http://www.springframework.org/schema/aop\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xsi:schemaLocation=\" http://www.springframework.org/schema/beans\n\t\thttp://www.springframework.org/schema/beans/spring-beans.xsd\n\t\thttp://www.springframework.org/schema/aop\n\t\thttp://www.springframework.org/schema/aop/spring-aop.xsd\n\t\thttp://www.springframework.org/schema/context\n\t\thttp://www.springframework.org/schema/context/spring-context.xsd\">\n\n    <!--开启组件扫描-->\n    <context:component-scan base-package=\"com.aaa\"/>\n    <!--开启AOP注解支持-->\n    <aop:aspectj-autoproxy/>\n    <!--加载jdbc配置文件-->\n    <context:property-placeholder location=\"classpath:jdbc.properties\"/>\n    <!--把数据库连接池交给IOC容器-->\n    <bean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\">\n        <property name=\"driverClassName\" value=\"${jdbc.driver}\"></property>\n        <property name=\"url\" value=\"${jdbc.url}\"></property>\n        <property name=\"username\" value=\"${jdbc.username}\"></property>\n        <property name=\"password\" value=\"${jdbc.password}\"></property>\n    </bean>\n\n    <!--把QueryRunner交给IOC容器-->\n    <bean id=\"queryRunner\" class=\"org.apache.commons.dbutils.QueryRunner\">\n        <constructor-arg name=\"ds\" ref=\"dataSource\"></constructor-arg>\n    </bean>\n</beans>\n```\n\n事务管理器（通知）\n\n```java\n@Component\n@Aspect\npublic class TransactionManager {\n    @Autowired\n    ConnectionUtils connectionUtils;\n\n    @Around(\"execution(* com.aaa.service..*.*(..))\")\n    public Object around(ProceedingJoinPoint pjp) {\n        Object object = null;\n        try {\n            // 开启事务\n            connectionUtils.getThreadConnection().setAutoCommit(false);\n            // 业务逻辑\n            pjp.proceed();\n            // 提交事务\n            connectionUtils.getThreadConnection().commit();\n        } catch (Throwable throwable) {\n            throwable.printStackTrace();\n            // 回滚事务\n            try {\n                connectionUtils.getThreadConnection().rollback();\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n        } finally {\n            try {\n                connectionUtils.getThreadConnection().setAutoCommit(true);\n                connectionUtils.getThreadConnection().close();\n                connectionUtils.removeThreadConnection();\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n        }\n        return object;\n    }\n}\n```\n\n> spring 环绕通知 ProceedingJoinPoint 执行 proceed 方法的作用是让目标方法执行\n>\n> 环绕通知=前置+目标方法执行+后置通知，proceed方法就是用于启动目标方法执行的.\n\n测试类\n\n```java\n@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration(\"classpath:applicationContext.xml\")\npublic class AccountTest {\n    @Autowired\n    private AccountService accountService;\n\n    @Test\n    public void testTransfer() throws Exception {\n        accountService.transfer(\"tom\", \"jerry\", 100d);\n    }\n}\n```\n\n## JdbcTemplate\n\nJdbcTemplate是spring框架中提供的一个模板对象，是对原始繁琐的Jdbc API对象的简单封装。\n\n核心对象 dataSource --->驱动 url username\n\n```java\nJdbcTemplate jdbcTemplate = new JdbcTemplate(DataSource dataSource);\n```\n\n### 整合JdbcTemplate\n\n需求：基于Spring的xml配置实现账户的CRUD案例\n\n创建java项目，导入坐标\n\n```xml\n<dependencies>\n        <!--导入spring的context坐标，context依赖aop-->\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-context</artifactId>\n            <version>5.1.5.RELEASE</version>\n        </dependency>\n        <!-- aspectj的织入（切点表达式需要用到该jar包） -->\n        <dependency>\n            <groupId>org.aspectj</groupId>\n            <artifactId>aspectjweaver</artifactId>\n            <version>1.8.13</version>\n        </dependency>\n        <!--spring整合junit-->\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-test</artifactId>\n            <version>5.1.5.RELEASE</version>\n        </dependency>\n        <dependency>\n            <groupId>junit</groupId>\n            <artifactId>junit</artifactId>\n            <version>4.12</version>\n        </dependency>\n        <!--在spring 框架 中实现事务管理功能-->\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-tx</artifactId>\n            <version>5.1.5.RELEASE</version>\n        </dependency>\n        <!--JDBC API-->\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-jdbc</artifactId>\n            <version>5.1.5.RELEASE</version>\n        </dependency>\n\n        <dependency>\n            <groupId>mysql</groupId>\n            <artifactId>mysql-connector-java</artifactId>\n            <version>5.1.38</version>\n            <scope>runtime</scope>\n        </dependency>\n        <dependency>\n            <groupId>com.alibaba</groupId>\n            <artifactId>druid</artifactId>\n            <version>1.2.8</version>\n        </dependency>\n    </dependencies>\n```\n\n编写Account实体类\n\n```java\npublic class Account {\n    private Integer id;\n    private String name;\n    private Double money;\n\n    public Integer getId() {\n        return id;\n    }\n\n    public void setId(Integer id) {\n        this.id = id;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public Double getMoney() {\n        return money;\n    }\n\n    public void setMoney(Double money) {\n        this.money = money;\n    }\n\n    @Override\n    public String toString() {\n        return \"Account{\" +\n                \"id=\" + id +\n                \", name='\" + name + '\\'' +\n                \", money=\" + money +\n                '}';\n    }\n}\n```\n\n编写AccountDao接口和实现类\n\n```java\npublic interface AccountDao {\n    public List<Account> findAll();\n    public Account findById(Integer id);\n    public void save(Account account);\n    public void update(Account account);\n    public void delete(Integer id);\n}\n```\n\n```java\n@Repository\npublic class AccountDaoImpl implements AccountDao{\n    @Autowired\n    private JdbcTemplate jdbcTemplate;\n    @Override\n    public List<Account> findAll() {\n        // 编写sql \n        String sql = \"select * from account\";\n        // 执行sql \n        return jdbcTemplate.query(sql, new BeanPropertyRowMapper<>(Account.class));\n    }\n\n    @Override\n    public Account findById(Integer id) {\n        // 编写sql \n        String sql = \"select * from account where id = ?\";\n        // 执行sql \n        return jdbcTemplate.queryForObject(sql, new BeanPropertyRowMapper<> (Account.class),id);\n    }\n\n    @Override\n    public void save(Account account) {\n        // 编写sql \n        String sql = \"insert into account values(null,?,?)\";\n        // 执行sql \n        jdbcTemplate.update(sql, account.getName(), account.getMoney());\n\n    }\n\n    @Override\n    public void update(Account account) {\n        // 编写sql \n        String sql = \"update account set name = ?,money = ? where id = ?\";\n        // 执行sql \n        jdbcTemplate.update(sql, account.getName(), account.getMoney(),account.getId());\n    }\n\n    @Override\n    public void delete(Integer id) {\n        // 编写sql \n        String sql = \"delete from account where id = ?\";\n        // 执行sql \n        jdbcTemplate.update(sql, id);\n    }\n}\n```\n\n编写AccountService接口和实现类\n\n```java\npublic interface AccountService {\n    public List<Account> findAll();\n    public Account findById(Integer id);\n    public void save(Account account);\n    public void update(Account account);\n    public void delete(Integer id);\n}\n```\n\n```java\n@Service\npublic class AccountServiceImpl implements AccountService{\n    @Autowired\n    private AccountDao accountDao;\n\n    @Override\n    public List<Account> findAll() {\n        return accountDao.findAll();\n    }\n\n    @Override\n    public Account findById(Integer id) {\n        return accountDao.findById(id);\n    }\n\n    @Override\n    public void save(Account account) {\n        accountDao.save(account);\n    }\n\n    @Override\n    public void update(Account account) {\n        accountDao.update(account);\n    }\n\n    @Override\n    public void delete(Integer id) {\n        accountDao.delete(id);\n    }\n}\n```\n\n编写spring核心配置文件\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n\t\thttp://www.springframework.org/schema/beans/spring-beans.xsd\n\t\thttp://www.springframework.org/schema/context\n\t\thttp://www.springframework.org/schema/context/spring-context.xsd\">\n\n\n    <context:component-scan base-package=\"com.aaa.crud\"/>\n    <context:property-placeholder location=\"classpath:jdbc.properties\"/>\n\n    <bean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\">\n        <property name=\"driverClassName\" value=\"${jdbc.driver}\"></property>\n        <property name=\"url\" value=\"${jdbc.url}\"></property>\n        <property name=\"username\" value=\"${jdbc.username}\"></property>\n        <property name=\"password\" value=\"${jdbc.password}\"></property>\n    </bean>\n\n    <bean id=\"jdbcTemplate\" class=\"org.springframework.jdbc.core.JdbcTemplate\">\n        <constructor-arg name=\"dataSource\" ref=\"dataSource\"></constructor-arg>\n    </bean>\n</beans>\n```\n\n编写测试代码\n\n```java\n@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration(\"classpath:applicationContext-crud.xml\")\npublic class CrudTest {\n    @Autowired\n    private AccountService accountService;\n    //测试保存\n    @Test\n    public void testSave() {\n        Account account = new Account();\n        account.setName(\"lucy\");\n        account.setMoney(100d);\n        accountService.save(account);\n    }\n    //测试查询\n    @Test\n    public void testFindById() {\n        Account account = accountService.findById(3);\n        System.out.println(account);\n    }\n\n    //测试查询所有\n    @Test\n    public void testFindAll() {\n        List<Account> accountList = accountService.findAll();\n        for (Account account : accountList) {\n            System.out.println(account);\n        }\n    }\n\n    //测试修改\n    @Test\n    public void testUpdate() {\n        Account account = new Account();\n        account.setId(3);\n        account.setName(\"rose\");\n        account.setMoney(2000d);\n        accountService.update(account);\n    }\n\n    //测试删除\n    @Test\n    public void testDelete() {\n        accountService.delete(3);\n    }\n}\n```\n\n### 实现转账案例\n\n创建java项目，导入坐标\n\n```xml\n\t<dependencies>\n        <!--导入spring的context坐标，context依赖aop-->\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-context</artifactId>\n            <version>5.1.5.RELEASE</version>\n        </dependency>\n        <!-- aspectj的织入（切点表达式需要用到该jar包） -->\n        <dependency>\n            <groupId>org.aspectj</groupId>\n            <artifactId>aspectjweaver</artifactId>\n            <version>1.8.13</version>\n        </dependency>\n        <!--spring整合junit-->\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-test</artifactId>\n            <version>5.1.5.RELEASE</version>\n        </dependency>\n        <dependency>\n            <groupId>junit</groupId>\n            <artifactId>junit</artifactId>\n            <version>4.12</version>\n        </dependency>\n        <!--在spring 框架 中实现事务管理功能-->\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-tx</artifactId>\n            <version>5.1.5.RELEASE</version>\n        </dependency>\n        <!--JDBC API-->\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-jdbc</artifactId>\n            <version>5.1.5.RELEASE</version>\n        </dependency>\n\n        <dependency>\n            <groupId>mysql</groupId>\n            <artifactId>mysql-connector-java</artifactId>\n            <version>5.1.38</version>\n            <scope>runtime</scope>\n        </dependency>\n        <dependency>\n            <groupId>com.alibaba</groupId>\n            <artifactId>druid</artifactId>\n            <version>1.2.8</version>\n        </dependency>\n    </dependencies>\n```\n\n编写Account实体类\n\n```java\npublic class Account {\n    private Integer id;\n    private String name;\n    private Double money;\n\n    public Integer getId() {\n        return id;\n    }\n\n    public void setId(Integer id) {\n        this.id = id;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public Double getMoney() {\n        return money;\n    }\n\n    public void setMoney(Double money) {\n        this.money = money;\n    }\n\n    @Override\n    public String toString() {\n        return \"Account{\" +\n                \"id=\" + id +\n                \", name='\" + name + '\\'' +\n                \", money=\" + money +\n                '}';\n    }\n}\n```\n\n编写AccountDao接口和实现类\n\n```java\npublic interface AccountDao {\n    /* 转出操作 */\n    public void out(String outUser, Double money);\n    /* 转入操作 */\n    public void in(String inUser, Double money);\n}\n```\n\n```java\n@Repository\npublic class AccountDaoImpl implements AccountDao {\n\n    @Autowired\n    private JdbcTemplate jdbcTemplate;\n    @Override\n    public void out(String outUser, Double money) {\n        jdbcTemplate.update(\"update account set money = money - ? where name = ?\", money, outUser);\n    }\n    @Override\n    public void in(String inUser, Double money) {\n        jdbcTemplate.update(\"update account set money = money + ? where name = ?\", money, inUser);\n    }\n}\n```\n\n编写AccountService接口和实现类\n\n```java\npublic interface AccountService {\n    public void transfer(String outUser, String inUser, Double money);\n}\n```\n\n```java\n@Service\npublic class AccountServiceImpl implements AccountService {\n    @Autowired\n    private AccountDao accountDao;\n    @Override\n    public void transfer(String outUser, String inUser, Double money) {\n            accountDao.out(outUser, money);\n            accountDao.in(inUser, money);\n    }\n}\n```\n\n编写spring核心配置文件\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xsi:schemaLocation=\" http://www.springframework.org/schema/beans\n\t\thttp://www.springframework.org/schema/beans/spring-beans.xsd\n\t\thttp://www.springframework.org/schema/context\n\t\thttp://www.springframework.org/schema/context/spring-context.xsd\">\n\n    <!--开启组件扫描-->\n    <context:component-scan base-package=\"com.aaa\"/>\n    <!--加载jdbc配置文件-->\n    <context:property-placeholder location=\"classpath:jdbc.properties\"/>\n    <!--把数据库连接池交给IOC容器-->\n    <bean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\">\n        <property name=\"driverClassName\" value=\"${jdbc.driver}\"></property>\n        <property name=\"url\" value=\"${jdbc.url}\"></property>\n        <property name=\"username\" value=\"${jdbc.username}\"></property>\n        <property name=\"password\" value=\"${jdbc.password}\"></property>\n    </bean>\n    <!--把JdbcTemplate交给IOC容器-->\n    <bean id=\"jdbcTemplate\" class=\"org.springframework.jdbc.core.JdbcTemplate\">\n        <constructor-arg name=\"dataSource\" ref=\"dataSource\"></constructor-arg>\n    </bean>\n</beans>\n```\n\n编写测试代码\n\n```java\n@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration(\"classpath:applicationContext.xml\")\npublic class AccountTest {\n    @Autowired\n    private AccountService accountService;\n\n    @Test\n    public void testTransfer() throws Exception {\n        accountService.transfer(\"tom\", \"jerry\", 100d);\n    }\n}\n```\n\n## Spring的事务\n\nSpring的事务控制可以分为编程式事务控制和声明式事务控制。 \n\n**编程式**：开发者直接把事务的代码和业务代码耦合到一起，在实际开发中不用。 \n\n**声明式**：开发者采用配置的方式来实现的事务控制，业务代码与事务代码实现解耦合，使用的AOP思想。 \n\n### 编程式事务控制（了解）\n\n> PlatformTransactionManager接口，是spring的事务管理器，里面提供了我们常用的操作事务的方法\n\n| 方法                                                         | 说明               |\n| ------------------------------------------------------------ | ------------------ |\n| TransactionStatus getTransaction(TransactionDefinition definition); | 获取事务的状态信息 |\n| void commit(TransactionStatus status);                       | 提交事务           |\n| void rollback(TransactionStatus status);                     | 回滚事务           |\n\n> PlatformTransactionManager 是接口类型，不同的 Dao 层技术则有不同的实现类\n\nDao层技术是jdbcTemplate或mybatis时： DataSourceTransactionManager \n\nDao层技术是hibernate时： HibernateTransactionManager \n\nDao层技术是JPA时： JpaTransactionManager\n\n> TransactionDefinition接口提供事务的定义信息（事务隔离级别、事务传播行为等等）\n\n| 方法                         | 说明               |\n| ---------------------------- | ------------------ |\n| int getlsolationLevel()      | 获得事务的隔离级别 |\n| int getPropogationBehavior() | 获得事务的传播行为 |\n| int getTimeout()             | 获得超时时间       |\n| boolean isReadOnly()         | 是否只读           |\n\n**事务隔离级别**\n\n设置隔离级别，可以解决事务并发产生的问题，如脏读、不可重复读和虚读（幻读）\n\n```sql\n* ISOLATION_DEFAULT 使用数据库默认级别\n* ISOLATION_READ_UNCOMMITTED 读未提交 \n* ISOLATION_READ_COMMITTED 读已提交\n* ISOLATION_REPEATABLE_READ 可重复读 \n* ISOLATION_SERIALIZABLE 串行化\n```\n\n**事务传播行为** \n\n事务传播行为指的就是当一个业务方法【被】另一个业务方法调用时，应该如何进行事务控制。\n\n| 参数          | 说明                                                         |\n| ------------- | ------------------------------------------------------------ |\n| REQUIRED      | 如果当前没有事务，就新建一个事务，如果已经存在一个事务中<br>加入到这个事务中。一般的选择（默认值) |\n| SUPPORTS      | 新建事务，如果当前在事务中，把当前事务挂起                   |\n| MANDATORY     | 使用当前的事务，如果当前没有事务，就抛出异常                 |\n| REQUERS_NEW   | 新建事务，如果当前在事务中，把当前事务挂起                   |\n| NOT_SUPPORTED | 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起     |\n| NEVER         | 以非事务方式运行，如果当前存在事务，抛出异常                 |\n| NESTED        | 如果当前存在事务，则在嵌套事务内执行。如果当前没有事务<br>则执行REQUIRED类似的操作 |\n\nread-only（是否只读）：建议查询时设置为只读\n\ntimeout（超时时间）：默认值是-1，没有超时限制。如果有，以秒为单位进行设置\n\n> TransactionStatus 接口提供的是事务具体的运行状态\n\n| 方法                       | 说明         |\n| -------------------------- | ------------ |\n| boolean isNewTransaction() | 是否是新事务 |\n| boolean hasSavepoint()     | 是否是回滚点 |\n| boolean isRollbackOnly()   | 事务是否回滚 |\n| boolean isCompleted()      | 事务是否完成 |\n\n**实现代码**\n\n配置文件\n\n```xml\n<!--事务管理器交给IOC-->\n    <bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\n        <property name=\"dataSource\" ref=\"dataSource\"/>\n    </bean>\n```\n\n业务层代码\n\n```java\n@Service\npublic class AccountServiceImpl implements AccountService {\n    @Autowired\n    private AccountDao accountDao;\n    @Autowired\n    private PlatformTransactionManager transactionManager;\n    @Override\n    public void transfer(String outUser, String inUser, Double money) {\n        // 创建事务定义对象 \n        DefaultTransactionDefinition def = new DefaultTransactionDefinition();\n        // 设置是否只读，false支持事务 \n        def.setReadOnly(false);\n        // 设置事务隔离级别，可重复读mysql默认级别 \n        def.setIsolationLevel(TransactionDefinition.ISOLATION_REPEATABLE_READ);\n        // 设置事务传播行为，必须有事务 \n        def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);\n        // 配置事务管理器 \n        TransactionStatus status = transactionManager.getTransaction(def);\n        try {\n            // 转账 \n            accountDao.out(outUser, money);\n            accountDao.in(inUser, money);\n            // 提交事务 \n            transactionManager.commit(status);\n        } catch (Exception e) {\n            e.printStackTrace();\n            // 回滚事务 \n            transactionManager.rollback(status);\n        }\n    }\n}\n```\n\nPlatformTransactionManager 负责事务的管理，它是个接口，其子类负责具体工作 \n\nTransactionDefinition 定义了事务的一些相关参数 \n\nTransactionStatus 代表事务运行的一个实时状态\n\n可以简单理解三者的关系：事务管理器通过读取事务定义参数进行事务管理，然后会产生一系列的事务状态。\n\n### 基于XML的声明式事务控制\n\n在 Spring 配置文件中声明式的处理事务来代替代码式的处理事务。底层采用AOP思想来实现的。\n\n需求：使用spring声明式事务控制转账业务。\n\n引入tx命名空间 aop命名空间\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:aop=\"http://www.springframework.org/schema/aop\"\n       xmlns:tx=\"http://www.springframework.org/schema/tx\"\n       xsi:schemaLocation=\"\nhttp://www.springframework.org/schema/beans\nhttp://www.springframework.org/schema/beans/spring-beans.xsd\nhttp://www.springframework.org/schema/context\nhttp://www.springframework.org/schema/context/spring-context.xsd\nhttp://www.springframework.org/schema/aop\nhttp://www.springframework.org/schema/aop/spring-aop.xsd\nhttp://www.springframework.org/schema/tx\nhttp://www.springframework.org/schema/tx/spring-tx.xsd\nhttp://www.w3.org/2001/XMLSchema-instance\nhttp://www.w3.org/2001/XMLSchema-instance \">\n    <context:component-scan base-package=\"com.aaa\"/>\n    <context:property-placeholder location=\"classpath:jdbc.properties\"/>\n    <bean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\">\n        <property name=\"driverClassName\" value=\"${jdbc.driver}\"></property>\n        <property name=\"url\" value=\"${jdbc.url}\"></property>\n        <property name=\"username\" value=\"${jdbc.username}\"></property>\n        <property name=\"password\" value=\"${jdbc.password}\"></property>\n    </bean>\n    <!--把JdbcTemplate交给IOC容器-->\n    <bean id=\"jdbcTemplate\" class=\"org.springframework.jdbc.core.JdbcTemplate\">\n        <constructor-arg name=\"dataSource\" ref=\"dataSource\"></constructor-arg>\n    </bean>\n</beans>\n```\n\n事务管理器通知配置\n\n```xml\n<!--事务管理器-->\n    <bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\n        <property name=\"dataSource\" ref=\"dataSource\"></property>\n    </bean>\n    <!--通知增强-->\n    <tx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\">\n        <!--定义事务的属性-->\n        <tx:attributes>\n            <tx:method name=\"*\"/>\n        </tx:attributes>\n    </tx:advice>\n```\n\n事务管理器AOP配置\n\n```xml\n\t<!--aop配置-->\n    <aop:config>\n        <!--切面配置-->\n        <aop:advisor advice-ref=\"txAdvice\"pointcut=\"execution(* com.aaa.service..*.*(..))\"/>\n    </aop:config>\n```\n\n事务控制转账业务代码\n\n```java\n@Service\npublic class AccountServiceImpl implements AccountService {\n    @Autowired\n    private AccountDao accountDao;\n    @Override\n    public void transfer(String outUser, String inUser, Double money) {\n            accountDao.out(outUser, money);\n            accountDao.in(inUser, money);\n    }\n}\n```\n\n测试类\n\n```java\n@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration(\"classpath:applicationContext.xml\")\npublic class AccountTest {\n    @Autowired\n    private AccountService accountService;\n\n    @Test\n    public void testTransfer() throws Exception {\n        accountService.transfer(\"tom\", \"jerry\", 100d);\n    }\n}\n```\n\n**事务参数的配置详解**\n\n```\n<tx:method name=\"transfer\" isolation=\"REPEATABLE_READ\" \tpropagation=\"REQUIRED\" timeout=\"-1\" read-only=\"false\"/> \n* name：切点方法名称\n* isolation:事务的隔离级别\n* propogation：事务的传播行为\n* timeout：超时时间\n* read-only：是否只读\n```\n\nCRUD常用配置\n\n```xml\n<tx:attributes>\n    <tx:method name=\"save*\" propagation=\"REQUIRED\"/>\n    <tx:method name=\"delete*\" propagation=\"REQUIRED\"/>\n    <tx:method name=\"update*\" propagation=\"REQUIRED\"/>\n    <tx:method name=\"find*\" read-only=\"true\"/>\n    <tx:method name=\"*\"/>\n</tx:attributes>\n```\n\n### 基于注解的声明式事务控制\n\n修改service层，增加事务注解\n\n```java\n@Service\npublic class AccountServiceImpl implements AccountService {\n    @Autowired\n    private AccountDao accountDao;\n    @Transactional(propagation = Propagation.REQUIRED, isolation = Isolation.REPEATABLE_READ, timeout = -1, readOnly = false)\n    @Override\n    public void transfer(String outUser, String inUser, Double money) {\n\n            accountDao.out(outUser, money);\n            accountDao.in(inUser, money);\n    }\n}\n```\n\n修改spring核心配置文件，开启事务注解支持（可由 SpringConfig 替代）\n\n```xml\n<!--省略之前datsSource、jdbcTemplate、组件扫描配置-->\n    <!--事务管理器-->\n    <bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\n        <property name=\"dataSource\" ref=\"dataSource\"></property>\n    </bean>\n\t<!--事务的注解支持--> \n    <tx:annotation-driven/>\n```\n\n核心配置类\n\n```java\n@Configuration // 声明为spring配置类\n@ComponentScan(\"com.aaa\") // 扫描包\n@Import(DataSourceConfig.class) // 导入其他配置类\n@EnableTransactionManagement // 事务的注解驱动\npublic class SpringConfig {\n    @Bean\n    public JdbcTemplate getJdbcTemplate(@Autowired DataSource dataSource) {\n        return new JdbcTemplate(dataSource);\n    }\n\n    @Bean(\"transactionManager\")\n    public PlatformTransactionManager getPlatformTransactionManager(@Autowired \tDataSource dataSource) {\n        return new DataSourceTransactionManager(dataSource);\n    }\n}\n```\n\n数据源配置类\n\n```java\n@PropertySource(\"classpath:jdbc.properties\")\npublic class DataSourceConfig {\n    @Value(\"${jdbc.driver}\")\n    private String driver;\n    @Value(\"${jdbc.url}\")\n    private String url;\n    @Value(\"${jdbc.username}\")\n    private String username;\n    @Value(\"${jdbc.password}\")\n    private String password;\n\n    @Bean\n    public DataSource getDataSource() {\n        DruidDataSource dataSource = new DruidDataSource();\n        dataSource.setDriverClassName(driver);\n        dataSource.setUrl(url);\n        dataSource.setUsername(username);\n        dataSource.setPassword(password);\n        return dataSource;\n    }\n}\n```\n\n测试类\n\n```java\n@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration(classes = SpringConfig.class)\n//@ContextConfiguration(\"classpath:applicationContext-crud.xml\")\npublic class AccountTest {\n    @Autowired\n    private AccountService accountService;\n\n    @Test\n    public void testTransfer() throws Exception {\n        accountService.transfer(\"tom\", \"jerry\", 100d);\n    }\n}\n```\n","tags":["Spring"],"categories":["学习之路"]},{"title":"MyBatis","url":"/2022/11/07/MyBatis/","content":"\n## mybatis\n\n### 三层架构\n\n软件开发常用的架构是三层架构，之所以流行是因为有着清晰的任务划分。一般包括以下三层： \n\n- 持久层：主要完成与数据库相关的操作，即对数据库的增删改查。 因为数据库访问的对象一般称为Data Access Object（简称DAO），所以有人把持久层叫做DAO 层。 \n\n- 业务层：主要根据功能需求完成业务逻辑的定义和实现。 因为它主要是为上层提供服务的，所以有人把业务层叫做Service层或Business层。 \n\n- 表现层：主要完成与最终软件使用用户的交互，需要有交互界面（UI）。 因此，有人把表现层称之为web层或View层。 \n\n三层架构之间调用关系为:表现层调用业务层，业务层调用持久层。 各层之间必然要进行数据交互，我们一般使用java实体对象来传递数据。\n\n### 框架\n\n**什么是框架**\n\n框架就是一套规范，既然是规范，你使用这个框架就要遵守这个框架所规定的约束。 框架可以理解为半成品软件，框架做好以后，接下来在它基础上进行开发。 \n\n**为什么使用框架**\n\n框架为我们封装好了一些冗余，且重用率低的代码。并且使用反射与动态代理机制，将代码实现了通 用性，让 开发人员把精力专注在核心的业务代码实现上。  \n\n比如在使用servlet进行开发时，需要在servlet获取表单的参数，每次都要获取很麻烦，而框架底层 就使用反射机制和拦截器机制帮助我们获取表单的值，使用jdbc每次做专一些简单的crud的时候都必须 写sql，但使用框架就不需要这么麻烦了，直接调用方法就可以。当然，既然是使用框架，那么还是要 遵循其一些规范进行配置 \n\n**常见的框架** \n\nJava世界中的框架非常的多，每一个框架都是为了解决某一部分或某些问题而存在的。下面列出在目 前企业中 流行的几种框架（一定要注意他们是用来解决哪一层问题的）：\n\n-  持久层框架：专注于解决数据持久化的框架。常用的有mybatis、hibernate、spring jdbc等等。 \n\n-  表现层框架：专注于解决与用户交互的框架。常见的有struts2、spring mvc等等。 \n\n-  全栈框架: 能在各层都给出解决方案的框架。比较著名的就是spring。\n\n我们以企业中最常用的组合为准来学习Spring + Spring MVC + mybatis（SSM）\n\n### Mybatis入门\n\n**为什么要学习mybatis**\n\n原始jdbc开发存在的问题如下： \n\n- 数据库连接创建、释放频繁造成系统资源浪费从而影响系统性能\n\n- sql 语句在代码中硬编码，造成代码不易维护，实际应用 sql 变化的可能较大，sql 变动需要改变java 代码。\n\n- 查询操作时，需要手动将结果集中的数据手动封装到实体中。\n\n应对上述问题给出的解决方案： \n\n-  使用数据库连接池初始化连接资源 \n\n-  将sql语句抽取到xml配置文件中 \n\n-  使用反射、内省等底层技术，自动将实体与表进行属性与字段的自动映射\n\n**Mybatis简介**\n\nMyBatis是一个优秀的基于ORM的半自动轻量级持久层框架，它对jdbc的操作数据库的过程进行封装， 使开发者只需要关注 SQL 本身，而不需要花费精力去处理例如注册驱动、创建connection、创建 statement、手动设置参数、结果集检索等jdbc繁杂的过程代码 \n\n**ORM思想** \n\nORM（Object Relational Mapping）对象关系映射 \n\n- O（对象模型）\n\n- 实体对象，即我们在程序中根据数据库表结构建立的一个个实体javaBean \n\n- R（关系型数据库的数据结构）： \n\n- 关系数据库领域的Relational（建立的数据库表） \n\n- M（映射）\n\n- 从R（数据库）到O（对象模型）的映射，可通过XML文件映射 \n\n实现：  \n\n- 让实体类和数据库表进行一一对应关系  \n\n- 先让实体类和数据库表对应  再让实体类属性和表里面字段对应  \n\n- 不需要直接操作数据库表，直接操作表对应的实体类对象 \n\n## 编写mybatis(核心)\n\n**案例需求：**通过mybatis查询数据库user表的所有记录，封装到User对象中，打印到控制台上\n\n**流程分析:**\n\n1. 创建数据库及user表 \n\n2. 创建maven工程，导入依赖（MySQL驱动、mybatis、junit） \n\n3. 编写User实体类 \n\n4. 编写UserMapper.xml映射配置文件（ORM思想）\n\n5. 编写SqlMapConfig.xml核心配置文件 数据库环境配置 映射关系配置的引入(引入映射配置文件的路径) \n\n6. 编写测试代码 \n\n**创建user数据表** \n\n```sql\nCREATE DATABASE `mybatis_db`;\nUSE `mybatis_db`;\nCREATE TABLE `user` (\n                        `id` int(11) NOT NULL auto_increment,\n                        `username` varchar(32) NOT NULL COMMENT '用户名称',\n                        `birthday` datetime default NULL COMMENT '生日',\n                        `sex` char(1) default NULL COMMENT '性别',\n                        `address` varchar(256) default NULL COMMENT '地址',\n                        PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n\ninsert into `user`(`id`,`username`,`birthday`,`sex`,`address`)\nvalues (1,'zxh','2022-08-23 00:00:00','男','河南郑州'),\n       (2,'gy','2022-08-24 00:00:00','男','河南郑州');\n```\n\n**导入MyBatis的坐标和其他相关坐标**\n\n```xml\n\t\t<!--mysql驱动坐标-->\n        <dependency>\n            <groupId>mysql</groupId>\n            <artifactId>mysql-connector-java</artifactId>\n            <version>5.1.38</version>\n            <scope>runtime</scope>\n        </dependency>\n\t\t<!--mybatis坐标-->\n        <dependency>\n            <groupId>org.mybatis</groupId>\n            <artifactId>mybatis</artifactId>\n            <version>3.5.4</version>\n        </dependency>\n      \t<!--单元测试坐标-->\n        <dependency>\n            <groupId>junit</groupId>\n            <artifactId>junit</artifactId>\n            <version>4.12</version>\n            <scope>test</scope>\n        </dependency>\n```\n\n**编写User实体**\n\ncom.example.demo2.domain\n\nUser.java\n\n```java\npublic class User {\n    private Integer id;\n    private String username;\n    private Date birthday;\n    private String sex;\n    private String address;\n\n    public Integer getId() {\n        return id;\n    }\n\n    public void setId(Integer id) {\n        this.id = id;\n    }\n\n    public String getUsername() {\n        return username;\n    }\n\n    public void setUsername(String username) {\n        this.username = username;\n    }\n\n    public Date getBirthday() {\n        return birthday;\n    }\n\n    public void setBirthday(Date birthday) {\n        this.birthday = birthday;\n    }\n\n    public String getSex() {\n        return sex;\n    }\n\n    public void setSex(String sex) {\n        this.sex = sex;\n    }\n\n    public String getAddress() {\n        return address;\n    }\n\n    public void setAddress(String address) {\n        this.address = address;\n    }\n\n    @Override\n    public String toString() {\n        return \"User{\" +\n                \"id=\" + id +\n                \", username='\" + username + '\\'' +\n                \", birthday=\" + birthday +\n                \", sex='\" + sex + '\\'' +\n                \", address='\" + address + '\\'' +\n                '}';\n    }\n}\n```\n\n**编写UserMapper映射文件**\n\nresource文件夹下，com.example.mapper 一层一层创建，一次创建三层会报错找不到文件\n\nusermapper.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE mapper\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n<mapper namespace=\"UserMapper\">\n    <!--查询所有-->\n    <select id=\"findAll\" resultType=\"com.example.demo2.domain.User\">\n        select * from user\n    </select>\n</mapper>\n```\n\nresource文件夹下 创建核心配置文件,可以叫mybatis-config.xml 或其他都可以，这里我们叫sqlMapConfig.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE configuration\n        PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n<configuration>\n    <!--环境配置-->\n    <environments default=\"development\">\n        <!--使用MySQL环境-->\n        <environment id=\"development\">\n            <!--使用JDBC类型事务管理器-->\n            <transactionManager type=\"JDBC\"></transactionManager>\n            <!--使用连接池-->\n            <dataSource type=\"POOLED\">\n                <property name=\"driver\" value=\"com.mysql.jdbc.Driver\"></property>\n                <property name=\"url\" value=\"jdbc:mysql:///mybatis_db?useSSL=false&amp;useServerPrepStmts=true&amp;characterEncoding=utf-8&amp;serverTimezone=Asia/Shanghai\"></property>\n                <property name=\"username\" value=\"root\"></property>\n                <property name=\"password\" value=\"123456\"></property>\n            </dataSource>\n        </environment>\n    </environments>\n    <!--加载映射配置-->\n    <mappers>\n        <mapper resource=\"com/example/mapper/UserMapper.xml\"></mapper>\n    </mappers>\n</configuration>\n```\n\n如果有乱码问题 url改为 \n\n```java\njdbc:mysql:///mybatis_db?useUnicode=true&amp;characterEncoding=utf-8\n```\n\n**编写测试类**\n\n```java\npublic class MybatisTest {\n    public static void main(String[] args) throws IOException {\n        /* 加载核心配置文件 */\n        InputStream is = Resources.getResourceAsStream(\"SqlMapConfig.xml\");\n        /* 获取SqlSessionFactory工厂对象 */\n        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);\n        /* 获取SqlSession会话对象 */\n        SqlSession sqlSession = sqlSessionFactory.openSession();\n        /* 执行sql */\n        List<User> list = sqlSession.selectList(\"UserMapper.findAll\");\n        for (User user : list) {\n            System.out.println(user);\n        }\n        /*  释放资源  */\n        sqlSession.close();\n    }\n}\n```\n\n## Mybatis增删改查\n\n**增加映射文件UserMapper.xml** \n\n```xml\n<!-- 插入语句使用insert标签 -->\n<insert id=\"save\" parameterType=\"com.example.demo2.domain.User\">\n    insert into user(username,birthday,sex,address) values(#{username},#{birthday},#{sex},#{address})\n</insert>\n```\n\n**编写测试类**\n\n```java\n\t@Test\n    public void testSave() throws Exception {\n        /* 加载核心配置文件 */\n        InputStream is = Resources.getResourceAsStream(\"SqlMapConfig.xml\");\n        /* 获取SqlSessionFactory工厂对象 */\n        SqlSessionFactory sqlSessionFactory = new\n                SqlSessionFactoryBuilder().build(is);\n        /* 获取SqlSession会话对象 */\n        SqlSession sqlSession = sqlSessionFactory.openSession();\n        /* 执行sql */\n        User user = new User();\n        user.setUsername(\"zxl\");\n        user.setBirthday(new Date());\n        user.setSex(\"男\");\n        user.setAddress(\"河南郑州\");\n        sqlSession.insert(\"UserMapper.save\", user);\n\n        /* DML语句，手动提交事务 */\n        sqlSession.commit();\n        /* 释放资源 */\n        sqlSession.close();\n    }\n```\n\n**增加映射文件UserMapper.xml** \n\n```xml\n<!--修改语句使用update标签 -->\n    <update id=\"update\" parameterType=\"com.example.demo2.domain.User\">\n        update user set username = #{username},birthday = #{birthday},\n                        sex = #{sex},address = #{address} where id = #{id}\n    </update>\n```\n\n**编写测试类**\n\n```java\n\t@Test\n    public void testUpdate() throws Exception {\n        /* 加载核心配置文件 */\n        InputStream is = Resources.getResourceAsStream(\"SqlMapConfig.xml\");\n        /* 获取SqlSessionFactory工厂对象 */\n        SqlSessionFactory sqlSessionFactory = new\n                SqlSessionFactoryBuilder().build(is);\n        /* 获取SqlSession会话对象 */\n        SqlSession sqlSession = sqlSessionFactory.openSession();\n        /* 执行sql */\n        User user = new User();\n        user.setId(3);\n        user.setUsername(\"zxl\");\n        user.setBirthday(new Date());\n        user.setSex(\"女\");\n        user.setAddress(\"河南郑州\");\n        sqlSession.update(\"UserMapper.update\", user);\n        /* DML语句，手动提交事务 */\n        sqlSession.commit();\n        /* 释放资源 */\n        sqlSession.close();\n    }\n```\n\n**增加映射文件UserMapper.xml** \n\n```xml\n<!--删除语句使用delete标签 -->\n    <delete id=\"delete\" parameterType=\"com.example.demo2.domain.User\">\n        delete from user where id = #{id}\n    </delete>\n```\n\n**编写测试类**\n\n```java\n\t@Test\n    public void testDelete() throws Exception {\n        /* 加载核心配置文件 */\n        InputStream is = Resources.getResourceAsStream(\"SqlMapConfig.xml\");\n        /* 获取SqlSessionFactory工厂对象 */\n        SqlSessionFactory sqlSessionFactory = new\n                SqlSessionFactoryBuilder().build(is);\n        /* 获取SqlSession会话对象 */\n        SqlSession sqlSession = sqlSessionFactory.openSession();\n        /* 执行sql */\n        sqlSession.delete(\"UserMapper.delete\", 3);\n        /* DML语句，手动提交事务 */\n        sqlSession.commit();\n        /* 释放资源 */\n        sqlSession.close();\n    }\n```\n\n## MyBatis常用配置解析\n\n###  environments标签 \n\n**sqlMapConfig.xml**\n\nresource文件夹下 jdbc.properties\n\n```properties\njdbc.driver=com.mysql.jdbc.Driver\njdbc.url=jdbc:mysql:///mybatis_db?useSSL=false&useServerPrepStmts=true&characterEncoding=utf-8&serverTimezone=Asia/Shanghai\njdbc.username=root\njdbc.password=123456\n```\n\nsqlMapConfig.xml 中\n\n```xml\n\t<!--导入jdbc.properties文件-->\t\n\t<properties resource=\"jdbc.properties\"></properties>\n    <!--环境配置 指定默认的环境名称-->\n    <environments default=\"development\">\n        <!--使用MySQL环境 指定当前的环境名称-->\n        <environment id=\"development\">\n            <!--使用JDBC类型事务管理器-->\n            <transactionManager type=\"JDBC\"></transactionManager>\n            <!--使用连接池-->\n            <!--数据源配置的参数-->\n            <dataSource type=\"POOLED\">\n                <property name=\"driver\" value=\"${jdbc.driver}\"></property>\n                <property name=\"url\" value=\"${jdbc.url}\"></property>\n                <property name=\"username\" value=\"${jdbc.username}\"></property>\n                <property name=\"password\" value=\"${jdbc.password}\"></property>\n            </dataSource>\n        </environment>\n    </environments>\n```\n\n事务管理器（transactionManager）类型有两种：\n\n- JDBC： 这个配置就是直接使用了JDBC 的提交和回滚设置，它依赖于从数据源得到的连接来管理事务作用域。 \n\n-  MANAGER： 这个配置几乎没做什么。它从来不提交或回滚一个连接，而是让容器来管理事务的整个生命周期。\n\n 数据源（dataSource）常用类型有三种：\n\n- UNPOOLED\n\n- 这个数据源的实现只是每次被请求时打开和关闭连接。\n\n- POOLED：\n\n- 这种数据源的实现利用“池”的概念将 JDBC 连接对象组织起来。\n\n-  JNDI :\n\n- 这个数据源实现是为了能在如 EJB 或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个 JNDI 上下文的数据源引用\n\n### properties标签 \n\n实际开发中，习惯将数据源的配置信息单独抽取成一个properties文件，该标签可以加载额外配置的 properties\n\n```properties\njdbc.driver=com.mysql.jdbc.Driver\njdbc.url=jdbc:mysql:///mybatis_db?useSSL=false&useServerPrepStmts=true&characterEncoding=utf-8&serverTimezone=Asia/Shanghai\njdbc.username=root\njdbc.password=123456\n```\n\n### typeAliases标签 \n\n类型别名是为 Java 类型设置一个短的名字。 为了简化映射文件 Java 类型设置，mybatis框架为我们设置好的一些常用的类型的别名\n\n**为domain 下的类配置别名**\n\n```xml\n<!--设置别名 sqlMapConfig.xml 里面-->\n<typeAliases>\n\t<!--方式一: 给单个实体起别名-->\n    <typeAlias type=\"com.aaa.domain.User\" alias=\"user\"/>\n    <!--方式二: 批量起别名 不区分大小写 配置后方式一不可写-->\n    <package name=\"com.aaa.domain\"/>\n   <!--配置后，使用domain包下的类，只需类名即可-->\n</typeAliases>\n```\n\n### **mappers标签** \n\n该标签的作用是加载映射的，加载方式有如下几种：\n\n```xml\n1. 使用相对于类路径的资源引用，例如：\n<mapper resource=\"xxx/xxx/xxx/userMapper.xml\"/>\n2. 使用完全限定资源定位符（URL），例如：\n<mapper url=\"file:///xxx/xxx/userMapper.xml\"/>\n《下面两种mapper代理开发中使用:暂时了解》\n3. 使用映射器接口实现类的完全限定类名，例如：\n<mapper class=\"xxx.xxx.xxx.userMapper\"/>\n4. 将包内的映射器接口实现全部注册为映射器，例如：\n<package name=\"xxx.xxx.builder\"/>\n```\n\n### plugins标签\n\nplugins 标签是配置 MyBatis 的插件\n\nMyBatis可以使用第三方的插件来对功能进行扩展，分页助手PageHelper是将分页的复杂操作进行封装，使用简单的方式即可获得分页的相关数据\n\n开发步骤：导入通用PageHelper的坐标，在mybatis核心配置文件中配置PageHelper插件，测试分页数据获取\n\npom.xml\n\n```xml\n\t\t<!-- 分页助手 -->\n        <dependency>\n            <groupId>com.github.pagehelper</groupId>\n            <artifactId>pagehelper</artifactId>\n            <version>3.7.5</version>\n        </dependency>\n        <dependency>\n            <groupId>com.github.jsqlparser</groupId>\n            <artifactId>jsqlparser</artifactId>\n            <version>0.9.1</version>\n        </dependency>\n```\n\n在mybatis核心配置文件( sqlMapConfig.xml )中配置PageHelper插件\n\n```xml\n<!-- typeAliases 标签后插入 分页助手的插件 -->\n    <plugins>\n        <plugin interceptor=\"com.github.pagehelper.PageHelper\">\n            <!--dialect: 指定方言 limit-->\n            <property name=\"dialect\" value=\"mysql\"/>\n        </plugin>\n    </plugins>\n```\n\n测试分页代码实现\n\n```java\n\t@Test\n    public void testPageHelper() throws IOException {\n        SqlSession sqlSession = new GetSqlSession().getSqlSession();\n        UserMapper mapper = sqlSession.getMapper(UserMapper.class);\n        //设置分页参数 第一个参数是页数,第二个参数是条数，每页查询的条数\n        PageHelper.startPage(1,2);\n        List<User> select = mapper.findAll();\n        for(User user : select){\n            System.out.println(user);\n        }\n    }\n```\n\n获得分页相关的其他参数\n\n```java\n\t@Test\n    public void testPageHelper() throws IOException {\n        //设置分页参数\n        SqlSession sqlSession = new GetSqlSession().getSqlSession();\n        UserMapper mapper = sqlSession.getMapper(UserMapper.class);\n        PageHelper.startPage(1,2);\n        List<User> select = mapper.findAll();\n        for(User user : select){\n            System.out.println(user);\n        }\n        //其他分页的数据\n        PageInfo<User> pageInfo = new PageInfo<User>(select);\n        System.out.println(\"总条数：\"+pageInfo.getTotal());\n        System.out.println(\"总页数：\"+pageInfo.getPages());\n        System.out.println(\"当前页：\"+pageInfo.getPageNum());\n        System.out.println(\"每页显示长度：\"+pageInfo.getPageSize());\n        System.out.println(\"是否第一页：\"+pageInfo.isIsFirstPage());\n        System.out.println(\"是否最后一页：\"+pageInfo.isIsLastPage());\n    }\n```\n\n## Mybatis的API概述 \n\n> API介绍\n\n### SqlSessionFactoryBuilder\n\n常用API：SqlSessionFactory build(InputStream inputStream)\n\n通过加载mybatis的核心文件的输入流的形式构建一个SqlSessionFactory对象\n\n```java\nInputStream inputStream = Resources.getResourceAsStream(\"SqlMapConfig.xml\"); \n\nSqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); \n\nSqlSessionFactory factory = builder.build(inputStream);\n```\n\n其中， Resources 工具类，这个类在 org.apache.ibatis.io 包中。Resources 类帮助你从类路径下文件系统或一个 web URL 中加载资源文件。\n\n### SqlSessionFactory\n\nSqlSessionFactory 有多个个方法创建SqlSession 实例。常用的有如下两个：\n\n```java\nSqlSessionFactory factory = builder.build(inputStream);\nSqlSession sqlSession = factory.openSession();\n\nSqlSession sqlSession = factory.openSession(true);//自动提交事务\n```\n\n**SqlSession会话对象** \n\nSqlSession 实例在 MyBatis 中是非常强大的一个类。在这里你会看到所有执行语句、提交或回滚事务 和获取映射器实例的方法。 执行语句的方法主要有：\n\n```java\n<T> T selectOne(String statement, Object parameter)\n\n<E> List<E> selectList(String statement, Object parameter)\n\nint insert(String statement, Object parameter)\n\nint update(String statement, Object parameter)\n\nint delete(String statement, Object parameter)\n```\n\n操作事务的方法主要有：\n\n```java\nvoid commit() \nvoid rollback()\n```\n\n## Mybatis的dao层开发使用\n\n### 传统开发方式\n\n**编写UserMapper接口**\n\n```java\npublic interface UserMapper {\n    public List findAll() throws Exception;\n}\n```\n\n**编写UserMapper实现**\n\n```java\npublic class UserMapperImpl implements UserMapper {\n    @Override\n    public List<User> findAll() throws Exception {\n        //加载配置文件\n        InputStream is = Resources.getResourceAsStream(\"SqlMapConfig.xml\");\n        //获取SqlSessionFactory工厂对象\n        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);\n        //获取SqlSe会话对象\n        SqlSession sqlSession = sqlSessionFactory.openSession();\n        //执行sql\n        List<User> list = sqlSession.selectList(\"UserMapper.findAll\");\n        //释放资源\n        sqlSession.close();\n        return list;\n    }\n}\n```\n\n**编写UserMapper.xml**\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE mapper\nPUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n\"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n\n<mapper namespace=\"UserMapper\">\n    <!--查询所有-->\n    <select id=\"findAll\" resultType=\"user\">\n        select * from user\n    </select>\n</mapper>\n```\n\n**测试**\n\n```java\n    @Test\n    public void testFindAll() throws Exception {\n        /* 创建UserMapper 实现类 */\n        UserMapper userMapper = new UserMapperImpl();\n        /* 执行查询 */\n        List<User> list = userMapper.findAll();\n        for (User user : list) {\n            System.out.println(user);\n        }\n    }\n```\n\n**传统方式问题思考**： \n\n1.实现类中，存在mybatis模板代码重复\n\n2.实现类调用方法时，xml中的sql statement 硬编码到java代码中 \n\n思考：能否只写接口，不写实现类。只编写接口和Mapper.xml即可？\n\n因为在dao（mapper）的实现类中对sqlsession的使用方式很类似。因此mybatis提供了接口的动态代理。 \n\n### 代理开发方式 \n\n采用 Mybatis 的基于接口代理方式实现 持久层 的开发，这种方式是我们后面进入企业的主流。 基于接口代理方式的开发只需要程序员编写 Mapper 接口，Mybatis 框架会为我们动态生成实现类的对象。 \n\n这种开发方式要求我们遵循一定的规范：\n\n```xml\n    <mapper namespace=\"UserDao\">\n        <!--查询所有-->\n        <select id=\"findAll\" parameterType=\"int\" resultType=\"user\">\n            select * from user where id=#{id}\n        </select>\n    </mapper>\n```\n\n```java\npublic interface UserDao {\n    User findAll(int id) throws Exception;\n}\n```\n\n- Mapper.xml映射文件中的namespace与mapper接口的全限定名相同 \n\n- Mapper接口方法名和Mapper.xml映射文件中定义的每个statement的id相同 \n\n- Mapper接口方法的输入参数类型和mapper.xml映射文件中定义的每个sql的parameterType的类型相同 \n\n- Mapper接口方法的输出参数类型和mapper.xml映射文件中定义的每个sql的resultType的类型相同 \n\nMapper 接口开发方法只需要程序员编写Mapper 接口（相当于Dao 接口），由Mybatis 框架根据接口 定义创建接口的动态代理对象，代理对象的方法体同上边Dao接口实现类方法。\n\n**编写UserMapper接口**\n\n```java\npublic interface UserMapper {\n    public List<User> findAll() throws Exception;\n}\n```\n\n**编写UserMapper.xml**\n\n```xml\n    <mapper namespace=\"com.aaa.mapper.UserMapper\">\n        <!--查询所有-->\n        <select id=\"findAll\" resultType=\"user\">\n            select * from user\n        </select>\n    </mapper>\n```\n\n**测试**\n\n```java\n    @Test\n    public void testFindAll() throws Exception {\n        //加载核心配置文件\n        InputStream is = Resources.getResourceAsStream(\"SqlMapConfig.xml\");\n        //获得SqlSessionFactory工厂对象\n        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);\n        //获得SqlSession会话对象\n        SqlSession sqlSession = sqlSessionFactory.openSession();\n        //获得Mapper代理对象\n        UserMapper userMapper = sqlSession.getMapper(UserMapper.class);\n        // 执行查询\n        List<User> list = userMapper.findAll();\n        for (User user : list) {\n            System.out.println(user);\n        }\n        //释放资源\n        sqlSession.close();\n    }\n```\n\n## Mybatis高级查询\n\n### ResutlMap属性\n\n**建立对象关系映射**\n\n```\nresultType 如果实体的属性名与表中字段名一致，将查询结果自动封装到实体类中\nResutlMap 如果实体的属性名与表中字段名不一致，可以使用ResutlMap实现手动封装到实体类中\n```\n\n**封装SqlSession**\n\n```java\npublic class GetSqlSession {\n    public SqlSession getSqlSession() throws IOException {\n        /* 加载核心配置文件 */\n        InputStream is = Resources.getResourceAsStream(\"SqlMapConfig.xml\");\n        /* 获取SqlSessionFactory工厂对象 */\n        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);\n        /* 获取SqlSession会话对象 true 自动提交事务 */\n        SqlSession sqlSession = sqlSessionFactory.openSession(true);\n        return sqlSession;\n    }\n}\n```\n\n**编写UserMapper接口**\n\n```java\npublic interface UserMapper {\n    public List<User> findAllResultMap();\n}\n```\n\n**编写UserMapper.xml** \n\n```xml\n<!--实现手动映射封装\nresultMap id=\"userResultMap\" 此标签唯一标识  type=\"user\" 封装后的实体类型  \n<id column=\"uid\" property=\"id\"></id> 表中主键字段封装\ncolumn=\"uid\" 表中的字段名\nproperty=\"id\" user实体的属性名\n<result column=\"NAME\" property=\"username\"></result> 表中普通字段封装\ncolumn=\"NAME\" 表中的字段名\nproperty=\"username\" user实体的属性名\n补充：如果有查询结果有 字段与属性是对应的，可以省略手动封装 【了解】-->\n\t<resultMap id=\"UserResultMap\" type=\"user\">\n        <id column=\"id\" property=\"id\"></id>\n        <result column=\"username\" property=\"username\"></result>\n        <result column=\"s\" property=\"sex\"></result>\n    </resultMap>\n\n    <select id=\"findAllMap\" resultMap=\"UserResultMap\">\n        select id,username,sex as s from user\n    </select>\n```\n\n**代码测试**\n\n```java\n\t@Test\n    public void findAllNap() throws IOException {\n        SqlSession sqlSession = new GetSqlSession().getSqlSession();\n        UserMapper mapper = sqlSession.getMapper(UserMapper.class);\n        for (User user : mapper.findAllMap()) {\n            System.out.println(user);\n        }\n    }\n```\n\n### 多条件查询\n\n**根据id和username查询user表**\n\n**方式一：使用 #{arg0} - #{argn} 或者 #{param1} - #{paramn} 获取参数**\n\nUserMapper接口\n\n```java\npublic interface UserMapper {\n    public List<User> findByIdAndUsername(Integer id, String username);\n} \n```\n\nUserMapper.xml\n\n```xml\n    <select id=\"findByIdAndUsername\" resultType=\"user\">\n        <!-- select * from user where id = #{arg0} and username = #{arg1} -->\n        select * from user where id = #{param1} and username = #{param2}\n    </select>\n```\n\n测试\n\n```java\n    @Test\n    public void testFindByIdAndUsername() throws IOException {\n        SqlSession sqlSession = new GetSqlSession().getSqlSession();\n        UserMapper mapper = sqlSession.getMapper(UserMapper.class);\n        List<User> gy = mapper.findByIdAndUsername(2, \"gy\");\n        for (User user : gy) {\n            System.out.println(user);\n        }\n    }\n```\n\n**方式二：使用注解，引入 @Param() 注解获取参数**\n\nUserMapper接口\n\n```java\npublic interface UserMapper {\n    public List findByIdAndUsername2(\n        @Param(\"id\") Integer id,@Param(\"username\") String username\n    ); \n}\n```\n\nUserMapper.xml \n\n```xml\n    <select id=\"findByIdAndUsername2\" resultType=\"user\">\n        select * from user where id = #{id} and username = #{username}\n    </select>\n```\n\n测试\n\n```java\n    @Test\n    public void testFindByIdAndUsername2() throws IOException {\n        SqlSession sqlSession = new GetSqlSession().getSqlSession();\n        UserMapper mapper = sqlSession.getMapper(UserMapper.class);\n        List<User> gy = mapper.findByIdAndUsername2(2, \"gy\");\n        for (User user : gy) {\n                System.out.println(user);\n        }\n    }\n```\n\n**方式三（推荐）：使用pojo对象传递参数** \n\nUserMapper接口\n\n```java\npublic interface UserMapper {\n    public List<User> findByIdAndUsername3(User user); \n}\n```\n\nUserMapper.xml\n\n```xml\n    <select id=\"findByIdAndUsername3\" parameterType=\"com.aaa.domain.User\" resultType=\"com.aaa.domain.User\">\n        select * from user where id = #{id} and username = #{username}\n    </select>\n```\n\n测试\n\n```java\n    @Test\n    public void testFindByIdAndUsername3() throws IOException {\n        SqlSession sqlSession = new GetSqlSession().getSqlSession();\n        UserMapper mapper = sqlSession.getMapper(UserMapper.class);\n        User param = new User();\n        param.setId(2);\n        param.setUsername(\"gy\");\n        List<User> list = mapper.findByIdAndUsername3(param);\n        System.out.println(list);\n    }\n```\n\n### 模糊查询 \n\n**根据username模糊查询user表** \n\nUserMapper接口 \n\n```java\npublic interface UserMapper { \n\tpublic List<User> findByusername(String username);\n}\n```\n\nUserMapper.xml \n\n```xml\n\t<select id=\"findByusername\" parameterType=\"string\" resultType=\"user\">\n        <!-- select * from user where username like '${value}'\n\t\t\t 不推荐使用，因为会出现sql注入问题\n\t\t-->\n        select * from user where username like #{username}\n    </select>\n```\n\n测试 \n\n```java\n@Test\n    public void testByusername() throws IOException {\n        SqlSession sqlSession = new GetSqlSession().getSqlSession();\n        UserMapper mapper = sqlSession.getMapper(UserMapper.class);\n        for (User user : mapper.findByusername(\"g%\")) {\n            System.out.println(user);\n        }\n    }\n```\n\n ${} 与 #{} 区别【笔试题】\n\n\\#{} :表示一个占位符号  ?\n\n- 通过 #{} 可以实现preparedStatement向占位符中设置值，自动进行java类型和jdbc类型转换，# {}可以有效防止sql注入。 \n\n- \\#{} 可以接收简单类型值或pojo属性值。 \n\n- 如果parameterType传输单个简单类型值， #{} 括号中名称随便写。\n\n${} :表示拼接sql串 \n\n- 通过 ${} 可以将parameterType 传入的内容拼接在sql中且不进行jdbc类型转换，会出现sql注入问题。 \n\n- ${} 可以接收简单类型值或pojo属性值。 \n\n- 如果parameterType传输单个简单类型值， ${} 括号中只能是value。\n\n### 返回主键\n\n向数据库插入一条记录后，希望能立即拿到这条记录在数据库中的主键值。\n\n**方式一 useGeneratedKeys**\n\nUserMapper接口\n\n```java\npublic interface UserMapper {\n    public void save1(User user);\n}\n```\n\nUserMapper.xml\n\n```xml\n    <!--useGeneratedKeys=\"true\" 声明返回主键\n\t\tkeyProperty=\"id\" 把返回主键的值，封装到实体的id属性中\n\t\t注意：只适用于主键自增的数据库，mysql和sqlserver支持，oracle不支持-->\n\t<insert id=\"save1\" parameterType=\"user\" useGeneratedKeys=\"true\" keyProperty=\"id\">\n        insert into user(username,birthday,sex,address) \n        values(#{username},#{birthday},#{sex},#{address})\n    </insert>\n```\n\n测试\n\n```java\n\t@Test\n    public void TestSave1() throws IOException {\n        SqlSession sqlSession = new GetSqlSession().getSqlSession();\n        UserMapper mapper = sqlSession.getMapper(UserMapper.class);\n        User user = new User();\n        user.setUsername(\"zxl\");\n        user.setBirthday(new Date());\n        user.setSex(\"男\");\n        user.setAddress(\"河南郑州\");\n        mapper.save1(user);\n        System.out.println(user.getId());\n        sqlSession.close();\n    }\n```\n\n**方式二 selectKey**\n\nUserMapper接口\n\n```java\npublic interface UserMapper {\n    public void save2(User user);\n}\n```\n\nUserMapper.xml\n\n```xml\n    <!--selectKey 适用范围广，支持所有类型数据库\n\t\tkeyColumn=\"id\" 指定主键列名\n\t\tkeyProperty=\"id\" 指定主键封装到实体的id属性中\n\t\tresultType=\"int\" 指定主键类型\n\t\torder=\"AFTER\" 设置在sql语句执行前（后），执行此语句-->\n\t<insert id=\"save2\" parameterType=\"user\" useGeneratedKeys=\"true\" keyProperty=\"id\">\n        <selectKey keyColumn=\"id\" keyProperty=\"id\" resultType=\"int\" order=\"AFTER\">\n        <!--得到刚 insert 进去记录的主键值，只适用与自增主键-->\n        select LAST_INSERT_ID();\n        </selectKey>\n        insert into user(username,birthday,sex,address)\n        values(#{username},#{birthday},#{sex},#{address})\n    </insert>\n```\n\n测试\n\n```java\n\t@Test\n    public void TestSave1() throws IOException {\n        SqlSession sqlSession = new GetSqlSession().getSqlSession();\n        UserMapper mapper = sqlSession.getMapper(UserMapper.class);\n        User user = new User();\n        user.setUsername(\"zxl\");\n        user.setBirthday(new Date());\n        user.setSex(\"男\");\n        user.setAddress(\"河南郑州\");\n        mapper.save2(user);\n        System.out.println(user.getId());\n        sqlSession.close();\n    }\n```\n\n## 动态SQL\n\n### 动态SQL之 if\n\n根据id和username查询，但是不确定两个都有值,if + where 解决动态的拼接and关键字 and可能造成的语法错误\n\nUserMapper接口\n\n```java\npublic interface UserMapper {\n    public List<User> findByIdAndUsernameIf(User user);\n}\n```\n\nUserMapper.xml映射\n\n```xml\n\t<select id=\"findByIdAndUsernameIf\" parameterType=\"user\" resultType=\"user\">\n        SELECT * FROM user\n\t\t<!--where标签相当于 where 1=1，但是如果没有条件，就不会拼接where关键字-->\n        <where>\n            <if test=\"id != null\">\n                AND id = #{id}\n            </if>\n            <if test=\"username != null\">\n                AND username = #{username}\n            </if>\n        </where>\n    </select>\n```\n\n测试代码\n\n```java\n\t@Test\n    public void testFindByIdAndUsernameIf() throws Exception {\n        SqlSession sqlSession = new GetSqlSession().getSqlSession();\n        UserMapper userMapper = sqlSession.getMapper(UserMapper.class);\n        User param = new User();\n        param.setId(7);\n        param.setUsername(\"zxl\");\n        List<User> list = userMapper.findByIdAndUsernameIf(param);\n        System.out.println(list);\n    }\n```\n\n### 动态SQL之 set\n\nset标签 代替set 关键字，可以再拼接sql语句时，动态拼接 \"，\" 避免拼接语法错误\n\nUserMapper接口\n\n```java\npublic interface UserMapper {\n   \tpublic void updateIf(User user);\n}\n```\n\n```xml\n<!--set标签在更新的时候，自动加上set关键字，然后去掉最后一个条件的逗号-->\n\t<update id=\"updateIf\" parameterType=\"user\">\n        UPDATE user\n        <set>\n            <if test=\"username != null\">\n                username = #{username},\n            </if>\n            <if test=\"birthday != null\">\n                birthday = #{birthday},\n            </if>\n            <if test=\"sex !=null\">\n                sex = #{sex},\n            </if>\n            <if test=\"address !=null\">\n                address = #{address},\n            </if>\n        </set>\n        WHERE id = #{id}\n    </update>\n```\n\n测试代码\n\n```java\n\t@Test\n    public void testUpdateIf()throws Exception{\n        SqlSession sqlSession = new GetSqlSession().getSqlSession();\n        UserMapper userMapper = sqlSession.getMapper(UserMapper.class);\n        User user = new User();\n        user.setId(1);\n        user.setUsername(\"小寒\");\n        user.setSex(\"女\");\n        userMapper.updateIf(user);\n    }\n```\n\n### 动态SQL之 foreach\n\nforeach主要是用来做数据的循环遍历\n\n例如：select * from user where id in (1,2,3) 在这样的语句中, 传入的参数部分必须依靠 foreach遍历才能实现。\n\n**foreach标签用于遍历集合，它的属性**\n\n- collection：代表要遍历的集合元素\n- open：代表语句的开始部分\n- close：代表结束部分\n- item：代表遍历集合的每个元素，生成的变量名\n- sperator：代表分隔符\n\n集合 UserMapper接口 \n\n```java\npublic interface UserMapper {\n   \tpublic List<User> findByList(List<Integer> ids)\n}\n```\n\nUserMaper.xml映射 \n\n```xml\n<!--如果查询条件为普通类型 List集合，collection属性值为：collection 或者 list-->\n\t<select id=\"findByList\" parameterType=\"list\" resultType=\"user\" >\n        SELECT * FROM user\n        <where>\n            <foreach collection=\"collection\" open=\"id in(\" close=\")\" item=\"id\"\n                     separator=\",\">\n                #{id}\n            </foreach>\n        </where>\n    </select>\n```\n\n测试代码\n\n```java\n\t@Test\n    public void testFindByList() throws Exception {\n        SqlSession sqlSession = new GetSqlSession().getSqlSession();\n        UserMapper userMapper = sqlSession.getMapper(UserMapper.class);\n        List<Integer> ids = new ArrayList<>();\n        ids.add(1);\n        ids.add(2);\n        ids.add(3);\n        List<User> list = userMapper.findByList(ids);\n        System.out.println(list);\n    }\n```\n\n数组 UserMapper接口\n\n```java\npublic interface UserMapper {\n   \tpublic List<User> findByArray(Integer[] ids);\n}\n```\n\nUserMaper.xml映射\n\n```xml\n<!-- 如果查询条件为普通类型 Array数组，collection属性值为：array-->\n\t<select id=\"findByArray\" parameterType=\"int\" resultType=\"user\" >\n        SELECT * FROM user\n        <where>\n            <foreach collection=\"array\" open=\"id in(\" close=\")\" item=\"id\"\n                     separator=\",\">\n                #{id}\n            </foreach>\n        </where>\n    </select>\n```\n\n测试代码\n\n```java\n    @Test\n    public void testFindByArray() throws Exception {\n      SqlSession sqlSession = new GetSqlSession().getSqlSession();\n      UserMapper userMapper = sqlSession.getMapper(UserMapper.class);\n      Integer[] ids = {1, 2, 3};\n      List<User> list = userMapper.findByArray(ids);\n      System.out.println(list);\n    }\n```\n\n### SQL片段\n\n映射文件中可将重复的 sql 提取出来，使用时用 include 引用即可，最终达到 sql 重用的目的\n\n```xml\n    <!--抽取的sql片段-->\n    <sql id=\"selectUser\">\n        SELECT * FROM user\n    </sql>\n    <select id=\"findByList\" parameterType=\"list\" resultType=\"user\" >\n        <!--引入sql片段-->\n        <include refid=\"selectUser\"></include>\n        <where>\n            <foreach collection=\"collection\" open=\"id in(\" close=\")\" item=\"id\"    separator=\",\">\n                #{id}\n            </foreach>\n        </where>\n    </select>\n```\n\n## Mybatis多表查询\n\n**案例环境准备**\n\n```sql\nDROP TABLE IF EXISTS `orders`;\nCREATE TABLE `orders` (\n                          `id` INT(11) NOT NULL AUTO_INCREMENT,\n                          `ordertime` VARCHAR(255) DEFAULT NULL,\n                          `total` DOUBLE DEFAULT NULL,\n                          `uid` INT(11) DEFAULT NULL,\n                          PRIMARY KEY (`id`),\n                          KEY `uid` (`uid`),\n                          CONSTRAINT `orders_ibfk_1` FOREIGN KEY (`uid`) REFERENCES `user` (`id`)\n) ENGINE=INNODB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8;\n\nINSERT INTO `orders` VALUES ('1', '2020-12-12', '3000', '1');\nINSERT INTO `orders` VALUES ('2', '2020-12-12', '4000', '1');\nINSERT INTO `orders` VALUES ('3', '2020-12-12', '5000', '2');\n\nDROP TABLE IF EXISTS `role`;\nCREATE TABLE `role` (\n                        `id` INT(11) NOT NULL AUTO_INCREMENT,\n                        `rolename` VARCHAR(255) DEFAULT NULL,\n                        `roleDesc` VARCHAR(255) DEFAULT NULL,\n                        PRIMARY KEY (`id`)\n) ENGINE=INNODB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8;\n\nINSERT INTO `role` VALUES ('1', 'CTO', 'CTO');\nINSERT INTO `role` VALUES ('2', 'CEO', 'CEO');\n\nDROP TABLE IF EXISTS `user_role`;\nCREATE TABLE `user_role` (\n                             `userid` INT(11) NOT NULL,\n                             `roleid` INT(11) NOT NULL,\n                             PRIMARY KEY (`userid`,`roleid`),\n                             KEY `roleid` (`roleid`),\n                             CONSTRAINT `user_role_ibfk_1` FOREIGN KEY (`userid`) REFERENCES `user`\n                                 (`id`),\n                             CONSTRAINT `user_role_ibfk_2` FOREIGN KEY (`roleid`) REFERENCES `role`(`id`)\n) ENGINE=INNODB DEFAULT CHARSET=utf8;\n\nINSERT INTO `user_role` VALUES ('1', '1');\nINSERT INTO `user_role` VALUES ('2', '1');\nINSERT INTO `user_role` VALUES ('1', '2');\nINSERT INTO `user_role` VALUES ('2', '2');\n```\n\n###  一对一（多对一） \n\n**一对一查询模型**\n\n用户表和订单表的关系为，一个用户有多个订单，一个订单只从属于一个用户\n\n一对一查询的需求：查询所有订单，与此同时查询出每个订单所属的用户 \n\n一对一查询语句 ：\n\n```sql\nSELECT * FROM orders o LEFT JOIN user u ON o.uid=u.id;\n```\n\nOrder实体\n\n```java\n@Data\n@ToString\npublic class Orders {\n    private int id;\n    private Date ordertime;\n    private double total;\n    private User user;\n}\n```\n\nOrderMapper接口\n\n```java\npublic interface OrdersMapper {\n    public List<Orders> findAllWithUser();\n}\n```\n\nOrderMapper.xml映射\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE mapper\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n<mapper namespace=\"com.example.mapper.OrdersMapper\">\n    <resultMap id=\"OrdersMap\" type=\"Orders\">\n        <id column=\"id\" property=\"id\"></id>\n        <result column=\"ordertime\" property=\"ordertime\"></result>\n        <result column=\"total\" property=\"total\"></result>\n        <!--一对一（多对一）使用association标签关联  \n\t\t\tproperty=\"user\" 封装实体的属性名  \n\t\t\tjavaType=\"user\" 封装实体的属性类型  -->\n        <association property=\"user\" javaType=\"User\">\n            <id column=\"id\" property=\"id\"></id>\n            <result column=\"username\" property=\"username\"></result>\n            <result column=\"birthday\" property=\"birthday\"></result>\n            <result column=\"sex\" property=\"sex\"></result>\n            <result column=\"address\" property=\"address\"></result>\n        </association>\n\n    </resultMap>\n\n    <select id=\"findAllWithUser\" resultMap=\"OrdersMap\">\n        SELECT * FROM orders o LEFT JOIN USER u ON o.uid = u.id\n    </select>\n</mapper>\n```\n\n配置映射 在sqlMapconfig.xml中\n\n```xml\n<!--加载映射配置-->\n    <mappers>\n<!--        <mapper resource=\"com/example/mapper/UserMapper.xml\"></mapper>-->\n<!--        <mapper resource=\"com/example/mapper/OedersMapper.xml\"></mapper>-->\n        <!--批量加载映射-->\n        <package name=\"com.example.mapper\"/>\n    </mappers>\n```\n\n测试代码\n\n```java\n\t@Test\n    public void testOrderWithUser() throws Exception {\n        SqlSession sqlSession = new GetSqlSession().getSqlSession();\n        OrdersMapper orderMapper = sqlSession.getMapper(OrdersMapper.class);\n        List<Orders> list = orderMapper.findAllWithUser();\n        for (Orders order : list) {\n            System.out.println(order);\n        }\n    }\n```\n\n### 一对多\n\n一对多查询语句\n\n```sql\nSELECT *,o.id oid FROM user u LEFT JOIN orders o ON u.id = o.uid;\n```\n\nUser实体\n\n```java\n@Data\n@ToString\npublic class User {\n    private Integer id;\n    private String username;\n    private Date birthday;\n    private String sex;\n    private String address;\n    // 代表当前用户具备的订单列表\n    private List<Orders> orderList;\n}\n```\n\nUserMapper接口\n\n```java\npublic interface UserMapper {\n    public List<User> findAllWithOrder();\n}\n```\n\nUserMapper.xml映射\n\n```xml\n<resultMap id=\"userMap\" type=\"User\">\n        <id column=\"id\" property=\"id\"></id>\n        <result column=\"username\" property=\"username\"></result>\n        <result column=\"birthday\" property=\"birthday\"></result>\n        <result column=\"sex\" property=\"sex\"></result>\n        <result column=\"address\" property=\"address\"></result>\n        <!--\n        一对多使用collection标签关联\n        property=\"orderList\" 封装到集合的属性名\n        ofType=\"order\" 封装集合的泛型类型\n        -->\n        <collection property=\"orderList\" ofType=\"Orders\">\n            <id column=\"oid\" property=\"id\"></id>\n            <result column=\"ordertime\" property=\"ordertime\"></result>\n            <result column=\"total\" property=\"total\"></result>\n        </collection>\n    </resultMap>\n    <select id=\"findAllWithOrder\" resultMap=\"userMap\">\n        SELECT *,o.id oid FROM USER u LEFT JOIN orders o ON u.`id` = o.`uid`;\n    </select>\n```\n\n测试代码\n\n```java\n\t@Test\n    public void testUserWithOrder() throws Exception {\n        SqlSession sqlSession = new GetSqlSession().getSqlSession();\n        UserMapper userMapper = sqlSession.getMapper(UserMapper.class);\n        List<User> list = userMapper.findAllWithOrder();\n        for (User user : list) {\n            System.out.println(user);\n        }\n    }\n```\n\n### 多对多\n\n多对多查询的模型 用户表和角色表的关系为，一个用户有多个角色，一个角色被多个用户使用 多对多查询的需求：查询所有用户同时查询出该用户的所有角色 \n\n多对多查询语句\n\n```sql\nSELECT * FROM user u -- 用户表\nLEFT JOIN user_role ur -- 左外连接中间表\nON u.id = ur.userid\nLEFT JOIN role r -- 左外连接中间表\nON ur.roleid = r.id;\n```\n\nUser和Role 实体\n\n```java\n@Data\n@ToString\npublic class User {\n    private Integer id;\n    private String username;\n    private Date birthday;\n    private String sex;\n    private String address;\n    // 代表当前用户关联的角色列表\n    private List<Role> roleList;\n}\n```\n\n```java\n@Data\n@ToString\npublic class Role {\n    private Integer id;\n    private String roleName;\n    private String roleDesc;\n}\n```\n\nUserMapper接口\n\n```java\npublic interface UserMapper {\n\tpublic List<User> findAllWithRole();\n}\n```\n\nUserMapper.xml映射\n\n```xml\n\t<resultMap id=\"userAndRoleMap\" type=\"com.example.demo2.entity.User\">\n        <id column=\"id\" property=\"id\"></id>\n        <result column=\"username\" property=\"username\"></result>\n        <result column=\"birthday\" property=\"birthday\"></result>\n        <result column=\"sex\" property=\"sex\"></result>\n        <result column=\"address\" property=\"address\"></result>\n\n        <collection property=\"roleList\" ofType=\"com.example.demo2.entity.Role\">\n            <id column=\"id\" property=\"id\"></id>\n            <result column=\"roleName\" property=\"roleName\"></result>\n            <result column=\"roleDesc\" property=\"roleDesc\"></result>\n        </collection>\n    </resultMap>\n\n    <select id=\"findAllWithRole\" resultMap=\"userAndRoleMap\">\n        SELECT * FROM user u\n            LEFT JOIN user_role ur\n            ON u.id = ur.userid\n            LEFT JOIN role r\n            ON ur.roleid = r.id;\n    </select>\n```\n\n测试代码\n\n```java\n\t@Test\n    public void testUserWithRole() throws Exception {\n        SqlSession sqlSession = new GetSqlSession().getSqlSession();\n        UserMapper userMapper = sqlSession.getMapper(UserMapper.class);\n        List<User> list = userMapper.findAllWithRole();\n        for (User user : list) {\n            System.out.println(user);\n        }\n    }\n```\n\n## 日志配置\n\npom.xml\n\n```xml\n\t\t<!-- 添加slf4j日志api -->\n        <dependency>\n            <groupId>org.slf4j</groupId>\n            <artifactId>slf4j-api</artifactId>\n            <version>1.7.20</version>\n        </dependency>\n        <!-- 添加logback-classic依赖 -->\n        <dependency>\n            <groupId>ch.qos.logback</groupId>\n            <artifactId>logback-classic</artifactId>\n            <version>1.2.3</version>\n        </dependency>\n        <!-- 添加logback-core依赖 -->\n        <dependency>\n            <groupId>ch.qos.logback</groupId>\n            <artifactId>logback-core</artifactId>\n            <version>1.2.3</version>\n        </dependency>\n\n        <dependency>\n            <groupId>ch.qos.logback</groupId>\n            <artifactId>logback-access</artifactId>\n            <version>1.2.3</version>\n        </dependency>\n        <dependency>\n            <groupId>org.logback-extensions</groupId>\n            <artifactId>logback-ext-spring</artifactId>\n            <version>0.1.4</version>\n        </dependency>\n```\n\nresource 下新建 logback.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<configuration>\n    <!--CONSOLE ：表示当前的日志信息是可以输出到控制台的。-->\n    <appender name=\"Console\" class=\"ch.qos.logback.core.ConsoleAppender\">\n        <encoder>\n            <pattern>[%level]  %cyan([%thread]) %boldGreen(%logger{15}) - %msg %n</pattern>\n        </encoder>\n    </appender>\n    <logger name=\"com.aaa\" level=\"DEBUG\" additivity=\"false\">\n        <appender-ref ref=\"Console\"/>\n    </logger>\n\n    <!--level:用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF默认debug-->\n    <root level=\"DEBUG\">\n        <appender-ref ref=\"Console\"/>\n    </root>\n</configuration>\n```\n\nweb.xml\n\n```xml\n\t<!-- logback -->\n    <context-param>\n        <param-name>logbackConfigLocation</param-name>\n        <!--logback.xml放在resources路径下-->\n        <param-value>classpath:logback.xml</param-value>\n    </context-param>\n\t<!-- logback自带监听器加载配置文件-->\n\t<listener>\n    <listener-class>ch.qos.logback.ext.spring.web.LogbackConfigListener</listener-class>\n \t</listener>\n```\n\n## MyBatis嵌套查询\n\n嵌套查询就是将原来多表查询中的联合查询语句拆成单个表的查询，再使用mybatis的语法嵌套在一 起\n\n优点：简化多表查询操作 缺点：执行多次sql语句，浪费数据库性能\n\n### 一对一嵌套查询\n\n需求：查询一个订单，与此同时查询出该订单所属的用户\n\n```sql\nSELECT * FROM orders o LEFT JOIN user u ON o.uid = u.id;\n```\n\n一对一查询语句 \n\n```sql\n-- 先查询订单\nSELECT * FROM orders;\n-- 再根据订单uid外键，查询用户\nSELECT * FROM user WHERE id = #{订单的uid};\n```\n\n**代码实现** \n\nOrderMapper接口\n\n```java\npublic interface OrdersMapper {\n\t public List<Orders> findAllUser();\n}\n```\n\nOrderMapper.xml映射\n\n```xml\n\t<!--一对一嵌套查询-->\n    <resultMap id=\"orderMap\" type=\"orders\">\n        <id column=\"id\" property=\"id\"></id>\n        <result column=\"ordertime\" property=\"ordertime\"></result>\n        <result column=\"total\" property=\"total\"></result>\n        <!--根据订单中uid外键，查询用户表-->\n        <association property=\"user\" javaType=\"user\" column=\"uid\"\n                     select=\"com.example.mapper.UserMapper.findById\"></association>\n    </resultMap>\n    <select id=\"findAllUser\" resultMap=\"orderMap\" >\n        SELECT * FROM orders\n    </select>\n```\n\nUserMapper接口\n\n```java\npublic interface UserMapper {\n    public User findById(Integer id);\n}\n```\n\nUserMapper.xml映射\n\n```xml\n\t<select id=\"findById\" parameterType=\"int\" resultType=\"user\">\n        SELECT * FROM `user` where id = #{uid}\n    </select>\n```\n\n测试代码\n\n```java\n \t@Test\n    public void testOrderWithAllUser() throws Exception {\n        SqlSession sqlSession = new GetSqlSession().getSqlSession();\n        OrdersMapper orderMapper = sqlSession.getMapper(OrdersMapper.class);\n        List<Orders> list = orderMapper.findAllUser();\n        for (Orders order : list) {\n            System.out.println(order);\n        }\n    }\n```\n\n### 一对多嵌套查询\n\n需求：查询所有用户，与此同时查询出该用户具有的订单\n\n一对多查询语句\n\n```sql\n-- 先查询用户\nSELECT * FROM `user`;\n-- 再根据用户id主键，查询订单列表\nSELECT * FROM orders where uid = #{用户id};\n```\n\n**代码实现** \n\nUserMapper接口\n\n```java\npublic interface UserMapper {\n\tpublic List<User> findAllWith();\n}\n```\n\nUserMapper.xml映射\n\n```xml\n\t<!--一对多嵌套查询-->\n    <resultMap id=\"userAllMap\" type=\"user\">\n        <id column=\"id\" property=\"id\"></id>\n        <result column=\"username\" property=\"username\"></result>\n        <result column=\"birthday\" property=\"birthday\"></result>\n        <result column=\"sex\" property=\"sex\"></result>\n        <result column=\"address\" property=\"address\"></result>\n        <!--根据用户id，查询订单表-->\n        <collection property=\"orderList\" column=\"id\" ofType=\"orders\"\n                    select=\"com.example.mapper.OrdersMapper.findByUid\"></collection>\n    </resultMap>\n    <select id=\"findAllWith\" resultMap=\"userAllMap\">\n        SELECT * FROM `user`\n    </select>\n```\n\nOrderMapper接口\n\n```java\npublic interface OrdersMapper { \n\tpublic List<Orders> findByUid(Integer uid);\n}\n```\n\nOrderMapper.xml映射\n\n```xml\n\t<select id=\"findByUid\" parameterType=\"int\" resultType=\"orders\">\n        SELECT * FROM orders where uid = #{uid}\n    </select>\n```\n\n测试代码\n\n```java\n\t@Test\n    public void testUserWithAllOrder() throws Exception {\n        SqlSession sqlSession = new GetSqlSession().getSqlSession();\n        UserMapper userMapper = sqlSession.getMapper(UserMapper.class);\n        List<User> list = userMapper.findAllWith();\n        for (User user : list) {\n            System.out.println(user);\n        }\n    }\n```\n\n### 多对多嵌套查询\n\n需求：查询用户 同时查询出该用户的所有角色\n\n多对多查询语句\n\n```sql\n-- 先查询用户\nSELECT * FROM `user`;\n-- 再根据用户id主键，查询角色列表\nSELECT * FROM role r INNER JOIN user_role ur \nON r.`id` = ur.`rid` WHERE ur.`uid` = #{用户id};\n```\n\n**代码实现**\n\nUserMapper接口\n\n```java\npublic interface UserMapper { \n\tpublic List<User> findWithRole();\n}\n```\n\nUserMapper.xml映射\n\n```xml\n\t<!--多对多嵌套查询-->\n    <resultMap id=\"userAndRole\" type=\"user\">\n        <id column=\"id\" property=\"id\"></id>\n        <result column=\"username\" property=\"username\"></result>\n        <result column=\"birthday\" property=\"birthday\"></result>\n        <result column=\"sex\" property=\"sex\"></result>\n        <result column=\"adress\" property=\"address\"></result>\n        <!--根据用户id，查询角色列表-->\n        <collection property=\"roleList\" column=\"id\" ofType=\"role\"\n                    select=\"com.example.mapper.RoleMapper.findByUid\"></collection>\n    </resultMap>\n    <select id=\"findWithRole\" resultMap=\"userAndRole\">\n        SELECT * FROM `user`\n    </select>\n```\n\nRoleMapper接口\n\n```java\npublic interface RoleMapper {\n    public List<Role> findByUid(Integer uid);\n}\n```\n\nRoleMapper.xml映射\n\n```xml\n\t<select id=\"findByUid\" parameterType=\"int\" resultType=\"role\">\n        SELECT r.id,r.rolename roleName,r.roleDesc roleDesc FROM role r\n        INNER JOIN user_role ur ON r.id = ur.roleid WHERE ur.userid = #{uid}\n    </select>\n```\n\n测试代码\n\n```java\n\t@Test\n    public void testUserRole() throws Exception {\n        SqlSession sqlSession = new GetSqlSession().getSqlSession();\n        UserMapper userMapper = sqlSession.getMapper(UserMapper.class);\n        List<User> list = userMapper.findWithRole();\n        for (User user : list) {\n            System.out.println(user);\n        }\n    }\n```\n\n## MyBatis加载策略\n\n**什么是延迟加载** \n\n问题 通过前面的学习，我们已经掌握了Mybatis中一对一，一对多，多对多关系的配置及实现，可以实现 对象的关联查询。实际开发过程中很多时候我们并不需要总是在加载用户信息时就一定要加载他的订单 信息。此时就是我们所说的延迟加载。\n\n**延迟加载**\n\n就是在需要用到数据时才进行加载，不需要用到数据时就不加载数据。延迟加载也称懒加载。\n\n优点： 先从单表查询，需要时再从关联表去关联查询，大大提高数据库性能，因为查询单表要比关联查询多张表 速度要快。 \n\n缺点： 因为只有当需要用到数据时，才会进行数据库查询，这样在大批量数据查询时，因为查询工作也要消耗时 间，所以可能造成用户等待时间变长，造成用户体验下降。 \n\n在多表中： 一对多，多对多：通常情况下采用延迟加载，一对一（多对一）：通常情况下采用立即加载 \n\n注意： 延迟加载是基于嵌套查询来实现的\n\n### 局部延迟加载\n\n在association和collection标签中都有一个fetchType属性，通过修改它的值，可以修改局部的加载策略。\n\n```xml\n\t<!-- 开启一对多 延迟加载 -->\n    <resultMap id=\"userMap\" type=\"user\">\n        <id column=\"id\" property=\"id\"></id>\n        <result column=\"username\" property=\"username\"></result>\n        <result column=\"password\" property=\"password\"></result>\n        <result column=\"birthday\" property=\"birthday\"></result>\n        <!--\n        fetchType=\"lazy\" 懒加载策略\n        fetchType=\"eager\" 立即加载策略\n        -->\n        <collection property=\"orderList\" ofType=\"orders\" column=\"id\"\n                    select=\"com.aaa.dao.OrderMapper.findByUid\" fetchType=\"lazy\">\n        </collection>\n    </resultMap>\n    <select id=\"findAll\" resultMap=\"userMap\">\n        SELECT * FROM `user`\n    </select>\n```\n\n### 设置触发延迟加载的方法\n\n大家在配置了延迟加载策略后，发现即使没有调用关联对象的任何方法，但是在你调用当前对象的 equals、clone、hashCode、toString方法时也会触发关联对象的查询。\n\n我们可以在配置文件 sqlMapConfig.xml 中使用lazyLoadTriggerMethods配置项覆盖掉上面四个方法。\n\n```xml\n<settings>\n    <!--所有方法都会延迟加载-->\n    <setting name=\"lazyLoadTriggerMethods\" value=\"toString()\"/>\n</settings>\n```\n\n全局延迟加载\n\n```xml\n<settings>\n    <!--开启全局延迟加载功能-->\n    <setting name=\"lazyLoadingEnabled\" value=\"true\"/>\n</settings>\n```\n\n**注意: 局部的加载策略优先级高于全局的加载策略。**\n\n## MyBatis缓存\n\n**为什么使用缓存**\n\n当用户频繁查询某些固定的数据时,第一次将这些数据从数据库中查询出来,保存在缓存中。当用户再 次查询这些数据时,不用再通过数据库查询,而是去缓存里面查询。减少网络连接和数据库查询带来的损耗,从而提高我们的查询效率,减少高并发访问带来的系统性能问题。一句话概括：经常查询一些不经常发生变化的数据，使用缓存来提高查询效率。 像大多数的持久化框架一样，Mybatis也提供了缓存策略，通过缓存策略来减少数据库的查询次数， 从而提高性能。 Mybatis中缓存分为一级缓存，二级缓存。\n\n### 一级缓存\n\n一级缓存是SqlSession级别的缓存，是默认开启的，所以在参数和SQL完全一样的情况下，我们使用同一个SqlSession对象调用一个Mapper方法，往往只执行一次SQL，因为使用SelSession第一次查询后，MyBatis会将其放在缓存中，以后再查询的时候，如果没有声明需要刷新，并且缓存没有超时的情况下，SqlSession都会取出当前缓存的数据，而不会再次发送SQL到数据库。\n\n**验证**\n\n```java\n\t@Test\n    public void testOneCache() throws Exception {\n        SqlSession sqlSession = new GetSqlSession().getSqlSession();\n        UserMapper userMapper = sqlSession.getMapper(UserMapper.class);\n        User user1 = userMapper.findById(1);\n        System.out.println(\"第一次查询的用户：\" + user1);\n        System.out.println(\"----------------------------\");\n        User user2 = userMapper.findById(1);\n        System.out.println(\"第二次查询的用户：\" + user2);\n        sqlSession.close();\n    }\n```\n\n我们可以发现，虽然在上面的代码中我们查询了两次，但最后只执行了一次数据库操作，这就是 Mybatis提供给我们的一级缓存在起作用了。因为一级缓存的存在，导致第二次查询id为1的记录时，并没有发出sql语句从数据库中查询数据，而是从一级缓存中查询。 \n\n**分析** \n\n 一级缓存是SqlSession范围的缓存，执行SqlSession的C（增加）U（更新）D（删除）操作，或者调 用clearCache()、commit()、close()方法，都会清空缓存。\n\n这样做的目的为了让缓存中存储的是最新的信息，避免脏读。\n\n**清除缓存**\n\n```java\n\t@Test\n    public void testOneCache() throws Exception {\n        SqlSession sqlSession = new GetSqlSession().getSqlSession();\n        UserMapper userMapper = sqlSession.getMapper(UserMapper.class);\n        User user1 = userMapper.findById(1);\n        System.out.println(\"第一次查询的用户：\" + user1);\n        System.out.println(\"----------------------------\");\n        //调用sqlSession清除缓存 方法一\n        sqlSession.clearCache();\n        User user2 = userMapper.findById(1);\n        System.out.println(\"第二次查询的用户：\" + user2);\n        sqlSession.close();\n    }\n```\n\n```xml\n<!-- 每次查询时，都会清除缓存 方法二 -->\n<select id=\"id\" parameterType=\"x\" resultType=\"x\" flushCache=\"true\" useCache=\"false\"></select>\n```\n\n**当为select语句时：**\nflushCache默认为false，表示任何时候语句被调用，都不会去清空本地缓存和二级缓存。\nuseCache默认为true，表示会将本条语句的结果进行二级缓存。\n**当为insert、update、delete语句时：**\n\nflushCache默认为true，表示任何时候语句被调用，都会导致本地缓存和二级缓存被清空。\n\nuseCache属性在该情况下没有。\n\n当为select语句的时候，如果没有去配置flushCache、useCache，那么默认是启用缓存的，所以，如果有必要，那么就需要人工修改配置，\n\nupdate 的时候如果 flushCache=\"false\"，则当你更新后，查询的数据数据还是老的数据。\n\n### 二级缓存\n\n二级缓存是namspace级别（跨sqlSession）的缓存，是默认不开启的\n\n二级缓存的开启需要进行配置，实现二级缓存的时候，MyBatis要求返回的POJO必须是可序列化的。 也就是要求实现Serializable接口，配置方法很简单，只需要在映射XML文件配置  就可以开启 二级缓存了。\n\n**验证**\n\n```java\n\t@Test\n    public void testOneCacheall() throws Exception {\n        SqlSession sqlSession1 = MyBatisUtil.getSqlSession();\n        UserMapper userMapper1 = sqlSession1.getMapper(UserMapper.class);\n        User user1 = userMapper1.findById(1);\n        System.out.println(\"第一次查询的用户：\" + user1);\n        sqlSession1.close();\n        System.out.println(\"----------------------------\");\n        //sqlSession1 和sqlSession2 缓存不共享 独立缓存区\n        SqlSession sqlSession2 = MyBatisUtil.getSqlSession();\n        UserMapper userMapper2 = sqlSession2.getMapper(UserMapper.class);\n        User user2 = userMapper2.findById(1);\n        System.out.println(\"第二次查询的用户：\" + user2);\n        sqlSession2.close();\n    }\n```\n\n**配置核心配置文件**\n\n```xml\n\t<settings>\n        <!--开启二级缓存-->\n        <setting name=\"cacheEnabled\" value=\"true\"/>\n    </settings>\n```\n\n配置UserMapper.xml映射 \n\n```xml\n    <!--当前映射文件开启二级缓存-->\n    <cache></cache>\n    <!--\n    <select>标签中设置useCache=”true”代表当前这个statement要使用二级缓存。\n    如果不使用二级缓存可以设置为false\n    注意：针对每次查询都需要最新的数据sql，要设置成useCache=\"false\"，禁用二级缓存。-->\n\t<select id=\"findById\" parameterType=\"int\" resultType=\"user\" useCache=\"true\">\n        SELECT * FROM `user` where id = #{id}\n    </select>\n```\n\nMyBatisUtil\n\n```java\npublic class MyBatisUtil {\n    \n    static SqlSessionFactory sqlSessionFactory;\n\n    static {\n        /* 加载核心配置文件 */\n        InputStream is = null;\n        try {\n            is = Resources.getResourceAsStream(\"SqlMapConfig.xml\");\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n        /* 获取SqlSessionFactory工厂对象 */\n        sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);\n    }\n\n    public static SqlSession getSqlSession() throws IOException {\n        /* 获取SqlSession会话对象 true 自动提交事务 */\n        SqlSession sqlSession = sqlSessionFactory.openSession(true);\n        return sqlSession;\n    }\n}\n```\n\n修改User实体\n\n```java\npublic class User implements Serializable {\n    \n}\n```\n\n测试\n\n```java\n\t@Test\n    public void testOneCacheall() throws Exception {\n        SqlSession sqlSession1 = MyBatisUtil.getSqlSession();\n        UserMapper userMapper1 = sqlSession1.getMapper(UserMapper.class);\n        User user1 = userMapper1.findById(1);\n        System.out.println(\"第一次查询的用户：\" + user1);\n        sqlSession1.close();\n        System.out.println(\"----------------------------\");\n        SqlSession sqlSession2 = MyBatisUtil.getSqlSession();\n        UserMapper userMapper2 = sqlSession2.getMapper(UserMapper.class);\n        User user2 = userMapper2.findById(1);\n        System.out.println(\"第二次查询的用户：\" + user2);\n        sqlSession2.close();\n    }\n```\n\n**分析**\n\n二级缓存是mapper映射级别的缓存，多个SqlSession去操作同一个Mapper映射的sql语句，多个 SqlSession可以共用二级缓存，二级缓存是跨SqlSession的。\n\n映射语句文件中的所有select语句将会被缓存。 \n\n映射语句文件中的所有insert、update和delete语句会刷新缓存。\n\n**注意问题（脏读）** \n\nmybatis的二级缓存因为是namespace级别，所以在进行多表查询时会产生脏读问题\n\n**小结** \n\nmybatis的缓存，都不需要我们手动存储和获取数据。mybatis自动维护的。 \n\nmybatis开启了二级缓存后，那么查询顺序：二级缓存-->一级缓存-->数据库 \n\n注意：mybatis的二级缓存会存在脏读问题，需要使用第三方的缓存技术解决问题。\n\n## MyBatis注解\n\n### MyBatis常用注解\n\n这几年来注解开发越来越流行，Mybatis也可以使用注解开发方式，这样我们就可以减少编写 Mapper映射文件了。我们先围绕一些基本的CRUD来学习，再学习复杂映射多表操作\n\n```xml\n@Insert：实现新增，代替了<insert></insert>\n@Delete：实现删除，代替了<delete></delete>\n@Update：实现更新，代替了<update></update>\n@Select：实现查询，代替了<select></select>\n@Result：实现结果集封装，代替了<result></result>\n@Results：可以与@Result 一起使用，封装多个结果集，代替了<resultMap></resultMap>\n@One：实现一对一结果集封装，代替了<association></association>\n@Many：实现一对多结果集封装，代替了<collection></collection>\n```\n\n### MyBatis注解的增删改查\n\n创建UserMapper接口\n\n```java\npublic interface UserMapper {\n   \t@Select(\"SELECT * FROM `user`\")\n    public List<User> findAll();\n    @Insert(\"INSERT INTO user(username,birthday,sex,address)VALUES(#{username},#{birthday},#{sex},#{address})\")\n            public void save(User user);\n    @Update(\"UPDATE `user` SET username = #{username},birthday = #{birthday},sex = #{sex},address = #{address} WHERE id = #{id}\")\n            public void update(User user);\n    @Delete(\"DELETE FROM `user` where id = #{id}\")\n    public void delete(Integer id);\n}\n```\n\n编写核心配置文件 sqlMapConfig.xml\n\n```xml\n\t<!--我们使用了注解替代的映射文件，所以我们只需要加载使用了注解的Mapper接口即可-->\n        <mappers>\n            <!--扫描使用注解的Mapper类-->\n            <mapper class=\"com.aaa.mapper.UserMapper\"></mapper>\n        </mappers>\n```\n\n```xml\n\t<!--或者指定扫描包含映射关系的接口所在的包也可以-->\n        <mappers>\n            <!--扫描使用注解的Mapper类所在的包-->\n            <package name=\"com.aaa.mapper\"></package>\n        </mappers>\n```\n\n测试代码\n\n```java\n\t//查询\n    @Test\n    public void testFindAll() throws Exception {\n        SqlSession sqlSession = MyBatisUtil.getSqlSession();\n        UserMapper userMapper = sqlSession.getMapper(UserMapper.class);\n        List<User> list = userMapper.findAll();\n        for (User user : list) {\n            System.out.println(user);\n        }\n    }\n\t//添加\n    @Test\n    public void testSave() throws Exception {\n        SqlSession sqlSession = MyBatisUtil.getSqlSession();\n        UserMapper userMapper = sqlSession.getMapper(UserMapper.class);\n        User user = new User();\n        user.setUsername(\"于谦\");\n        user.setBirthday(new Date());\n        user.setSex(\"男\");\n        user.setAddress(\"德云社\");\n        userMapper.save(user);\n    }\n    //更新\n    @Test\n    public void testUpdate() throws Exception {\n        SqlSession sqlSession = MyBatisUtil.getSqlSession();\n        UserMapper userMapper = sqlSession.getMapper(UserMapper.class);\n        User user = new User();\n        user.setId(14);\n        user.setUsername(\"郭德纲\");\n        user.setBirthday(new Date());\n        user.setSex(\"男\");\n        user.setAddress(\"德云社\");\n        userMapper.update(user);\n    }\n    //删除\n    @Test\n    public void testDelete() throws Exception {\n        SqlSession sqlSession = MyBatisUtil.getSqlSession();\n        UserMapper userMapper = sqlSession.getMapper(UserMapper.class);\n        userMapper.delete(4);\n    }\n```\n\n### 使用注解实现复杂映射开发\n\n之前我们在映射文件中通过配置 resultMap、association、collection 来实现复杂关系映射。\n\n使用注解开发后，我们可以使用 @Results、@Result，@One、@Many 注解组合完成复杂关系的配置。\n\n![](https://image.aobayu.cn/images/Results.jpg)\n\n![](https://image.aobayu.cn/images/OneMany.jpg)\n\n### 一对一查询\n\n需求：查询一个订单，与此同时查询出该订单所属的用户\n\n一对一查询语句：\n\nSELECT * FROM orders;\n\nSELECT * FROM user WHERE id = #{订单的uid};\n\n**代码实现**\n\nOrderMapper1接口\n\n```java\npublic interface OrderMapper1 {\n    @Select(\"select * from orders\")\n    @Results({\n            @Result(id = true,column = \"id\",property = \"id\"),\n            @Result(column = \"ordertime\",property = \"ordertime\"),\n            @Result(column = \"total\",property = \"total\"),\n            @Result(property = \"user\",javaType = User.class,column = \"uid\",one = @One(\n                    select =\"com.example.mapper.UserMapper1.findById\",fetchType = FetchType.EAGER))\n    })\n    public List<Orders> findAllWithUser();\n}\n```\n\nUserMapper1接口\n\n```java\npublic interface UserMapper1 {\n\t@Select(\"SELECT * FROM `user` WHERE id = #{id}\")\n    public User findById(Integer id);\n}\n```\n\nsqlMapConfig.xml 配置\n\n```xml\n\t<mappers>\n        <!--扫描使用注解的Mapper类-->\n        <mapper class=\"com.example.mapper.UserMapper1\"></mapper>\n        <mapper class=\"com.example.mapper.OrderMapper1\"></mapper>\n    </mappers>\n```\n\n测试代码\n\n```java\n\t@Test\n    public void testOrderWithUser1() throws Exception {\n        SqlSession sqlSession = MyBatisUtil.getSqlSession();\n        OrderMapper1 orderMapper = sqlSession.getMapper(OrderMapper1.class);\n        List<Orders> list = orderMapper.findAllWithUser();\n        for (Orders order : list) {\n            System.out.println(orders);\n        }\n    }\n```\n\n### 一对多查询\n\n需求：查询一个用户，与此同时查询出该用户具有的订单\n\n一对多查询语句：\n\nSELECT * FROM user;\n\nSELECT * FROM orders where uid = #{用户id};\n\n**代码实现**\n\nUserMapper1接口\n\n```java\npublic interface UserMapper1 {\n    @Select(\"select *from user\")\n    @Results({\n            @Result(id = true,column = \"id\",property = \"id\"),\n            @Result(column = \"brithday\",property = \"brithday\"),\n            @Result(column = \"sex\",property = \"sex\"),\n            @Result(column = \"address\",property = \"address\"),\n            @Result(property = \"orderList\",javaType = List.class,column = \"id\",\n                    many = @Many(select = \"com.example.mapper.OrderMapper1.findById\",fetchType= FetchType.EAGER))\n    })\n    public List<User> findAllWithOrder();\n}\n```\n\nOrderMapper1接口\n\n```java\npublic interface OrderMapper1 {\n    @Select(\"select *from orders\")\n    public List<Orders> findById();\n}\n```\n\n测试代码\n\n```java\n\t@Test\n    public void testUserWithOrder() throws Exception {\n        SqlSession sqlSession = MyBatisUtil.getSqlSession();\n        UserMapper1 userMapper = sqlSession.getMapper(UserMapper1.class);\n        List<User> list = userMapper.findAllWithOrder();\n        for (User user : list) {\n            System.out.println(user);\n        }\n    }\n```\n\n### 多对多查询\n\n需求：查询所有用户，同时查询出该用户的所有角色 多对多查询语句\n\nSELECT * FROM user;\n\nSELECT * FROM role r INNER JOIN user_role ur ON r.`id` = ur.`rid` WHERE ur.`uid` = #{用户id};\n\n**代码实现**\n\nUserMapper1接口\n\n```java\npublic interface UserMapper1 {\t\n\t@Select(\"SELECT * FROM `user`\")\n    @Results({\n            @Result(id = true, column = \"id\", property = \"id\"),\n            @Result(column = \"brithday\", property = \"brithday\"),\n            @Result(column = \"sex\", property = \"sex\"),\n            @Result(column = \"address\", property = \"address\"),\n            @Result(property = \"roleList\", javaType = List.class,\n                    column = \"id\" ,\n                    many = @Many(select = \"com.example.mapper.RoleMapper1.findByUid\",fetchType = FetchType.EAGER))\n    })\n    public List<User> findAllWithRole();\n}\n```\n\nRoleMapper1接口\n\n```java\npublic interface RoleMapper1 {\n    @Select(\"SELECT * FROM role r INNER JOIN user_role ur ON r.id = ur.roleid WHERE ur.userid = #{uid}\")\n    public List<Role> findByUid(Integer uid);\n}\n```\n\nsqlMapConfig.xml 配置\n\n```xml\n\t<mappers>\n        <!--扫描使用注解的Mapper类-->\n        <mapper class=\"com.example.mapper.UserMapper1\"></mapper>\n        <mapper class=\"com.example.mapper.OrderMapper1\"></mapper>\n        <mapper class=\"com.example.mapper.RoleMapper1\"></mapper>\n    </mappers>\n```\n\n测试代码\n\n```java\n\t@Test\n    public void testUserWithRole() throws Exception {\n        SqlSession sqlSession = MyBatisUtil.getSqlSession();\n        UserMapper1 userMapper = sqlSession.getMapper(UserMapper1.class);\n        List<User> list = userMapper.findAllWithRole();\n        for (User user : list) {\n            System.out.println(user);\n        }\n    }\n```\n\n### 基于注解的二级缓存\n\n**配置SqlMapConfig.xml文件开启二级缓存的支持**\n\n```xml\n\t<settings>\n        <!--\n        因为cacheEnabled的取值默认就为true，所以这一步可以省略不配置。\n        为true代表开启二级缓存；为false代表不开启二级缓存。\n        -->\n        <setting name=\"cacheEnabled\" value=\"true\"/>\n    </settings>\n```\n\n**在Mapper接口中使用注解配置二级缓存**\n\n```java\n@CacheNamespace\npublic interface UserMapper {...}\n```\n\n**注解延迟加载**\n\n不管是一对一还是一对多 ，在注解配置中都有fetchType的属性\n\n```\nfetchType = FetchType.LAZY 表示懒加载\nfetchType = FetchType.EAGER 表示立即加载\nfetchType = FetchType.DEFAULT 表示使用全局配置 \n```\n\n**小结**\n\n 注解开发和xml配置优劣分析 \n\n1.注解开发和xml配置相比，从开发效率来说，注解编写更简单，效率更高。 \n\n2.从可维护性来说，注解如果要修改，必须修改源码，会导致维护成本增加。xml维护性更强。","tags":["MyBatis"],"categories":["学习之路"]},{"title":"注解和反射","url":"/2022/11/04/注解和反射/","content":"\n## 枚举\n\n为了间接的表示一些固定的值，Java就给我们提供了枚举是指将变量的值一一列出来,变量的值只限于列举出来的值的范围内\n\n**定义格式**\n\n```java\npublic enum s {\n\t枚举项1,枚举项2,枚举项3;\n}\n注意: 定义枚举类要用关键字enum\n/* 定义一个枚举类，用来表示春，夏，秋，冬这四个固定值 */\npublic enum Season {\n\tSPRING,SUMMER,AUTUMN,WINTER;\n}\n```\n\n**示例代码**\n\n```java\npublic enum Season {\n\tSPRING(\"春\"),SUMMER,AUTUMN,WINTER(\"冬\");\n    private String s =null;\n    private SeasonEnum(){}\n    private SeasonEnum(String s){\n        this.s = s;\n    }\n    public String getS(){\n        return s;\n    }\n}\n```\n\n```java\npublic class Test {\n    public static void main(String[] args) {\n        System.out.println(Season.SPRING.getS());\n    }\n}\n```\n\n### 枚举的特点\n\n- 特点\n  - 所有枚举类都是Enum的子类\n  - 我们可以通过\"枚举类名.枚举项名称\"去访问指定的枚举项\n  - 每一个枚举项其实就是该枚举的一个对象\n  - 枚举也是一个类，也可以去定义成员变量\n\n```java\npublic class Test {\n     public static void main(String[] args) {\n        System.out.println(Season.SPRING);\n        System.out.println(Season.SUMMER);\n        System.out.println(Season.AUTUMN);\n        System.out.println(Season.WINTER);\n        Season spring = Season.SPRING;\n    }\n}\n```\n\n### 枚举的方法\n\n| 方法名                                   | 说明                                 |\n| ---------------------------------------- | ------------------------------------ |\n| String name()                            | 获取枚举项的名称                     |\n| int ordinal()                            | 返回枚举项在枚举类中的索引值         |\n| int compareTo(E o)                       | 比较两个枚举项，返回的是索引值的差值 |\n| String toString()                        | 返回枚举常量的名称                   |\n| static T valueOf(Class type,String name) | 获取指定枚举类中的指定名称的枚举值   |\n| values()                                 | 获得所有的枚举项                     |\n\n```java\npublic enum SeasonEnum {\n\tSPRING,SUMMER,AUTUMN,WINTER;\n}\n```\n\n```java\npublic class EnumDemo {\n    public static void main(String[] args) {\n        /* String name() 获取枚举项的名称 */\n        String name = SeasonEnum.SPRING.name();\n        System.out.println(name);\n        System.out.println(\"==============\");\n        /* int ordinal() 返回枚举项在枚举类中的索引值 */\n        int index1 = SeasonEnum.SPRING.ordinal();\n        int index2 = SeasonEnum.SUMMER.ordinal();\n        int index3 = SeasonEnum.AUTUMN.ordinal();\n        int index4 = SeasonEnum.WINTER.ordinal();\n        System.out.println(index1);\n        System.out.println(index2);\n        System.out.println(index3);\n        System.out.println(index4);\n        System.out.println(\"==============\");\n        /*int compareTo(E o) 比较两个枚举项，返回的是索引值的差值 */\n        int result = SeasonEnum.SPRING.compareTo(SeasonEnum.WINTER);\n        System.out.println(result);\n        System.out.println(\"===========\");\n        /* String toString() 返回枚举常量的名称 */\n        String str = SeasonEnum.SPRING.toString();\n        System.out.println(str);\n        System.out.println(\"==========\");\n        /* static <T> T valueOf(Class<T> type,String name) */\n        /* 获取指定枚举类中的指定名称的枚举值 */\n        SeasonEnum spring = Enum.valueOf(SeasonEnum.class, \"SPRING\");\n        System.out.println(spring);\n        System.out.println(SeasonEnum.SPRING == spring);\n        System.out.println(\"=========\");\n        /* values() 获得所有的枚举项 */\n        SeasonEnum[] values = SeasonEnum.values();\n        for (SeasonEnum value:values) {\n            System.out.println(value);\n        }\n    }\n}\n```\n\n## 注解\n\n**概述**\n\n- 对我们的程序进行标注和解释\n\n注解和注释的区别\n\n- 注释: 给程序员看的\n- 注解: 给编译器看的\n\n使用注解进行配置配置的优势\n\n- 代码更加简洁,方便\n\njava中的类，方法，变量，参数和包等都可以被标注。它们可以在编译、类加载、运行时被读取并执行相应的处理。\n\n**基本注解用法：**\n\n@Override 检查该方法是否是重写方法。如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误。\n\n@Deprecated 标识方法过时 如果使用该方法，会报编译警告。\n\n@SuppressWarnings 抑制警告，指示编译器去忽略注解中声明的警告。\n\n### 自定义注解\n\n**格式**\n\n```java\npublic @interface 注解名称 {\n\n\tpublic 属性类型 属性名() default 默认值 ;\n\n}\n```\n\n属性类型：基本数据类型，String，Class，注解，枚举，以上类型的一维数组\n\n```java\npublic @interface AnnoTest {\n    /* 定义一个char类型的属性 */\n    public char ch() default '好';\n\t/* 定义一个int类型的属性 */\n    int sum() default 1;\n\t/* 定义一个String类型的属性 */\n    String str() default \"好人\";\n\t/*定义String数组*/\n    String[] starr() default {\"h\",\"a\",\"o\"};\n\t/* 定义一个枚举类型的属性 */\n    Season season() default  Season.SPRING;\n\t/* 定义一个注解类型的属性 */\n    Anno anno() default @Anno;\n\t/* 定义一个Class类型的属性 */\n    Class clazz() default SeasonTest.class;\n\t/*value。后期我们在使用注解的时候，如果我们只需要给注解的value属性赋值。\n\t那么value就可以省略 */\n\tpublic String value();\n}\n\npublic @interface Anno {}\n\npublic enum Season {\n    SPRING,SUMMER,AUTUMN,WINTER;\n}\n```\n\n注意：如果只有一个属性需要赋值，并且属性的名称是value，则value可以省略，直接定义值即可\n\n**自定义注解案例**\n\n需求\n\n- 自定义一个注解@Test,用于指定类的方法上,如果某一个类的方法上使用了该注解,就执行该方法\n\n实现步骤\n\n- 自定义一个注解Test,并在类中的某几个方法上加上注解\n- 在测试类中,获取注解所在的类的Class对象\n- 获取类中所有的方法对象\n- 遍历每一个方法对象,判断是否有对应的注解\n\n代码实现\n\n```java\n/* 表示Test这个注解的存活时间 */\n/* RetentionPolicy.SOURCE —— 只在源文件中，编译后丢弃\nRetentionPolicy.CLASS —— 编译后保留在class中，但被JVM丢弃\nRetentionPolicy.RUNTIME —— 被JVM保留,所以他们能在运行时被JVM或其他使用反射机\n制的代码所读取和使用.\n*/\n\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface Anno {\n    \n}\n```\n\n```java\npublic class Utils {\n     /* 没有使用Test注解 */\n    public void hao(){\n        System.out.println(\"好人\");\n    }\n    /* 使用Test注解 */\n    @Anno\n    public void method(){\n        System.out.println(\"启动\");\n    }\n}\n```\n\n```java\npublic class Test {\n    public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, InvocationTargetException, NoSuchMethodException {\n        /* 1.通过反射获取UseTest类的字节码文件对象 */\n        Class clazz = Class.forName(\"com.example.qy161_backstage.Utils\");\n\t\t/* 创建对象 */\n        Utils utils = (Utils) clazz.getDeclaredConstructor().newInstance();\n\t\t/* 2.通过反射获取这个类里面所有的方法对象 */\n        Method[] method = clazz.getDeclaredMethods();\n\t\t/* 3.遍历数组，得到每一个方法对象 */\n        for (Method methods : method) {\n            /* method依次表示每一个方法对象。\n            isAnnotationPresent(Class<? extends Annotation> annotationClass)\n            判断当前方法上是否有指定的注解。\n            参数：注解的字节码文件对象\n            返回值：布尔结果。 true 存在 false 不存在 */\n            if (methods.isAnnotationPresent(Anno.class)){\n                methods.invoke(utils);\n            }\n        }\n    }\n}\n```\n\n### 元注解\n\n**概述**\n\n- 元注解就是描述注解的注解\n\n- 元注解介绍\n\n| 元注解名    | 说明                                  |\n| ----------- | ------------------------------------- |\n| @Target     | 指定了注解能在哪里使用                |\n| @Retention  | 可以理解为保留时间(生命周期)          |\n| @Inherited  | 表示修饰的自定义注解可以被子类继承    |\n| @Documented | 表示该自定义注解，会出现在API文档里面 |\n\n```java\n/* @Target({ElementType.FIELD,ElementType.TYPE,ElementType.METHOD})\n指定注解使用的位置（成员变量，类，方法）\n@Retention(RetentionPolicy.RUNTIME)\n指定该注解的存活时间\n@Inherited 指定该注解可以被继承 */\n@Target({ElementType.FIELD,ElementType.TYPE,ElementType.METHOD})\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface Anno {}\n```\n\n```java\n@Anno\npublic class Person {\n}\n```\n\n```java\npublic class Student extends Person {\n\tpublic void show(){\n\t\tSystem.out.println(\"student.......show..........\");\n\t}\n}\n```\n\n```java\npublic class StudentDemo {\n\tpublic static void main(String[] args) throws ClassNotFoundException {\n        /* 获取到Student类的字节码文件对象 */\n        Class clazz = Class.forName(\"com.aaa.myanno4.Student\");\n        /* 获取注解 */\n        boolean result = clazz.isAnnotationPresent(Anno.class);\n        System.out.println(result);\n\t}\n}\n```\n\n## 反射\n\n**反射概念：**\n\n- 通常情况下编写代码都是固定的，无论运行多少次执行的结果也是固定的，在某些特殊场合中编写 代码时不确定要创建什么类型的对象，也不确定要调用什么样的方法，这些都希望通过运行时传递 的参数来决定，该机制叫做动态编程技术，也就是反射机制。\n\n- 通俗来说，反射机制就是用于动态创建对象并且动态调用方法的机制。\n- 目前主流的框架底层都是采用反射机制实现的。\n\n**类加载器**\n\n负责将.class文件（存储的物理文件）加载在到内存中\n\nxxx.java --javac--> xxx.class --(类加载器)-->虚拟机\n\n**类加载的过程【理解】**\n\n- 类加载时机\n  - 创建类的实例（对象）--> new\n  - 调用类的类方法 -- >静态方法\n  - 访问类或者接口的类变量，或者为该类变量赋值 -->静态变量\n  - 使用反射方式来强制创建某个类或接口对应的java.lang.Class对象--> 反射\n  - 初始化某个类的子类 --> 创建子类\n  - 直接使用java.exe命令来运行某个主类 --> main 函数\n\n- 类加载过程\n  - 加载\n    -  通过包名 + 类名，获取这个类\n    - 把这个类加载到内存中\n    - 加载完毕创建一个class对象\n  - 链接\n    - 验证：确保Class文件字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身安全(文件中的信息是否符合虚拟机规范有没有安全隐患)\n    - 准备:负责为类的类变量（被static修饰的变量）分配内存，并设置默认初始化值,(初始化静态变量)\n    -  解析:将类的二进制数据流中的符号引用替换为直接引用(本类中如果用到了其他类，此时就需要找到对应的类)\n  - 初始化\n    - 根据程序员通过程序制定的主观计划去初始化类变量和其他资源,(静态变量赋值以及初始化其他资源)\n-  小结\n  - 当一个类被使用的时候，才会加载到内存\n  - 类加载的过程: 加载、验证、准备、解析、初始化\n\n**类加载的分类【理解】**\n\n- 分类\n  - Bootstrap class loader：虚拟机的内置类加载器，通常表示为null ，并且没有父null 启动类加载器\n  -  Platform class loader：平台类加载器,负责加载JDK中一些特殊的模块在，Java8和之前，这个加载器叫做扩展加载器（ExtClassLoader）\n  - System class loader：系统类加载器,负责加载用户类路径上所指定的类库，也叫Appclass Loader\n- 类加载器的继承关系\n  - System的父加载器为Platform\n  - Platform的父加载器为Bootstrap\n\n```java\npublic class ClassLoaderTest {\n    public static void main(String[] args) {\n        /* 获取系统类加载器 */\n        ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();\n        /* 获取系统类加载器的父加载器 --- 平台类加载器 */\n        ClassLoader parent = systemClassLoader.getParent();\n        /* 获取平台类加载器的父加载器 --- 启动类加载器 */\n        ClassLoader parent1 = parent.getParent();\n\n        System.out.println(\"系统类加载器\" + systemClassLoader);\n        System.out.println(\"平台类加载器\" + parent);\n        System.out.println(\"启动类加载器\" + parent1);\n    }\n}\n```\n\n**双亲委派模型【理解】**\n\n概念：如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式\n\n### ClassLoader类\n\n| 方法名                                              | 说明               |\n| --------------------------------------------------- | ------------------ |\n| public static ClassLoader getSystemClassLoader()    | 获取系统类加载器   |\n| public InputStream getResourceAsStream(String name) | 加载某一个资源文件 |\n\n```java\npublic class ClassLoaderDemo2 {\n    public static void main(String[] args) throws IOException {\n        /*static ClassLoader getSystemClassLoader() 获取系统类加载器\n\t\tInputStream getResourceAsStream(String name) 加载某一个资源文件*/\n\t\t/* 获取系统类加载器 */\n\t\tClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();\n        /* 利用加载器去加载一个指定的文件\n\t\t参数：文件的路径（放在src的根目录下，默认去那里加载）\n\t\t返回值：字节流 */\n        InputStream is = systemClassLoader.getResourceAsStream(\"prop.properties\");\n        Properties prop = new Properties();\n        prop.load(is);\n        System.out.println(prop);\n        is.close();\n    }\n}\n```\n\n### Class类\n\n**Class基本概念**\n\njava.lang.Class类的实例可以用于描述Java应用程序中的类和接口，也就是一种数据类型。 该类没有公共构造方法，该类的实例由Java虚拟机和类加载器自动构造完成，本质上就是加载到内存中的运行时类。\n\n获取Class对象的方式\n\n- 使用数据类型.class的方式可以获取对应类型的Class对象（掌握）。\n\n- 使用引用/对象.getClass()的方式可以获取对应类型的Class对象。\n- 使用包装类.TYPE的方式可以获取对应基本数据类型的Class对象。\n- 使用Class.forName()的方式来获取参数指定类型的Class对象（掌握）。\n- 使用类加载器ClassLoader的方式获取指定类型的Class对象。\n\n**常用的方法**\n\n| 方法声明                                  | 功能介绍                                  |\n| ----------------------------------------- | ----------------------------------------- |\n| static Class<?> forName(String className) | 用于获取参数指定类型对应的Class对象并返回 |\n| T newInstance() [方法已过时]              | 用于创建该Class对象所表示类的新实例       |\n\n```java\npublic class ClassTest {\n    public static void main(String[] args) throws ClassNotFoundException {\n        /* 1.使用数据类型.class的方式可以获取对应类型的Class对象*/\n        Class c1 = String.class;\n        System.out.println(\"c1：\"+c1);\n        // 自动调用toString方法 class java.lang.String\n        c1= int.class;\n        System.out.println(\"c1: \"+c1);\n        c1 = void.class;\n        System.out.println(\"c1: \"+c1);\n        System.out.println(\"=============\");\n        /* 2.使用对象.getClass()的方式获取对应的Class对象 */\n        String str1 = new String(\"hello\");\n        c1=str1.getClass();\n        System.out.println(\"c1: \"+c1);\n        //int.getClass(); Error: 基本数据类型的变量不能调用方法\n        Integer it1 = 20;\n        c1 = it1.getClass();\n        System.out.println(\"c1: \"+c1);\n        System.out.println(\"=============\");\n        /* 4.调用Class类中的forName方法来获取对应的Class对象*/\n        //要求写完整的名称：包名.类名\n        //不能获取基本数据类型的Class对象\n        c1 = Class.forName(\"java.util.Date\");\n        System.out.println(\"c1: \"+c1);\n        System.out.println(\"=============\");\n        /* 5.使用类加载器的方式来获取Class对象 */\n        ClassLoader classLoader = ClassTest.class.getClassLoader();\n        System.out.println(\"classLoader = \" + classLoader);\n        c1 = classLoader.loadClass(\"java.lang.String\");\n        System.out.println(\"c1 = \" + c1);\n\n    }\n}\n```\n\n### Constructor类\n\n概念：java.lang.reflect.Constructor类主要用于描述获取到的构造方法信息\n\n**Class类获Constructor类的方法**\n\n| 方法声明                                             | 功能介绍                                  |\n| ---------------------------------------------------- | ----------------------------------------- |\n| Constructor getConstructor(Class<>...parameterTypes) | 用于获取此Class对象所表示类型中参数指定的 |\n| Constructor<?>0getConstructors()                     | 用于获取此Class对象所表示类型中所有的公共 |\n\n**Constructor类的常用方法**\n\n| 方法声明                         | 功能介绍                                                     |\n| -------------------------------- | ------------------------------------------------------------ |\n| T newInstance(Object...initargs) | 使用此Constructor对象描述的构造方法来构造Class对象代表类型的新实例 |\n| int getModifiers()               | 获取方法的访问修饰符                                         |\n| String getName()                 | 获取方法的名称                                               |\n| Class<?[]getParameterTypes()     | 获取方法所有参数的类型                                       |\n\n```java\npublic class Person {\n    private String name;\n    public Person() {}\n\n    public Person(String name) {\n        this.name = name;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    @Override\n    public String toString() {\n        return \"Person{\" +\n                \"name='\" + name + '\\'' +\n                '}';\n    }\n}\n```\n\n```java\npublic class ConstructorTest {\n    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException {\n        Person person = new Person();\n        Class aClass = Class.forName(\"com.example.qy161_backstage.reflex.Person\");\n        Constructor constructors = aClass.getConstructor();\n        Object o = constructors.newInstance();\n        System.out.println(o);\n        \n        Person person1 = new Person(\"hd\");\n        Class aClass1 = Class.forName(\"com.example.qy161_backstage.reflex.Person\");\n        Constructor constructors1 = aClass.getConstructor(String.class);\n        Object hd1 = constructors1.newInstance(\"hd1\");\n        System.out.println(hd1);\n        \n\t\tPerson person2 = new Person();\n        Class aClass2 = Class.forName(\"com.example.qy161_backstage.reflex.Person\");\n        Constructor[] constructors2 = aClass2.getConstructors();\n        for (int i = 0; i < constructors2.length; i++) {\n            Constructor constructor = constructors2[i];\n            System.out.println(constructor);\n            System.out.println(\"==========================\");\n            System.out.println(constructor.getModifiers());\n            System.out.println(constructor.getName());\n            System.out.println(constructor.getParameterTypes());\n        }\n    }\n}\n```\n\n```java\npublic class PersonConstructorTest {\n    public static void main(String[] args) throws IOException, ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException {\n        /* 1.使用原始方式以无参形式构造Person类型的对象并打印 */\n        Person p1 = new Person();\n        System.out.println(\"无参方式创建的对象是：\" + p1);\n        System.out.println(\"-------------------------------\");\n        /* 2.使用反射机制以无参形式构造Person类型的对象并打印 */\n        /* 创建对象的类型可以从键盘输入\n        System.out.println(\"请输入要创建对象的类型：\");\n        Scanner sc = new Scanner(System.in);\n        String str1 = sc.next();\n        Class c1 = Class.forName(\"com.aaa.Person\");*/\n        /* 创建对象的类型可以从配置文件中读取 */\n        BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(\"E:/.Code/aaa.txt\")));\n        String str1 = br.readLine();\n        // Class aClass2 =Class.forName(\"com.example.qy161_backstage.reflex.Person\");\n        Class c1 = Class.forName(str1);\n        //System.out.println(\"无参方式创建的对象是：\" + c1.newInstance());\n        /* 获取Class对象对应类中的无参构造方法，也就是Person类中的无参构造方法 */\n        Constructor constructor = c1.getConstructor();\n        /* 使用获取到的无参构造方法来构造对应类型的对象，也就是Person类型的对象 */\n        System.out.println(\"无参方式创建的对象是：\" + constructor.newInstance());\n        br.close();\n        System.out.println(\"-------------------------------\");\n        /* 4.使用反射机制以有参方式构造Person类型的对象并打印 */\n        /* 获取Class对象对应类中的有参构造方法，也就是Person类中的有参构造方法 */\n        Constructor constructor1 = c1.getConstructor(String.class);\n        /* 使用获取到的有参构造方法来构造对应类型的对象，也就是Person类型的对象 */\n        /* newInstance方法中的实参是用于给有参构造方法的形参进行初始化的，也就是给name和age进行初始化的 */\n        System.out.println(\"有参方式构造的对象是：\" + constructor1.newInstance(\"zhangfei\"));\n        System.out.println(\"-------------------------------\");\n        /* 5.使用反射机制获取Person类中所有的公共构造方法并打印 */\n        Constructor[] constructors = c1.getConstructors();\n        for (Constructor ct : constructors) {\n            System.out.println(\"构造方法的访问修饰符是：\" + ct.getModifiers());\n            System.out.println(\"构造方法的方法名称是：\" + ct.getName());\n            Class[] parameterTypes = ct.getParameterTypes();\n            System.out.print(\"构造方法的所有参数类型是：\");\n            for (Class cs : parameterTypes) {\n                System.out.print(cs + \" \");\n            }\n            System.out.println();\n            System.out.println(\"-------------------------------\");\n        }\n    }\n}\n```\n\n### Field类\n\n基本概念：java.lang.reflect.Field类主要用于描述获取到的单个成员变量信息\n\n**获取到Field类的方法**\n\n| 方法声明                            | 功能介绍                                                |\n| ----------------------------------- | ------------------------------------------------------- |\n| Field getDeclaredField(String name) | 用于获取此Class对象所表示类中参数指定的单个成员变量信息 |\n| Field[ getDeclaredFields()          | 用于获取此Class对象所表示类中所有成员变量信息           |\n\n**Field类的常用方法**\n\n| 方法声明                           | 功能介绍                                                     |\n| ---------------------------------- | ------------------------------------------------------------ |\n| Object get(Object obj)             | 获取参数对象obj中此Field对象所表示成员变量的数值             |\n| void set(Object obj, object value) | 将参数对象obj中此Field对象表示成员变量的数值修改为参数value的数值 |\n| void setAccessible(boolean flag)   | 当实参传递true时，则反射对象在使用时应该取消Java语言访问检查 |\n| int getModifiers()                 | 获取成员变量的访问修饰符                                     |\n| Class<?> getType()                 | 获取成员变量的数据类型                                       |\n| String getName()                   | 获取成员变量的名称                                           |\n\n```java\npublic class FieldTest {\n    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException, NoSuchFieldException {\n        /*使用原始方式来构造对象以及获取成员变量的数值并打印\n        Person p1 = new Person(\"zhangfei\");\n        System.out.println(\"获取到的成员变量数值为：\" + p1.name);*/\n        //使用反射机制来构造对象以及获取成员变量的数值并打印\n        //获取Class对象\n        Class aClass = Class.forName(\"com.example.qy161_backstage.reflex.Person\");\n        //根据Class对象获取对应的有参构造方法\n        Constructor constructor = aClass.getConstructor(String.class);\n        //使用有参构造方法来得到Person类型的对象\n        Object name = constructor.newInstance(\"name\");\n        //根据Class对象获取对应的成员变量信息\n        Field declaredField = aClass.getDeclaredField(\"name\");\n        /* 设置Java语言访问检查的取消 暴力反射 */\n        declaredField.setAccessible(true);\n        //使用Person类型的对象来获取成员变量的数值并打印\n        System.out.println(\"获取到的成员变量数值为：\" + declaredField.get(name));\n        //使用原始方式修改指定对象中成员变量的数值后再次打印\n        //p1.name = \"guanyu\";\n        //System.out.println(\"修改后成员变量的数值为：\" + p1.name);\n        //使用反射机制修改指定对象中成员变量的数值后再次打印\n        declaredField.set(name,\"zhangfei\");\n        System.out.println(declaredField.get(name));\n        System.out.println(\"======================\");\n        //获取Class对象对应类中所有的成员变量\n        Field[] declaredField1 = aClass.getDeclaredFields();\n        for (Field d: declaredField1) {\n            System.out.println(\"获取到的访问修饰符为：\" + d.getModifiers());\n            System.out.println(\"获取到的数据类型为：\" + d.getType());\n            System.out.println(\"获取到的成员变量名称是：\" + d.getName());\n        }\n\n    }\n}\n```\n\n### Method类\n\n基本概念：java.lang.reflect.Method类主要用于描述获取到的单个成员方法信息\n\n**获取到Method类的方法**\n\n| 方法声明                                                 | 功能介绍                                                     |\n| -------------------------------------------------------- | ------------------------------------------------------------ |\n| Method getMethod(String name,Class<?>... parameterTypes) | 用于获取该Class对象表示类中名字为name参数为parameterTypes的指定公共成员方法 |\n| MethodgetMethods()                                       | 用于获取该Class对象表示类中所有公共成员方法                  |\n\n**Method类的常用方法**\n\n| 方法声明                                 | 功能介绍                                                    |\n| ---------------------------------------- | ----------------------------------------------------------- |\n| object invoke(Object obj,Object... args) | 使用对象obj来调用此Method对象所表示的成员方法，实参传递args |\n| int getModifiers()                       | 获取方法的访问修饰符                                        |\n| Class<?> getReturnType()                 | 获取方法的返回值类型                                        |\n| String getName()                         | 获取方法的名称                                              |\n| Class<?>getParameterTypes()              | 获取方法所有参数的类型                                      |\n| Class<?>-getExceptionTypes()             | 获取方法的异常信息                                          |\n\n```java\npublic class MethodTest {\n    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException {\n        //使用反射机制构造对象并调用方法打印结果\n        Class c1 = Class.forName(\"com.example.qy161_backstage.reflex.Person\");\n        //根据Class对象来获取对应的有参构造方法\n        Constructor constructor = c1.getConstructor(String.class);\n        //使用有参构造方法构造对象并记录\n        Object object = constructor.newInstance(\"zhangfei\");\n        //根据Class对象来获取对应的成员方法\n        Method method = c1.getMethod(\"getName\");\n        //使用对象调用成员方法进行打印\n        System.out.println(\"调用方法的返回值是：\" + method.invoke(object));\n        //使用反射机制来获取类中的所有成员方法并打印\n        Method[] methods = c1.getMethods();\n        for (Method mt : methods) {\n            System.out.println(\"成员方法的修饰符是：\" + mt.getModifiers());\n            System.out.println(\"成员方法的返回值类型是：\" + mt.getReturnType());\n            System.out.println(\"成员方法的名称是：\" + mt.getName());\n            System.out.println(\"成员方法形参列表的类型是：\");\n            Class<?>[] parameterTypes = mt.getParameterTypes();\n            for (Class ct : parameterTypes) {\n                System.out.print(ct + \" \");\n            }\n            System.out.println(\"成员方法的异常类型列表是：\");\n            Class<?>[] exceptionTypes = mt.getExceptionTypes();\n            for (Class ct: exceptionTypes) {\n                System.out.print(ct + \" \");\n            }\n        }\n\n    }\n}\n```\n\n**获取其它结构信息**\n\n| 方法声明                         | 功能介绍           |\n| -------------------------------- | ------------------ |\n| Package getPackage()             | 获取所在的包信息   |\n| Class<? super T> getSuperclass() | 获取继承的父类信息 |\n| Class<?>[] getInterfaces()       | 获取实现的所有接口 |\n| AnnotationgetAnnotations()       | 获取注解信息       |\n| TypegetGenericInterfaces()       | 获取泛型信息       |\n\n```java\npublic class Person {\n    private String name;\n    private int age;\n    public Person() {}\n\n    public Person(String name) {\n        this.name = name;\n    }\n    public Person(String name,int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    @Override\n    public String toString() {\n        return \"Person{\" +\n                \"name='\" + name + '\\'' +\n                \", age=\" + age +\n                '}';\n    }\n}\n```\n\n```java\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface MyAnnotation {\n}\n```\n\n```java\n@MyAnnotation\npublic class Student <T,E> extends Person implements Comparable, Serializable {\n\n    @Override\n    public int compareTo(Object o) {\n        return 0;\n    }\n}\n```\n\n```java\npublic class StudentTest {\n    public static void main(String[] args) throws ClassNotFoundException {\n        // 获取Student类型的Class对象\n        Class c1 = Class.forName(\"com.example.qy161_backstage.reflex.Student\");\n        System.out.println(\"获取到的包信息是：\" + c1.getPackage());\n        System.out.println(\"获取到的父类信息是：\" + c1.getSuperclass());\n        System.out.println(\"获取到的接口信息是：\");\n        Class[] interfaces = c1.getInterfaces();\n        for (Class ct : interfaces) {\n            System.out.print(ct + \" \");\n        }\n        System.out.println();\n        System.out.println(\"获取到的注解信息是：\");\n        Annotation[] annotations = c1.getAnnotations();\n        for (Annotation at : annotations) {\n            System.out.print(at + \" \");\n        }\n        System.out.println();\n        System.out.println(\"获取到的泛型信息是：\");\n        Type[] genericInterfaces = c1.getGenericInterfaces();\n        for (Type tt : genericInterfaces) {\n            System.out.print(tt + \" \");\n        }\n        System.out.println();\n    }\n}\n```\n\n","tags":["注解","反射"],"categories":["学习之路"]},{"title":"JavaWeb","url":"/2022/10/08/JavaWeb/","content":"\n## 基本概念\n\n### 前言\n\nweb开发：\n\n- web，网页的意思，www.baidu.com\n- 静态web\n  - html，css\n  - 提供给所有人看的数据始终不会发生变化！\n- 动态web\n  - 淘宝，几乎是所有的网站；\n  - 提供给所有人看的数据始终会发生变化，每个人在不同的时间，不同的地点看到的信息各不相同！\n  - 技术栈：Servlet/JSP，ASP，PHP；\n\n在Java中，动态web资源开发的技术统称为JavaWeb；\n\n### C/S架构的概念\n\nC/S架构（Client/Server，客户端/服务器模式），是一种比较早的软件体系结构，也是生活中很常见的结构。这种结构将需要处理的业务合理地分配到客户端和服务器端，客户端通常负责完成与用户的交互任务，服务器通常负责数据的管理。\n\n**C/S架构的主要优点如下：**\n\n客户端的界面和功能可以很丰富。\n\n应用服务器的负荷较轻。\n\n响应速度较快。\n\n**C/S架构的主要缺点如下：**\n\n适用面窄，用户群固定。\n\n维护和升级的成本高，所有的客户端都需要更新版本。\n\n### B/S架构的概念\n\nB/S架构（Browser/Server，浏览器/服务器模式），是互联网兴起后的软件体系结构，该结构将系统功能实现的主要业务逻辑集中到服务器端，极少数业务逻辑在浏览器实现，浏览器通常负责完成与用户的交互任务，服务器通常负责数据的管理。\n\n**B/S架构的主要优点如下：**\n\n无需安装客户端，只要有浏览器即可。\n\n适用面广，用户群不固定。\n\n通过权限控制实现多客户访问的目的，交互性较强。\n\n维护和升级的成本低，无需更新所有客户端版本。\n\n**B/S架构的主要缺点如下：**\n\n应用服务器的负荷较重。\n\n浏览器的界面和功能想要达到客户端的丰富程度需要花费大量的成本。\n\n在跨浏览器上不尽如人意，适配比较麻烦。\n\n### web应用程序\n\nweb应用程序：可以提供浏览器访问的程序；\n\n- a.html、b.html......多个web资源，这些web资源可以被外界访问，对外界提供服务；\n- 你们能访问到的任何一个页面或者资源，都存在于这个世界的某一个角落的计算机上。\n- URL\n- 这个统一的web资源会被放在同一个文件夹下，web应用程序-->Tomcat：服务器\n- 一个web应用由多部分组成 （静态web，动态web）\n  - html，css，js\n  - jsp，servlet\n  - Java程序\n  - jar包\n  - 配置文件 （Properties）\n\nweb应用程序编写完毕后，若想提供给外界访问：需要一个服务器来统一管理；\n\n### 静态web\n\n- *.htm, *.html,这些都是网页的后缀，如果服务器上一直存在这些东西，我们就可以直接进行读取。通络；\n\n![](https://image.aobayu.cn/images/web1.png)\n\n- 静态web存在的缺点\n  - Web页面无法动态更新，所有用户看到都是同一个页面\n    - 轮播图，点击特效：伪动态\n    - JavaScript [实际开发中，它用的最多]\n    - VBScript\n  - 它无法和数据库交互（数据无法持久化，用户无法交互）\n\n### 动态web\n\n页面会动态展示： “Web的页面展示的效果因人而异”；\n\n![](https://image.aobayu.cn/images/web2.png)\n\n缺点：\n\n- 加入服务器的动态web资源出现了错误，我们需要重新编写我们的\n\n  - 后台程序\n  - 重新发布\n  - 停机维护\n\n优点：\n\n- Web页面可以动态更新，所有用户看到都不是同一个页面\n- 它可以与数据库交互 （数据持久化：注册，商品信息，用户信息........）\n\n![](https://image.aobayu.cn/images/web3.png)\n\n## web服务器\n\n**ASP:**\n\n- 微软：国内最早流行的就是ASP；\n\n- 在HTML中嵌入了VB的脚本， ASP + COM；\n\n- 在ASP开发中，基本一个页面都有几千行的业务代码，页面极其乱；\n\n- 维护成本高！\n\n- C#\n\n- IIS\n\n  ```html\n  <h1>\n      <h1><h1>\n          <h1>\n              <h1>\n                  <h1>\n          <h1>\n              <%\n              System.out.println(\"hello\")\n              %>\n              <h1>\n                  <h1>\n     <h1><h1>\n  <h1>\n  ```\n\n**php：**\n\n- PHP开发速度很快，功能很强大，跨平台，代码很简单 （70% , WP）\n- 无法承载大访问量的情况（局限性）\n\n**JSP/Servlet : **\n\nB/S：浏览和服务器\n\nC/S: 客户端和服务器\n\n- sun公司主推的B/S架构\n- 基于Java语言的 (所有的大公司，或者一些开源的组件，都是用Java写的)\n- 可以承载三高问题带来的影响\n- 语法像ASP ， ASP-->JSP , 加强市场强度\n\n**Web Server**\n\n服务器是一种被动的操作，用来处理用户的一些请求和给用户一些响应信息\n\n**IIS**\n\n微软的； ASP...,Windows中自带的\n\n**Tomcat**\n\n面向百度编程\n\nTomcat是Apache 软件基金会（Apache Software Foundation）的Jakarta 项目中的一个核心项目，最新的Servlet 和JSP 规范总是能在Tomcat 中得到体现，因为Tomcat 技术先进、性能稳定，而且**免费**，因而深受Java 爱好者的喜爱并得到了部分软件开发商的认可，成为目前比较流行的Web 应用服务器。\n\nTomcat 服务器是一个免费的开放源代码的Web 应用服务器，属于轻量级应用服务器，在中小型系统和并发访问用户不是很多的场合下被普遍使用，是开发和调试JSP 程序的首选。对于一个Java初学web的人来说，它是最佳的选择\n\nTomcat 实际上运行JSP 页面和Servlet。\n\n## HTTP协议\n\nHTTP协议（HyperText Transfer Protocol，超文本传输协议）是由W3C（万维网联盟）组织制定的一种应用层协议，是用来规范浏览器与Web服务器之间如何通讯的数据格式，主要涉及浏览器的发请求格式和服务器的响应格式。\n\nHTTP协议通常承载于TCP协议之上，而承载于TLS或SSL协议层之上的协议就是常说的HTTPS协议。\n\nHTTP默认的端口号为80，HTTPS默认的端口号为443。\n\n**两个时代**\n\n- http1.0\n  - HTTP/1.0：客户端可以与web服务器连接后，只能获得一个web资源，断开连接\n- http2.0\n  - HTTP/1.1：客户端可以与web服务器连接后，可以获得多个web资源。\n\n**HTTP请求格式**\n\n客户端发送一个HTTP请求到服务器的请求消息主要包括：请求行、请求头、空白行和请求体。\n\n**HTTP响应格式**\n\n通常情况下服务器接收并处理客户端发过来的请求后会返回一个HTTP的响应消息，主要包括：响应行、响应头、空白行和响应体。\n\n- 客户端---发请求（Request）---服务器\n\n百度：\n\n```java\nRequest URL:https://www.baidu.com/   请求地址\nRequest Method:GET    get方法/post方法\nStatus Code:200 OK    状态码：200\nRemote（远程） Address:14.215.177.39:443\n    \nAccept:text/html  \nAccept-Encoding:gzip, deflate, br\nAccept-Language:zh-CN,zh;q=0.9    语言\nCache-Control:max-age=0\nConnection:keep-alive\n```\n\n**请求行**\n\n- 请求行中的请求方式：GET\n\n- 请求方式：\n\n  Get，Post,HEAD,DELETE,PUT,TRACT…\n\n  - get：请求能够携带的参数比较少，大小有限制，会在浏览器的URL地址栏显示数据内容，不安全，但高效\n  - post：请求能够携带的参数没有限制，大小没有限制，不会在浏览器的URL地址栏显示数据内容，安全，但不高效。\n\n**消息头**\n\n```java\nAccept：告诉浏览器，它所支持的数据类型\nAccept-Encoding：支持哪种编码格式  GBK   UTF-8   GB2312  ISO8859-1\nAccept-Language：告诉浏览器，它的语言环境\nCache-Control：缓存控制\nConnection：告诉浏览器，请求完成是断开还是保持连接\nHOST：主机..../.\n```\n\n**Http响应**\n\n- 服务器---响应-----客户端\n\n百度：\n\n```java\nCache-Control:private    缓存控制\nConnection:Keep-Alive    连接\nContent-Encoding:gzip    编码\nContent-Type:text/html   类型\n```\n\n**响应体**\n\n```java\nAccept：告诉浏览器，它所支持的数据类型\nAccept-Encoding：支持哪种编码格式  GBK   UTF-8   GB2312  ISO8859-1\nAccept-Language：告诉浏览器，它的语言环境\nCache-Control：缓存控制\nConnection：告诉浏览器，请求完成是断开还是保持连接\nHOST：主机..../.\nRefresh：告诉客户端，多久刷新一次；\nLocation：让网页重新定位；\n```\n\n**响应状态码**\n\n200：请求响应成功 200\n\n3xx：请求重定向\n\n- 重定向：你重新到我给你新位置去；\n\n4xx：找不到资源 404\n\n- 资源不存在；\n\n5xx：服务器代码错误 500 502:网关错误\n\n## tomcat\n\n**安装tomcat**\n\ntomcat官网：http://tomcat.apache.org/\n\n**Tomcat启动和配置**\n\nbin: 主要存放二进制可执行文件和脚本。\n\nconf: 主要存放各种配置文件。\n\nlib: 主要用来存放Tomcat运行需要加载的jar包。\n\nlogs: 主要存放Tomcat在运行过程中产生的日志文件。\n\ntemp: 主要存放Tomcat在运行过程中产生的临时文件。\n\nwebapps: 主要存放应用程序，当Tomcat启动时会去加载该目录下的应用程序。\n\nwork: 主要存放tomcat在运行时的编译后文件，例如JSP编译后的文件。\n\n**启动-关闭Tomcat**\n\nstartup.bat: 启动\n\nshutdown.bat: 关闭\n\n**可能遇到的问题：**\n\n1. Java环境变量没有配置\n2. 闪退问题：需要配置兼容性\n3. 乱码问题：配置文件中设置\n\n**启动信息乱码的处理方式**\n\napache-tomcat-8.5.68\\conf下\n\nlogging.properties文件修改为\n\njava.util.logging.ConsoleHandler.encoding = GBK\n\n## 在IDEA中使用tomcat\n\n1.添加新配置\n\n![](https://image.aobayu.cn/images/tomcat1.png)\n\n2. 添加Tomact Server\n\n![](https://image.aobayu.cn/images/tomcat2.png)\n\n3. 选择 tomcat 路径\n\n![](https://image.aobayu.cn/images/tomcat3.png)\n\n4. 添加 Artifact\n\n![](https://image.aobayu.cn/images/tomcat4.png)\n\n5. 添加 :war exploded\n\n![](https://image.aobayu.cn/images/tomcat5.png)\n\n6. 启动\n\n![](https://image.aobayu.cn/images/tomcat6.png)\n\n## maven\n\n**我为什么要学习这个技术？**\n\n1. 在Javaweb开发中，需要使用大量的jar包，我们手动去导入；\n\n2. 如何能够让一个东西自动帮我导入和配置这个jar包。\n\n   由此，Maven诞生了！\n\n**Maven项目架构管理工具**\n\n我们目前用来就是方便导入jar包的！\n\nMaven的核心思想：约定大于配置\n\n- 有约束，不要去违反。\n\nMaven会规定好你该如何去编写我们的Java代码，必须要按照这个规范来；\n\n**Maven的作用**\n\n- 依赖管理\n  - 依赖指的就是是 我们项目中需要使用的第三方Jar包, 一个大一点的工程往往需要几十上百个 Jar包,按照我们之前的方式,每使用一种Jar,就需要导入到工程中,还要解决各种Jar冲突的问题.\n  - Maven可以对Jar包进行统一的管理,包括快速引入Jar包,以及对使用的 Jar包进行统一的版本控制\n\n- 一键构建项目\n  - 之前我们创建项目,需要确定项目的目录结构,比如 src 存放Java源码, resources 存放配置文件,还要配置环境比如JDK的版本等等,如果有多个项目 那么就需要每次自己搞一套配置,十分麻烦\n  - Maven为我们提供了一个标准化的Java项目结构,我们可以通过Maven快速创建一个标准的 Java项目.\n\n**下载安装Maven**\n\n官网;https://maven.apache.org/\n\n下载完成后，解压即可；\n\n解压后目录结构:\n\nbin:存放了 maven 的命令 \n\nboot:存放了一些 maven 本身的引导程序，如类加载器等 \n\nconf:存放了 maven 的一些配置文件，如 setting.xml 文件 \n\nlib:存放了 maven 本身运行所需的一些 jar 包\n\n**配置环境变量**\n\n在我们的系统环境变量中\n\n配置如下配置：\n\n- MAVEN_HOME maven的目录\n- 在系统的path中配置 %MAVEN_HOME%\\bin\n\n**Maven 软件版本测试**\n\n打开命令行，输入 mvn –v命令，看到版本号，即为执行成功\n\n**Maven中的仓库是用来存放maven构建的项目和各种依赖的(Jar包)**\n\n**本地仓库**: 位于自己计算机中的仓库, 用来存储从远程仓库或中央仓库下载的插件和 jar 包，\n\n**远程仓库**: 需要联网才可以使用的仓库，阿里提供了一个免费的maven 远程仓库。 \n\n**中央仓库**: 在 maven 软件中内置一个远程仓库地址 [http://repo1.maven.org/maven2](http://repo1.maven.org/maven2?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2NjUyMjA1MzksImZpbGVHVUlEIjoiV2xBcnoxN0phWXM3dkdBMiIsImlhdCI6MTY2NTIyMDIzOSwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjotNzIzMTQ0NTA2MX0.B5LqHwI3o8MwvpNDgo_YTD1c7l2WhsinqEF5Xeh4a-c) ，它是中央仓库，服务于整个互联网，它是由 Maven 团队自己维护，里面存储了非常全的 jar 包，它包 含 了世界上大部分流行的开源项目构件\n\n**Maven 本地仓库的配置**\n\nmaven仓库默认是在 C盘 .m2 目录下,如果怕C盘满，可以在设置中配置\n\n在maven安装目录中,进入 conf文件夹, 可以看到一个 settings.xml 文件中, 我们在这个文件中, 进行 本地仓库的配置打开 settings.xml文件，进行如下配置：\n\n**Maven 本地仓库的配置**  打开 settings.xml找到 localRepository 标签,下面的内容复制到其中即可\n\n```\n<localRepository>D:\\Environment\\apache-maven-3.6.2\\maven-repo</localRepository>\n```\n\n **配置阿里云远程仓库**  打开 settings.xml,找到<mirrors> 标签 , 下面的内容复制到其中即可\n\n```\n<mirror>\n    <id>alimaven</id>\n    <name>aliyun maven</name>\n    <url>http://maven.aliyun.com/nexus/content/groups/public/</url>\n    <mirrorOf>central</mirrorOf>\n</mirror>\n```\n\n## 在IDEA中使用Maven\n\n1. 打开IDEA，新建项目\n\n![](https://image.aobayu.cn/images/Maven1.png)\n\n2. 选择Jakarta EE ，Web appLication，下一步\n\n![](https://image.aobayu.cn/images/Maven2.png)\n\n3. 选择Java EE 8，勾选 Web Profile，创建项目\n\n![](https://image.aobayu.cn/images/Maven3.png)\n\n4. 项目创建完成，目录如下\n\n![](https://image.aobayu.cn/images/Maven4.png)\n\n5. IDEA中的Maven设置，仓库位置，更改路径\n\n![](https://image.aobayu.cn/images/Maven5.png)\n\n**pom核心配置文件**\n\n一个 maven 工程都有一个 pom.xml 文件，通过 pom.xml 文件定义项目的信息、项目依赖、引入插 件等等。\n\n创建一个Servlet, 缺少jar包报错, 要解决问题，就是要将 servlet-api-xxx.jar 包放进来，作为 maven 工程应当添加 servlet的坐标，从而导入它的 jar\n\n pom.xml 文件中引入依赖包的坐标 \n\n```\n<!--引入Servlet依赖-->\n<dependencies>\n    <dependency>\n      <groupId>javax.servlet</groupId>\n      <artifactId>javax.servlet-api</artifactId>\n      <version>4.0.1</version>\n      <scope>provided</scope>\n    </dependency>\n</dependencies>\n```\n\n使用插件,可以由插件启动tomcat\n\n```\n<build>\n    <plugins>\n        <!--Tomcat插件 -->\n        <plugin>\n            <groupId>org.apache.tomcat.maven</groupId>\n            <artifactId>tomcat7-maven-plugin</artifactId>\n            <version>2.2</version>\n            <!--修改Tomcat的端口和访问路径-->\n            <configuration>\n                <port>80</port><!--访问端口号 -->\n                <path>/</path>\n            </configuration>\n        </plugin>\n    </plugins>\n</build>\n```\n\n**Maven的常用命令** \n\n| 命令        | 说明                                                         |\n| ----------- | ------------------------------------------------------------ |\n| mvn compile | 完成编译操作，执行完毕后，会生成target目录，该目录中存放了编译后的字节码文件 |\n| mvn clean   | 执行完毕后，会将target目录删除                               |\n| mvn clean   | 执行完毕后，会在target目录中生成三个文件夹:<br>surefire、surefire-reports(测试报告)、test-classes(测试的字节码文件) |\n| mvn package | 完成打包操作,执行完毕后，会在target目录中生成一个文件，该文件可能是jar、war |\n| mvn install | 执行mvn install命令，完成将打好的jar包安装到本地仓库的操作，执行完毕后<br>会在本地仓库中出现安装后的jar包，方便其他工程引用 |\n\n## Servlet\n\nServlet（Server Applet）是Java Servlet的简称，称为小服务程序或服务连接器，是Java语言编写的服务器端程序，换句话说，Servlet就是运行在服务器上的Java类。\n\nServlet用来完成B/S架构下客户端请求的响应处理，也就是交互式地浏览和生成数据，生成动态Web内容。\n\n### Servlet的编程步骤\n\n- 建立一个Java Web Application项目并配置Tomcat服务器。\n- 自定义类实现Servlet接口或继承 HttpServlet类（推荐） 并重写service方法。\n- 将自定义类的信息配置到 web.xml文件并启动项目，配置方式如下\n\n```java\n//@WebServlet(\"/hello1\") web.xml中不配置 使用注解\npublic class HelloServlet  implements Servlet {\n        @Override\n        public void init(ServletConfig servletConfig) throws ServletException {\n\n        }\n\n        @Override\n        public ServletConfig getServletConfig() {\n        \treturn null;\n        }\n\n        @Override\n        public void service(ServletRequest servletRequest,ServletResponse servletResponse) throws ServletException, IOException {\n        \tSystem.out.println(\"接收到了浏览器的请求并做出了响应！\");\n        }\n\n        @Override\n        public String getServletInfo() {\n        \treturn null;\n        }\n\n        @Override\n        public void destroy() {\n\n        }\n}\n```\n\n> src.main.webapp.WEB-INF 下的 web.xml 中添加\n\n```java\n<!-- 配置Servlet -->\n<servlet>\n    <!-- HelloServlet是Servlet类的别名 -->\n    <servlet-name>HelloServlet</servlet-name>\n    <!-- com.aaa.test1.HelloServlet是包含路径的真实的Servlet类名 -->\n    <servlet-class>com.aaa.test1.HelloServlet</servlet-class>\n</servlet>\n<!-- 映射Servlet -->\n<servlet-mapping>\n    <!-- HelloServlet是Servlet类的别名，与上述名称必须相同 -->\n    <servlet-name>HelloServlet</servlet-name>\n    <!-- /hello是供浏览器使用的地址 -->\n    <url-pattern>/hello</url-pattern>\n</servlet-mapping>\n```\n\n在浏览器上访问的方式为：http://localhost:8080/工程路径/url-pattern的内容\n\n###  Servlet接口\n\n基本概念\n\n- javax.servlet.Servlet接口用于定义所有servlet必须实现的方法。\n\n常用的方法\n\n方法介绍\n\n**void init(ServletConfig config)**\t由servlet容器调用，以向servlet指示servlet正在被放入服务中\n\n**void service(ServletRequest req,ServletResponse res)**\t由servlet容器调用，以允许servlet响应请求\n\n**ServletConfig getServletConfig()**\t返回ServletConfig对象，该对象包含此servlet的初始化和启动参数\n\n**String getServletInfo()**\t返回有关servlet的信息，如作者、版本和版权\n\n**void destroy()**\t由servlet容器调用，以向servlet指示该servlet正在退出服务\n\n### Servlet的生命周期\n\n- 构造方法只被调用一次，当第一次请求Servlet时调用构造方法来创建Servlet的实例。 \n\n- init方法只被调用一次，当创建好Servlet实例后立即调用该方法实现Servlet的初始化。  \n\n- service方法被多次调用，每当有请求时都会调用service方法来用于请求的响应。 \n\n- destroy方法只被调用一次，当该Servlet实例所在的Web应用被卸载前调用该方法来释放当前占用的资源。\n\n### GenericServlet类\n\n基本概念\n\n- javax.servlet.GenericServlet类主要用于定义一个通用的、与协议无关的servlet，该类实现了Servlet接口。\n\n- 若编写通用servlet，只需重写service抽象方法即可。\n\n**常用的方法**\n\n| 方法声明                                                     | 功能介绍                             |\n| ------------------------------------------------------------ | ------------------------------------ |\n| abstract void service(ServletRequest req,ServletResponse res) | 由servlet容器调用允许servlet响应请求 |\n\n### HttpServlet类\n\n基本概念\n\n- javax.servlet.http.HttpServlet类是个抽象类并继承了GenericServlet类。\n\n- 用于创建适用于网站的HTTP Servlet，该类的子类必须至少重写一个方法。\n\n**常用的方法**\n\n**void doGet(HttpServletRequest req,HttpServletResponse resp)**\t处理客户端的GET请求\n\n**void doPost(HttpServletRequest req,HttpServletResponse resp)**\t处理客户端的POST请求\n\n**void init()**\t进行初始化操作\n\n**void service(HttpServletRequest req,HttpServletResponse resp)** 根据请求决定调用doGet还是doPost方法\n\n**void destroy()**\t删除实例时释放资源\n\n**GET请求**\n\n发出GET请求的主要方式： \n\n​\t（1）在浏览器输入URL按回车 \n\n​\t（2）点击<a>超链接 </a>\n\n​\t（3）点击submit按钮，提交 <form method=\"get\">表单 GET请求特点：会将请求数据添加到请求URL地址的后面，只能提交少量的数据、不安全\n\n**POST请求**\n\n发出POST请求的方法如下： \n\n​\t点击submit按钮，提交 <form method=\"post\">表单 \n\nPOST请求的特点： \n\n​\t请求数据添加到HTTP协议体中，可提交大量数据、安全性好\n\n> 实现Servlet接口，这里我们直接继承HttpServlet\n\n```java\n@WebServlet(\"/thind\")\npublic class ThindServlet extends HttpServlet {\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        System.out.println(\"Post\");\n    }\n\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        System.out.println(\"Get\");\n    }\n}\n```\n\n> 编写Servlet的映射(有Servlet依赖则不用)\n\n```xml\n    <!--注册Servlet-->\n    <servlet>\n        <servlet-name>hello</servlet-name>\n        <servlet-class>com.kuang.servlet.HelloServlet</servlet-class>\n    </servlet>\n    <!--Servlet的请求路径-->\n    <servlet-mapping>\n        <servlet-name>hello</servlet-name>\n        <url-pattern>/hello</url-pattern>\n    </servlet-mapping>\n```\n\n> 映射问题\n\n1. 一个Servlet可以指定一个映射路径\n\n   ```xml\n       <servlet-mapping>\n           <servlet-name>hello</servlet-name>\n           <url-pattern>/hello</url-pattern>\n       </servlet-mapping>\n   ```\n\n2. 一个Servlet可以指定多个映射路径\n\n   ```xml\n       <servlet-mapping>\n           <servlet-name>hello</servlet-name>\n           <url-pattern>/hello</url-pattern>\n       </servlet-mapping>\n       <servlet-mapping>\n           <servlet-name>hello</servlet-name>\n           <url-pattern>/hello2</url-pattern>\n       </servlet-mapping>\n       <servlet-mapping>\n           <servlet-name>hello</servlet-name>\n           <url-pattern>/hello3</url-pattern>\n       </servlet-mapping>\n       <servlet-mapping>\n           <servlet-name>hello</servlet-name>\n           <url-pattern>/hello4</url-pattern>\n       </servlet-mapping>\n       <servlet-mapping>\n           <servlet-name>hello</servlet-name>\n           <url-pattern>/hello5</url-pattern>\n       </servlet-mapping>\n   ```\n\n3. 一个Servlet可以指定通用映射路径\n\n   ```xml\n       <servlet-mapping>\n           <servlet-name>hello</servlet-name>\n           <url-pattern>/hello/*</url-pattern>\n       </servlet-mapping>\n   ```\n\n4. 默认请求路径\n\n   ```xml\n       <!--默认请求路径-->\n       <servlet-mapping>\n           <servlet-name>hello</servlet-name>\n           <url-pattern>/*</url-pattern>\n       </servlet-mapping>\n   ```\n\n5. 指定一些后缀或者前缀等等….\n\n   ```xml\n   <!--可以自定义后缀实现请求映射\n       注意点，*前面不能加项目映射的路径\n       hello/sajdlkajda.qinjiang\n       -->\n   <servlet-mapping>\n       <servlet-name>hello</servlet-name>\n       <url-pattern>*.qinjiang</url-pattern>\n   </servlet-mapping>\n   ```\n\n6. 优先级问题\n   指定了固有的映射路径优先级最高，如果找不到就会走默认的处理请求；\n\n   ```xml\n   <!--404-->\n   <servlet>\n       <servlet-name>error</servlet-name>\n       <servlet-class>com.kuang.servlet.ErrorServlet</servlet-class>\n   </servlet>\n   <servlet-mapping>\n       <servlet-name>error</servlet-name>\n       <url-pattern>/*</url-pattern>\n   </servlet-mapping>\n   ```\n\n### ServletRequest接口\n\n基本概念 \n\n- javax.servlet.ServletRequest接口主要用于向servlet提供客户端请求信息，可以从中获取到任何 请求信息。 \n\n- Servlet容器创建一个ServletRequest对象，并将其作为参数传递给Servlet的service方法。\n\n**常用的方法**\n\n**String getParameter(String name)**\t以字符串形式返回请求参数的值，如果该参数不存在，则返回空值\n\n**String[] getParameterValues(String name)**\t返回一个字符串对象数组，其中包含给定请求参数所具有的所有值，如果该参数不存在，则返回空值\n\n**Map<String, String[]> getParameterMap()**\t返回请求参数的键值对，一个键可以对应多个值\n\n**String getRemoteAddr()**\t返回发送请求的客户端或最后一个代理的IP地址\n\n**int getRemotePort()**\t返回发送请求的客户端或最后一个代理的端口号\n\n```html\n<html>\n<head>\n    <meta charset=\"UTF-8\">\n    <title>请求参数的获取和测试</title>\n</head>\n<body>\n    <form action=\"parameter\" method=\"post\">\n      姓名：<input type=\"text\" name=\"name\"/><br/>\n      年龄：<input type=\"text\" name=\"age\"/><br/>\n      爱好：<input type=\"checkbox\" name=\"hobby\" value=\"Java\"/>Java\n      <input type=\"checkbox\" name=\"hobby\" value=\"C\"/>C\n      <input type=\"checkbox\" name=\"hobby\" value=\"C++\"/>C++<br/>\n      <input type=\"submit\" value=\"提交\"/>\n    </form>\n</body>\n</html>\n```\n\n```java\n@WebServlet(\"/parameter\")\npublic class ParameterServlet extends HelloServlet{\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException, UnsupportedEncodingException {\n        // 6.设置请求信息中的编码方式为utf-8来解决乱码问题\n        request.setCharacterEncoding(\"utf-8\");\n        // 1.获取指定参数名称对应的参数值并打印\n        String name = request.getParameter(\"name\");\n        System.out.println(\"获取到的姓名为：\" + name);\n        String[] hobbies = request.getParameterValues(\"hobby\");\n        System.out.print(\"获取到的爱好有：\");\n        for (String ts : hobbies) {\n            System.out.print(ts + \" \");\n        }\n        System.out.println();\n        System.out.println(\"----------------------------\");\n\n        // 2.获取请求参数名和对应值的第二种方式\n        Map<String, String[]> parameterMap = request.getParameterMap();\n        // 使用Map集合中所有的键值对组成Set集合\n        Set<Map.Entry<String, String[]>> entries = parameterMap.entrySet();\n        // 遍历Set集合\n        for (Map.Entry<String, String[]> me : entries) {\n            System.out.print(me.getKey() + \"对应的数值有：\");\n            for (String ts : me.getValue()) {\n                System.out.print(ts + \" \");\n            }\n            System.out.println();\n        }\n        System.out.println(\"----------------------\");\n        // 4.获取客户端请求的其它信息\n        System.out.println(\"发送请求的客户端IP地址为：\" + request.getRemoteAddr());\n        System.out.println(\"发送请求的客户端端口号为：\" + request.getRemotePort());\n    }\n}\n```\n\n### HttpServletRequest接口\n\nweb服务器接收到客户端的http请求，针对这个请求，分别创建一个代表请求的HttpServletRequest对象，代表响应的一个HttpServletResponse；\n\n- 如果要获取客户端请求过来的参数：找HttpServletRequest\n- 如果要给客户端响应一些信息：找HttpServletResponse\n\n基本概念\n\n- javax.servlet.http.HttpServletRequest接口是ServletRequest接口的子接口，主要用于提供HTTP 请求信息的功能。 \n\n- 不同于表单数据，在发送HTTP请求时，HTTP请求头直接由浏览器设置。 \n\n- 可直接通过HttpServletRequest对象提供的一系列get方法获取请求头数据。 \n\n**常用的方法**\n\n**String getRequestURI()**\t返回此请求的资源路径信息\n\n**StringBuffer getRequestURL()**\t返回此请求的完整路径信息\n\n**String getMethod()**\t返回发出此请求的HTTP方法的名称，例如GET、POST\n\n**String getQueryString()**\t返回路径后面请求中附带的参数\n\n**String getServletPath()**\t返回此请求中调用servlet的路径部分\n\n```java\nSystem.out.println(\"发送请求的客户端IP地址为：\" +request.getRemoteAddr());\nSystem.out.println(\"发送请求的客户端端口号为：\" + request.getRemotePort());\nSystem.out.println(\"请求资源的路径为：\" + request.getRequestURI());\nSystem.out.println(\"请求资源的完整路径为：\" + request.getRequestURL());\nSystem.out.println(\"请求方式为：\" + request.getMethod());\nSystem.out.println(\"请求的附带参数为：\" + request.getQueryString());\nSystem.out.println(\"请求的Servlet路径为：\" + request.getServletPath());\n```\n\n### ServletResponse接口\n\n基本概念\n\n- javax.servlet.ServletResponse接口用于定义一个对象来帮助Servlet向客户端发送响应。 \n\n- Servlet容器创建ServletResponse对象，并将其作为参数传递给servlet的service方法。\n\n**常用方法**\n\n**PrintWriter getWriter()**\t返回可向客户端发送字符文本的PrintWriter对象\n\n**String getCharacterEncoding()**\t获取响应内容的编码方式\n\n**void setContentType(String type)**\t如果尚未提交响应，则设置发送到客户端响应的内容类型。内容类型可以包括字符编码规范，例如text/html;charset=UTF-8\n\n```java\n@Override\npublic void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n\t\t// 获取响应数据的默认编码方式\n        String characterEncoding = response.getCharacterEncoding();\n        System.out.println(\"服务器响应数据的默认编码方式为：\" + characterEncoding);\n        // ISO-8859-1\n        // 设置服务器和浏览器的编码方式以及文本类型\n        response.setContentType(\"text/html;charset=UTF-8\");\n        PrintWriter writer = response.getWriter();\n        writer.write(\"我接收到了！\");\n        writer.write(\"<h1>\" +\"名字：\"+ request.getParameter(\"name\") + \"</h1>\");\n        System.out.println(\"服务器发送数据成功！\");\n        writer.close();\n}\n```\n\n### HttpServletResponse接口\n\n基本概念\n\njavax.servlet.http.HttpServletResponse接口继承ServletResponse接口，以便在发送响应时提供特定于HTTP的功能。\n\n**常用方法**\n\nvoid sendRedirect(String location)   使用指定的重定向位置URL向客户端发送临时重定向响应\n\n### 重定向和转发\n\n**重定向的概述** \n\n重定向的概念\n\n首先客户浏览器发送http请求，当web服务器接受后发送302状态码响应及对应新的location给客户浏览器，客户浏览器发现是302响应，则自动再发送一个新的http请求，请求url是新的location 地址，服务器根据此请求寻找资源并发送给客户。 \n\n重定向的实现\n\n实现重定向需要借助javax.servlet.http.HttpServletResponse接口中的以下方法：\n\nvoid sendRedirect(String location)\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>重定向的测试</title>\n</head>\n<body>\n<form action=\"redirectServlet\" method=\"post\">\n    <input type=\"submit\" value=\"重定向\"/>\n</form>\n</body>\n</html>\n```\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>重定向后的页面</title>\n</head>\n<body>\n<h1>服务器重新指定位置后的页面</h1>\n</body>\n</html>\n```\n\n```java\n@WebServlet(\"/redirectServlet\")\npublic class RedirectServlet extends HttpServlet {\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws IOException {\n        System.out.println(\"接收到了浏览器的请求...\");\n        // 重定向，也就是给浏览器发送一个新的位置\n        resp.sendRedirect(\"target.html\");\n        //response.sendRedirect(\"www.aobayu.cn\");\n    }\n\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException {\n        this.doPost(req, resp);\n    }\n}\n```\n\n重定向的特点\n\n- 重定向之后，浏览器地址栏的URL会发生改变。 \n\n- 重定向过程中会将前面Request对象销毁，然后创建一个新的Request对象。 \n\n- 重定向的URL可以是其它项目工程。\n\n**转发的概述**\n\n转发的概念\n\n一个Web组件（Servlet/JSP）将未完成的处理通过容器转交给另外一个Web组件继续处理，转发 的各个组件会共享Request和Response对象。\n\n转发的实现\n\n绑定数据到Request对象\n\n**Object getAttribute(String name)** 将指定属性值作为对象返回，若给定名称属性不存在，则返回空值 \n\n**void setAttribute(String name,Object o)**  在此请求中存储属性值\n\n获取转发器对象\n\n**RequestDispatcher getRequestDispatcher(String path)**\t返回一个RequestDispatcher对象，该对象充当位于给定路径上的资源的包装器\n\n转发操作\n\n**void forward(ServletRequest request, ServletResponse response)**\t将请求从一个servlet转发到服务器上的另一个资源（Servlet、JSP文件或HTML文件）\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>转发的测试</title>\n</head>\n<body>\n<form action=\"forwardServlet\" method=\"post\">\n    <input type=\"submit\" value=\"转发\"/>\n</form>\n</body>\n</html>\n```\n\n```java\n@WebServlet(\"/forwardServlet\")\npublic class ForwardServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        this.doPost(req, resp);\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        System.out.println(\"接收到了浏览器的请求...\");\n        // 向request对象中设置属性信息\n        req.setAttribute(\"key1\", \"value1\");\n        // 转发，也就是让Web组件将任务转交给另外一个Web组件\n        RequestDispatcher requestDispatcher = req.getRequestDispatcher(\"/targetServlet\");\n\n        requestDispatcher.forward(req, resp);\n    }\n}\n```\n\n```java\n@WebServlet(\"/targetServlet\")\npublic class TargetServlet extends HelloServlet{\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        this.doPost(request, response);\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws IOException {\n        System.out.println(\"转发过来了...\");\n        // 获取request对象中的属性值判断是否共享\n        Object key1 = req.getAttribute(\"key1\");\n        System.out.println(\"获取到的属性值为：\" + key1);// value1\n        // 通过打印流向页面写入转发成功的信息\n        resp.setContentType(\"text/html;charset=utf-8\");\n        resp.getWriter().write(\"<h1>转发成功！</h1>\");\n    }\n}\n```\n\n转发的特点\n\n- 转发之后浏览器地址栏的URL不会发生改变。\n\n- 转发过程中共享Request对象。 \n\n- 转发的URL不可以是其它项目工程。\n\n### Servlet接收中文乱码\n\n**接收乱码原因**\n\n浏览器在提交表单时，会对中文参数值进行自动编码。当Tomcat服务器接收到浏览器请求后自动 解码，当编码与解码方式不一致时,就会导致乱码。 \n\n**解决POST接收乱码**\n\n```Java\n//接收之前设置编码方式： \nrequest.setCharacterEncoding(\"utf-8\") \n//提示：必须在调用request.getParameter(\"name\")之前设置\n```\n\n **解决GET接收乱码**\n\n```Java\n// 将接收到的中文乱码重新编码: \n// 接收到get请求的中文字符串 \nString name = request.getParameter(\"name\"); \n// 将中文字符重新编码，默认编码为ISO-8859-1 \nString userName = new String(name.getBytes(\"ISO-8859-1\"),\"utf-8\");\n```\n\n## Cookie、Session\n\n### 会话\n\n**会话**：用户打开一个浏览器，点击了很多超链接，访问多个web资源，关闭浏览器，这个过程可以称之为会话；\n\n**有状态会话**：一个同学来过教室，下次再来教室，我们会知道这个同学，曾经来过，称之为有状态会话；\n\n**你能怎么证明你是学生？**\n\n1. 学生证书\n2. 学校登记，你来过了\n\n**一个网站，怎么证明你来过？**\n\n客户端 服务端\n\n1. 服务端给客户端一个 信件，客户端下次访问服务端带上信件就可以了； cookie\n2. 服务器登记你来过了，下次你来的时候我来匹配你； seesion\n\n**状态管理**\n\nWeb程序基于HTTP协议通信，而HTTP协议是”无状态”的协议，一旦服务器响应完客户的请求之 后，就断开连接，而同一个客户的下一次请求又会重新建立网络连接。 \n\n服务器程序有时是需要判断是否为同一个客户发出的请求，比如客户的多次选购商品。因此，有必 要跟踪同一个客户发出的一系列请求。\n\n把浏览器与服务器之间多次交互作为一个整体，将多次交互所涉及的数据保存下来，即状态管理。\n\n多次交互的数据状态可以在客户端保存，也可以在服务器端保存。状态管理主要分为以下两类： \n\n**客户端管理**：将状态保存在客户端。基于Cookie技术实现。\n\n **服务器管理**：将状态保存在服务器端。基于Session技术实现。\n\n### 保存会话的两种技术\n\n**cookie**\n\n- 客户端技术 （响应，请求）\n\n**session**\n\n- 服务器技术，利用这个技术，可以保存用户的会话信息？ 我们可以把信息或者数据放在Session中！\n\n常见常见：网站登录之后，你下次不用再登录了，第二次访问直接就上去了！\n\n### Cookie技术\n\n- Cookie本意为”饼干“的含义，在这里表示客户端以“名-值”形式进行保存的一种技术。\n\n- 浏览器向服务器发送请求时，服务器将数据以Set-Cookie消息头的方式响应给浏览器，然后浏览器 会将这些数据以文本文件的方式保存起来。\n\n- 当浏览器再次访问服务器时，会将这些数据以Cookie消息头的方式发送给服务器。\n\n### Cookie的方法\n\n使用javax.servlet.http.Cookie类的构造方法实现Cookie的创建。\n\n| 方法声明                          | 功能介绍                 |\n| --------------------------------- | ------------------------ |\n| Cookie(String name, String value) | 根据参数指定数值构造对象 |\n\n使用javax.servlet.http.HttpServletResponse接口的成员方法实现Cookie的添加。\n\n| 方法声明                      | 功能介绍                 |\n| ----------------------------- | ------------------------ |\n| void addCookie(Cookie cookie) | 添加参数指定的对象到响应 |\n\n```java\n@WebServlet(name = \"CookieServlet\", urlPatterns = \"/cookie\")\npublic class CookieServlet extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        // 1.测试一下浏览器的请求是否到达\n        System.out.println(\"看看有没有执行到这里哦！\");\n        // 2.创建Cookie对象并添加到响应信息中\n        Cookie cookie = new Cookie(\"name\", \"zhangfei\");\n        response.addCookie(cookie);\n        System.out.println(\"创建Cookie成功！\");\n    }\n\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        this.doPost(request, response);\n    }\n}\n```\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>测试</title>\n</head>\n<body>\n<form action=\"cookie\" method=\"post\">\n    <input type=\"submit\" value=\"测试cookie\"/>\n</form>\n</body>\n</html>\n```\n\n> 使用javax.servlet.http.HttpServletRequest接口的成员方法实现Cookie对象的获取。\n\n| 方法声明              | 功能介绍                         |\n| --------------------- | -------------------------------- |\n| Cookie[] getCookies() | 返回此请求中包含的所有Cookie对象 |\n\n```java\n@WebServlet(name = \"CookieServlet2\", urlPatterns = \"/cookie2\")\n    public class CookieServlet2 extends HttpServlet {\n        protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n            // 1.获取客户端发来的Cookie信息并打印出来\n            Cookie[] cookies = request.getCookies();\n            System.out.println(\"获取到的Cookie信息有：\");\n            for (Cookie tc : cookies) {\n                System.out.println(tc.getName() + \"对应的值为：\" + tc.getValue());\n            }\n        }\n\n        protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n            this.doPost(request, response);\n        }\n```\n\n> 使用javax.servlet.http.Cookie类的构造方法实现Cookie对象中属性的获取和修改。\n\n| 方法声明                       | 功能介绍                 |\n| ------------------------------ | ------------------------ |\n| String getName()               | 返回此Cookie对象中的名字 |\n| String getValue()              | 返回此Cookie对象的数值   |\n| void setValue(String newValue) | 设置Cookie的数值         |\n\n```java\n@WebServlet(name = \"CookieServlet3\", urlPatterns = \"/cookie3\")\npublic class CookieServlet3 extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n            // 1.获取客户端发来的Cookie信息并打印出来\n            Cookie[] cookies = request.getCookies();\n            for (Cookie tc : cookies) {\n                // 2.当获取到的Cookie对象的名字为name时，将对应的数值修改为guanyu并添加到响应信息中\n                if (\"name\".equalsIgnoreCase(tc.getName())) {\n                    tc.setValue(\"guanyu\");\n                    response.addCookie(tc);\n                    break;\n                }\n            }\n            System.out.println(\"修改Cookie信息成功！\");\n    }\n\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n            this.doPost(request, response);\n        }\n\t}\n```\n\n### Cookie的生命周期\n\n- 默认情况下，浏览器会将Cookie信息保存在内存中，只要浏览器关闭，Cookie信息就会消失。\n\n- 如果希望关闭浏览器后Cookie信息仍有效，可以通过Cookie类的成员方法实现。\n\n| 方法声明                   | 功能介绍                               |\n| -------------------------- | -------------------------------------- |\n| int getMaxAge()            | 返回cookie的最长使用期限（以秒为单位） |\n| void setMaxAge(int expiry) | 设置cookie的最长保留时间（秒）         |\n\n```java\n@WebServlet(name = \"CookieServlet4\", urlPatterns = \"/cookie4\")\n    public class CookieServlet4 extends HttpServlet {\n        protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n            // 1.创建Cookie信息\n            Cookie cookie = new Cookie(\"name\", \"liubei\");\n            // 2.获取Cookie信息的默认使用期限\n            int maxAge = cookie.getMaxAge();\n            System.out.println(\"该Cookie的默认使用期限是：\" + maxAge);\n            // 3.修改Cookie信息的使用期限\n            // 正数表示在指定的秒数后失效   负数表示浏览器关闭后失效   0表示马上失效\n            //cookie.setMaxAge(0);\n            cookie.setMaxAge(60*10);\n            // 4.添加到响应信息中\n            response.addCookie(cookie);\n            System.out.println(\"设置Cookie的生命周期成功！\");\n        }\n\n        protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n            this.doPost(request, response);\n        }\n    }\n```\n\n> cookie存中文会报错，因此可以使用url编码\n\n```java\n@Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        //发送Cookie\n        String value = \"张飞\";\n        //对中文进行URL编码\n        value = URLEncoder.encode(value, \"UTF-8\");\n        System.out.println(\"存储数据：\"+value);\n        //将编码后的值存入Cookie中\n        Cookie cookie = new Cookie(\"username\",value);\n        //设置存活时间   ，1周 7天\n        cookie.setMaxAge(60*60*24*7);\n        //2. 发送Cookie，response\n        response.addCookie(cookie);\n    }\n```\n\n> 解码使用\n\n```java\n@Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        //获取Cookie\n        //1. 获取Cookie数组\n        Cookie[] cookies = request.getCookies();\n        //2. 遍历数组\n        for (Cookie cookie : cookies) {\n            //3. 获取数据\n            String name = cookie.getName();\n            if(\"username\".equals(name)){\n                String value = cookie.getValue();//获取的是URL编码后的值 %E5%BC%A0%E4%B8%89\n                //URL解码\n                value = URLDecoder.decode(value,\"UTF-8\");\n                System.out.println(name+\":\"+value);//value解码后为 张飞\n                break;\n            }\n        }\n    }\n```\n\n### Cookie的特点\n\nCookie技术不适合存储所有数据，程序员只用于存储少量、非敏感信息，原因如下：\n\n- 将状态数据保存在浏览器端，不安全。\n\n- 保存数据量有限制，大约4KB左右。\n\n- 只能保存字符串信息。\n\n- 可以通过浏览器设置为禁止使用。\n\n### Session技术\n\n- Session本意为\"会话\"的含义，是用来维护一个客户端和服务器关联的一种技术。\n\n- 浏览器访问服务器时，服务器会为每一个浏览器都在服务器端的内存中分配一个空间，用于创建一个Session对象，该对象有一个id属性且该值唯一，我们称为SessionId，并且服务器会将这个SessionId以Cookie方式发送给浏览器存储。\n\n- 浏览器再次访问服务器时会将SessionId发送给服务器，服务器可以依据SessionId查找相对应的Session对象\n\n**什么是Session**\n\n- 服务器会给每一个用户（浏览器）创建一个Seesion对象；\n- 一个Seesion独占一个浏览器，只要浏览器没有关闭，这个Session就存在；\n- 用户登录之后，整个网站它都可以访问！--> 保存用户的信息；保存购物车的信息…..\n\n### Session的方法\n\n使用javax.servlet.http.HttpServletRequest接口的成员方法实现Session的获取。\n\n| 方法声明                 | 功能介绍                                            |\n| ------------------------ | --------------------------------------------------- |\n| HttpSession getSession() | 返回此请求关联的当前Session，若此请求没有则创建一个 |\n\n使用javax.servlet.http.HttpSession接口的成员方法实现判断和获取\n\n| 方法声明        | 功能介绍                  |\n| --------------- | ------------------------- |\n| boolean isNew() | 判断是否为新创建的Session |\n| String getId()  | 获取Session的编号         |\n\n```java\n@WebServlet(name = \"SessionServlet\", urlPatterns = \"/session\")\npublic class SessionServlet extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        // 1.调用getSession方法获取或者创建Session对象\n        HttpSession session = request.getSession();\n        // 2.判断该Session对象是否为新建的对象\n        System.out.println(session.isNew()? \"新创建的Session对象\": \"已有的Session对象\");\n        // 3.获取编号并打印\n        String id = session.getId();\n        System.out.println(\"获取到的Session编号为：\" + id);\n    }\n\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n    \tthis.doPost(request, response);\n    }\n}\n```\n\n> 使用javax.servlet.http.HttpSession接口的成员方法实现属性的管理。\n\n| 方法声明                                     | 功能介绍                                                     |\n| -------------------------------------------- | ------------------------------------------------------------ |\n| Object getAttribute(String name)             | 返回在此会话中用指定名称绑定的对象，如果没有对象在该名称下绑定，则返回空值 |\n| void setAttribute(String name, Object value) | 使用指定的名称将对象绑定到此会话                             |\n| void removeAttribute(String name)            | 从此会话中删除与指定名称绑定的对象                           |\n\n```java\n@WebServlet(name = \"SessionServlet2\", urlPatterns = \"/session2\")\npublic class SessionServlet2 extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        HttpSession session = request.getSession();\n        // 1.设置属性名和属性值\n        session.setAttribute(\"name\", \"machao\");\n        // 2.获取指定属性名对应的属性值\n        System.out.println(\"获取到的属性值为：\" + session.getAttribute(\"name\")); // machao\n        // 3.删除指定的属性名\n        session.removeAttribute(\"name\");\n        // 4.获取指定属性名对应的属性值\n        System.out.println(\"获取到的属性值为：\" + session.getAttribute(\"name\")); // null\n    }\n\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n    \tthis.doPost(request, response);\n    }\n}\n```\n\n> 可以配置web.xml文件修改失效时间。\n\n```xml\n<session-config>\n        <session-timeout>30</session-timeout>\n</session-config>\n```\n\n### Session的特点\n\n- 数据比较安全。\n- 能够保存的数据类型丰富，而Cookie只能保存字符串。\n- 能够保存更多的数据，而Cookie大约保存4KB。\n- 数据保存在服务器端会占用服务器的内存空间，如果存储信息过多、用户量过大，会严重影响服务器的性能。\n\n使用场景：\n\n- 保存一个登录用户的信息；\n- 购物车信息；\n- 在整个网站中经常会使用的数据，我们将它保存在Session中；\n\n### Session和cookie的区别\n\n- Cookie是把用户的数据写给用户的浏览器，浏览器保存 （可以保存多个）\n- Session把用户的数据写到用户独占Session中，服务器端保存 （保存重要的信息，减少服务器资源的浪费）\n- Session对象由服务创建；\n\n## JSP\n\n### 什么是JSP\n\nJava Server Pages ： Java服务器端页面，也和Servlet一样，用于动态Web技术！\n\nJSP是Java Server Pages的简称，跟Servlet一样可以动态生成HTML响应， JSP文件命名为xxx.jsp。\n\n与Servlet不同，JSP文件以HTML标记为主，然后内嵌Java代码段，用于处理动态内容。\n\n最大的特点：\n\n- 写JSP就像在写HTML\n- 区别：\n  - HTML只给用户提供静态的数据\n  - JSP页面中可以嵌入JAVA代码，为用户提供动态数据；\n\n**浏览器向服务器发送请求，不管访问什么资源，其实都是在访问Servlet！**\n\nJSP最终也会被转换成为一个Java类！**JSP 本质上就是一个Servlet！**\n\n```jsp\n<%@ page import=\"java.util.Date\" %> \n\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %> \n\n<html> \n<head> \n\t<title>Hello Time</title>\n</head> \n<body> \n现在的时间是：<%= new Date()%> \n</body> \n</html>\n```\n\n只要是 JAVA代码就会原封不动的输出；\n\n如果是HTML代码，就会被转换为：\n\n```java\nout.write(\"<html>\\r\\n\");\n```\n\n这样的格式，输出到前端！\n\n### JSP语法\n\n**<%! 程序代码区 %>||<% %>**\n\n```jsp\n<%!\n    int i; \n\tpublic void setName(){}\n%>\n\n<%\n    int sum = 0;\n\tfor (int i = 1; i <=100 ; i++) {\n      sum+=i;\n    }\n\tout.println(\"<h1>Sum=\"+sum+\"</h1>\");\n%>\n```\n\n程序代码区：可以定义局部变量以及放入任何的Java程序代码。\n\n**<%= %>**\n\n```jsp\n<%=\"hello world\"%> \n```\n\n注意：不需要以;结束，只有一行\n\n可以输出一个变量或一个具体内容，但=后面必须是字符串变量或者可以被转换成字符串的表达式。\t\n\n**注释**\n\n```jsp\n<!--… …-->HTML文件的注释，浏览器可以查看到\n<%--… …--%>JSP文件的注释，浏览器看不到\n<%//… …%>Java语言中的单行注释，浏览器看不到\n<%/*… …*/%>Java语言中的多行注释，浏览器看不到 注释的内容不会被执行\n```\n\n**JSP指令**\n\n**page**指令用于导包和设置一些页面属性，常用属性如下：\n\nimport\t\t          导入相应的包，惟一允许在同一文档中多次出现的属性\n\ncontentType\t\t设置Content-Type响应报头，标明即将发送到浏览器的文档类型\n\npageEncoding\t 设置页面的编码\n\nlanguage \t\t     指定页面使用的语言 \n\n```jsp\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" pageEncoding=\"utf-8\" %>\n\n<%@include file=\"\"%>\n<%--@include会将两个页面合二为一--%>\n\n<%@include file=\"common/header.jsp\"%>\n<h1>网页主体</h1>\n\n<%@include file=\"common/footer.jsp\"%>\n\n<hr>\n\n<%--jSP标签 jsp:include：拼接页面，本质还是三个 --%>\n<jsp:include page=\"/common/header.jsp\"/>\n<h1>网页主体</h1>\n<jsp:include page=\"/common/footer.jsp\"/>\n```\n\n### 内置对象\n\n在JSP程序中有9个内置对象由容器为用户进行实例化，程序员可以不用定义就直接使用这些变量。\n\n在JSP转换成Servlet后，会自动追加这些变量的定义，使用内置对象可以简化JSP的开发。\n\n| 对象变量    | 对象类型            | 作用             |\n| ----------- | ------------------- | ---------------- |\n| out         | JSPWriter           | 输出流           |\n| request     | HttpServletRequest  | 请求信息         |\n| response    | HttpServletResponse | 响应信息         |\n| session     | HttpSession         | 会话             |\n| application | ServletContext      | 全局的上下文对象 |\n| pageContext | PageContext         | JSP页面上下文    |\n| page        | Object              | JSP页面本身      |\n| config      | ServletConfig       | Servlet配管对象  |\n| exception   | Throwable           | 捕获网页异常     |\n\nrequest：客户端向服务器发送请求，产生的数据，用户看完就没用了，比如：新闻，用户看完没用的！\n\nsession：客户端向服务器发送请求，产生的数据，用户用完一会还有用，比如：购物车；\n\napplication：客户端向服务器发送请求，产生的数据，一个用户用完了，其他用户还可能使用，比如：聊天数据；\n\n```jsp\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n<html>\n<head>\n    <title>session内置对象的使用</title>\n</head>\n    <body>\n        <% session.setAttribute(\"name\",\"hd\");%>\n        <% session.getAttribute(\"name\");%>\n        ${name}\n    </body>\n</html>\n```\n\n### EL表达式\n\nEL（Expression Language）表达式提供了在JSP中简化表达式的方法，可以方便地访问各种数据并输出。\n\nEL表达式： ${ }获取数据、执行运算、获取web开发的常用对象\n\n**JSP标签**\n\n> 依次访问pageContext、request、session和application作用域对象存储的数据。\n\n```jsp\n<%=request.getAttribute(\"varName\")%>\n用EL实现: ${varName}\n```\n\n### **JSTL表达式**\n\nJSTL( JSP Standard Tag Library ) 被称为JSP标准标签库。\n\n开发人员可以利用这些标签取代JSP页面上的Java代码，从而提高程序的可读性，降低程序的维护难度。\n\nJSTL标签库的使用就是为了弥补HTML标签的不足；它自定义许多标签，可以供我们使用，标签的功能和Java代码一样！\n\n**JSTL标签库使用步骤**\n\n- 引入对应的 taglib\n- 使用其中的方法\n- **在Tomcat 也需要引入 jstl的包，否则会报错：JSTL解析错误**\n\npom.xml\n\n```xml\n<dependency>\n    <groupId>jstl</groupId>\n    <artifactId>jstl</artifactId>\n    <version>1.2</version>\n</dependency>\n<dependency>\n    <groupId>apache-taglibs</groupId>\n    <artifactId>standard</artifactId>\n    <version>1.1.2</version>\n</dependency>\n```\n\n在JSP页面中使用taglib指定引入jstl标签库\n\n```jsp\n<!-- prefix属性用于指定库前缀 --> \n<!-- uri属性用于指定库的标识 --> \n<%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %>\n```\n\n> 输出标签\n\n```jsp\n<c:out></c:out> 用来将指定内容输出的标签\n```\n\n> 设置标签\n\n```jsp\n<c:set></c:set> 用来设置属性范围值的标签\n```\n\n> 删除标签\n\n```jsp\n<c:remove></c:remove> 用来删除指定数据的标签\n```\n\n> 单条件判断标签\n\n```jsp\n<c:if test =\"EL条件表达式\"> \n\n满足条件执行 \n\n</c:if >\n\n<head>\n    <title>Title</title>\n</head>\n<body>\n\n\n<h4>if测试</h4>\n\n<hr>\n\n<form action=\"coreif.jsp\" method=\"get\">\n    <%--\n    EL表达式获取表单中的数据\n    ${param.参数名}\n    --%>\n    <input type=\"text\" name=\"username\" value=\"${param.username}\">\n    <input type=\"submit\" value=\"登录\">\n</form>\n\n<%--判断如果提交的用户名是管理员，则登录成功--%>\n<c:if test=\"${param.username=='admin'}\" var=\"isAdmin\">\n    <c:out value=\"管理员欢迎您！\"></c:out>\n</c:if>\n\n<%--自闭合标签--%>\n<c:out value=\"${isAdmin}\"/>\n\n</body>\n```\n\n> 多条件判断标签\n\n```jsp\n<c:choose > \n\n\t<c:when test =\"EL表达式\"> \n\n\t\t满足条件执行 \n\n\t</c:when> \n\n\t…\n\n\t<c:otherwise>\n\n\t\t不满足上述when条件时执行 \n\n\t</c:otherwise>\n\n</c:choose >\n\n<body>\n\n<%--定义一个变量score，值为85--%>\n<c:set var=\"score\" value=\"55\"/>\n\n<c:choose>\n    <c:when test=\"${score>=90}\">\n        你的成绩为优秀\n    </c:when>\n    <c:when test=\"${score>=80}\">\n        你的成绩为一般\n    </c:when>\n    <c:when test=\"${score>=70}\">\n        你的成绩为良好\n    </c:when>\n    <c:when test=\"${score>=60}\">\n        你的成绩为次\n    </c:when>\n    <c:otherwise>\n\t\t<c:out value=\"成绩不及格\"></c:out><br>\n\t</c:otherwise>\n</c:choose>\n\n</body>\n```\n\n> 循环标签\n\n```jsp\n<c:forEach var=\"循环变量\" items=\"集合\"> \n\n\t… \n\n</c:forEach>\n\n<%\n\n    ArrayList<String> people = new ArrayList<>();\n    people.add(0,\"张三\");\n    people.add(1,\"李四\");\n    people.add(2,\"王五\");\n    people.add(3,\"赵六\");\n    people.add(4,\"田六\");\n    request.setAttribute(\"list\",people);\n%>\n\n\n<%--\nvar , 每一次遍历出来的变量\nitems, 要遍历的对象\nbegin,   哪里开始\nend,     到哪里\nstep,   步长\n--%>\n<c:forEach var=\"people\" items=\"${list}\">\n    <c:out value=\"${people}\"/><br>\n</c:forEach>\n\n<hr>\n<%-- 指定起始和结尾位置 从下标1开始到3结束，包含1和3 跳跃性遍历 间隔为1--%>\n<c:forEach var=\"people\" items=\"${list}\" begin=\"1\" end=\"3\" step=\"1\" >\n    <c:out value=\"${people}\"/><br>\n</c:forEach>\n```\n\n> 实现循环标签的使用\n\n```jsp\n<%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %>\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n<html>\n<head>\n  <title>实现循环标签的使用</title>\n</head>\n<body>\n<%\n  // 准备一个数组并初始化\n  String[] sArr = {\"11\", \"22\", \"33\", \"44\", \"55\"};\n  pageContext.setAttribute(\"sArr\", sArr);\n%>\n\n<%-- 使用循环标签遍历数组中的所有元素 --%>\n<c:forEach var=\"ts\" items=\"${sArr}\">\n  <c:out value=\"${ts}\"></c:out>\n</c:forEach>\n<hr/>\n\n<%-- 跳跃性遍历 间隔为2  也就是跳过一个遍历一个 --%>\n<c:forEach var=\"ts\" items=\"${sArr}\" step=\"2\">\n  <c:out value=\"${ts}\"></c:out>\n</c:forEach>\n<hr/>\n\n<%-- 指定起始和结尾位置 从下标1开始到3结束，包含1和3--%>\n<c:forEach var=\"ts\" items=\"${sArr}\" begin=\"1\" end=\"3\">\n  <c:out value=\"${ts}\"></c:out>\n</c:forEach>\n\n</body>\n</html>\n```\n\n> 实现choose标签的使用\n\n```jsp\n<%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %>\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n<html>\n<head>\n  <title>实现choose标签的使用</title>\n</head>\n<body>\n<%-- 设置一个变量代表考试的成绩并指定数值 --%>\n<c:set var=\"score\" value=\"59\" scope=\"page\"></c:set>\n<c:out value=\"${score}\"></c:out>\n<hr/>\n<%-- 进行多条件判断和处理 --%>\n<c:choose>\n  <c:when test=\"${score > 60}\">\n    <c:out value=\"成绩不错，继续加油哦！\"></c:out>\n  </c:when>\n  <c:when test=\"${score == 60}\">\n    <c:out value=\"60分万岁，多一份浪费！\"></c:out>\n  </c:when>\n  <c:otherwise>\n    <c:out value=\"革命尚未成功，同志仍需努力！\"></c:out>\n  </c:otherwise>\n</c:choose>\n</body>\n</html>\n```\n\n> 实现if标签的使用\n\n```jsp\n<%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %>\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n<html>\n<head>\n  <title>实现if标签的使用</title>\n</head>\n<body>\n<%-- 设置一个变量以及对应的数值 --%>\n<c:set var=\"age\" value=\"17\" scope=\"page\"></c:set>\n<c:out value=\"${age}\"></c:out>\n<hr/>\n\n<%-- 判断该年龄是否成年，若成年则提示已经成年了 --%>\n<c:if test=\"${age >= 18}\">\n  <c:out value=\"已经成年了！\"></c:out>\n</c:if>\n\n</body>\n</html>\n```\n\n## Filter过滤器\n\n**基本概念**\n\n- Filter本意为”过滤“的含义，是JavaWeb的三大组件之一，三大组件为： Servlet、 Filter、 Listener。\n\n- 过滤器是向 Web 应用程序的请求和响应处理添加功能的 Web 服务组件。\n\n- 过滤器相当于浏览器与Web资源之间的一道过滤网，在访问资源之前通过一系列的过滤器对请求 进行修改、判断以及拦截等，也可以对响应进行修改、判断以及拦截等。\n\n### 使用方式\n\n自定义类实现Filter接口，重写对应的方法即可\n\n```java\npublic class CharacterEncodingFilter implements Filter {\n\n    //初始化：web服务器启动，就以及初始化了，随时等待过滤对象出现！\n    public void init(FilterConfig filterConfig) throws ServletException {\n        System.out.println(\"CharacterEncodingFilter初始化\");\n    }\n\n    //Chain : 链\n    /*\n    1. 过滤中的所有代码，在过滤特定请求的时候都会执行\n    2. 必须要让过滤器继续同行\n        chain.doFilter(request,response);\n     */\n    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n        request.setCharacterEncoding(\"utf-8\");\n        response.setCharacterEncoding(\"utf-8\");\n        response.setContentType(\"text/html;charset=UTF-8\");\n\n        System.out.println(\"CharacterEncodingFilter执行前....\");\n        chain.doFilter(request,response); //让我们的请求继续走，如果不写，程序到这里就被拦截停止！\n        System.out.println(\"CharacterEncodingFilter执行后....\");\n    }\n\n    //销毁：web服务器关闭的时候，过滤会销毁\n    public void destroy() {\n        System.out.println(\"CharacterEncodingFilter销毁\");\n    }\n}\n```\n\n在web.xml中配置 Filter\n\n```xml\n<filter>\n    <filter-name>CharacterEncodingFilter</filter-name>\n    <filter-class>com.aaa.filter.CharacterEncodingFilter</filter-class>\n</filter>\n<filter-mapping>\n    <filter-name>CharacterEncodingFilter</filter-name>\n    <!--只要是 /servlet的任何请求，会经过这个过滤器-->\n    <url-pattern>/servlet</url-pattern>\n    <!--<url-pattern>/*</url-pattern>-->\n</filter-mapping>\n```\n\n### 登录案例\n\n在web.xml文件中配置过滤器\n\n```xml\n\t<filter>\n        <filter-name>LoginFilter</filter-name>\n        <filter-class>com.aobayu.demo.aaa.LoginFilter</filter-class>\n    </filter>\n    <filter-mapping>\n        <filter-name>LoginFilter</filter-name>\n        <!--只要是任何请求，会经过这个过滤器-->\n        <url-pattern>/*</url-pattern>\n        <!--<url-pattern>/*</url-pattern>-->\n    </filter-mapping>\n```\n\nlogin.jsp\n\n```jsp\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n<html>\n<head>\n    <title>登录页面</title>\n</head>\n<body>\n\n  <form action=\"login\" method=\"post\">\n  用户名: <input type=\"text\" name=\"userName\"/><br/>\n  密&nbsp;&nbsp;&nbsp;&nbsp;码:<input type=\"password\" name=\"password\"/><br/>\n  <input type=\"submit\" value=\"登录\"/>\n  </form>\n\n</body>\n</html>\n```\n\nmain.jsp\n\n```jsp\n<%@ page import=\"java.util.Date\" %>\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" pageEncoding=\"utf-8\" %>\n<html>\n<head>\n  <title>主页面</title>\n</head>\n<body>\n现在的时间是：<%= new Date()%>\n\n<h1>登录成功，欢迎${sessionScope.userName}使用！</h1>\n\n</body>\n</html>\n```\n\n点击登录到 LoginServlet\n\n```java\n@WebServlet(\"/login\")\npublic class LoginServlet extends HttpServlet {\n\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        this.doPost(req, resp);\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        // 1.接收前端页面输入的用户名和密码信息并打印\n        String userName = req.getParameter(\"userName\");\n        System.out.println(\"接收到的用户名为：\" + userName);\n        String password = req.getParameter(\"password\");\n        System.out.println(\"接收到的密码为：\" + password);\n        // 2.使用固定的用户名和密码信息来进行登录的校验\n        if (\"admin\".equals(userName) && \"123456\".equals(password)) {\n            System.out.println(\"登录成功，欢迎使用！\");\n            // 存储用户名信息\n            req.getSession().setAttribute(\"userName\", userName);\n            //跳转到 main.jsp\n            resp.sendRedirect(\"main.jsp\");\n        } else {\n            System.out.println(\"用户名或密码错误，请重新输入！\");\n            req.getRequestDispatcher(\"login.jsp\").forward(req, resp);\n        }\n    }\n}\n```\n\n登录失败拦截 LoginFilter\n\n```java\n@WebFilter(\"/main.jsp\")\npublic class LoginFilter implements Filter {\n    @Override\n    public void init(FilterConfig filterConfig) throws ServletException {\n        System.out.println(\"Filter初始化\");\n    }\n\n    @Override\n    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {\n        // 1.实现对用户访问主页面的过滤操作，也就是只有用户登录后才能访问主页面，否则一律拦截\n        //判断session中是否已有用户名信息，若没有则进行拦截，否则放行\n        HttpServletRequest httpServletRequest = (HttpServletRequest)servletRequest;\n        HttpSession session = httpServletRequest.getSession();\n        Object userName = session.getAttribute(\"userName\");\n        // 获取Servlet的请求路径\n        String servletPath = httpServletRequest.getServletPath();\n        // 若没有登录，则回到登录页面\n        if (null == userName && !servletPath.contains(\"login\")) {\n            servletRequest.getRequestDispatcher(\"login.jsp\").forward(servletRequest, servletResponse);\n        } else {\n            // 若已经登录，则放行\n            filterChain.doFilter(servletRequest, servletResponse);\n        }\n\n    }\n\n    @Override\n    public void destroy() {\n        System.out.println(\"Filter销毁\");\n    }\n```\n\n## Listener监听器\n\n**概述**\n\n监听你的web应用，监听许多信息的初始化，销毁，增加，修改，删除值等\n\n`Servlet`监听器用于监听一些重要事件的发生，监听器对象可以在事情发生前、发生后可以做一些必要的处理 \n\n**监听器的分类：**\n\n在一个web应用程序的整个运行周期内，web容器会创建和销毁三个重要的对象，`ServletContext`,`HttpSession`,`ServletRequest`\n\n 按监听的对象划分，可以分为\n\n- ServletContext \n\n- HttpSession \n\n- ServletRequest  \n\n​    按监听的事件划分\n\n- 对象自身的创建和销毁的监听器\n\n- 对象中属性的创建和消除的监听器\n\n- session中的某个对象的状态变化的监听器\n\n### 创建监听器\n\n> ServletContext 监听\n\n`ServletContext` 代表整个web应用，在服务器启动的时候，tomcat会自动创建该对象。在服务器关闭时会自动销毁该对象\n\n```java\n@WebListener\npublic class MyContextListener implements ServletContextListener {\n        @Override\n        public void contextInitialized(ServletContextEvent servletContextEvent) {\n        //        获取到上下文对象\n        ServletContext application = servletContextEvent.getServletContext();\n        System.out.println(\"上下文初始化\"+application);\n        }\n    \n        @Override\n        public void contextDestroyed(ServletContextEvent servletContextEvent) {\n        System.out.println(\"上下文销毁\");\n        }\n}\n```\n\n或在xml中配置\n\n```xml\n<listener>\n\n\t<listener-class>监听器的全路径</listener-class>\n\n</listener>\n```\n\n> session监听\n\n```java\n@WebListener\npublic class MySessionListener implements HttpSessionListener {\n    /**\n    *\n    * @param httpSessionEvent 事件参数，可以获取到被监听对象的数据信息\n    */\n    @Override\n    public void sessionCreated(HttpSessionEvent httpSessionEvent) {\n    \tSystem.out.println(\"session创建\"+httpSessionEvent.getSession().getId());\n    }\n\n    @Override\n    public void sessionDestroyed(HttpSessionEvent httpSessionEvent) {\n    \tSystem.out.println(\"session销毁\"+httpSessionEvent.getSession());\n    }\n}\n```\n\n> session中属性监听\n\n```java\n@WebListener\npublic class MySessionAttributeListener implements HttpSessionAttributeListener {\n    @Override\n    public void attributeAdded(HttpSessionBindingEvent httpSessionBindingEvent) {\n    System.out.println(\"session属性添加：\"+httpSessionBindingEvent.getName());\n    }\n\n    @Override\n    public void attributeRemoved(HttpSessionBindingEvent httpSessionBindingEvent) {\n    System.out.println(\"session属性移除：\"+httpSessionBindingEvent.getName());\n    }\n\n    @Override\n    public void attributeReplaced(HttpSessionBindingEvent httpSessionBindingEvent) {\n    System.out.println(\"session属性替换：\"+httpSessionBindingEvent.getName());\n    }\n}\n```\n\n在线人数统计：\n\n1、先获取容器中的数量计数器，如果没有，创建存进去\n\n2、每创建一个session，计数器加1\n\n3、每销毁一个session,计数器减1\n\n```java\n@WebListener\npublic class OnlineListener implements ServletContextListener, HttpSessionListener {\n    ServletContext appliction;\n    @Override\n    public void contextInitialized(ServletContextEvent servletContextEvent) {\n        /* 当容器创建就获取上下文对象*/\n        appliction = servletContextEvent.getServletContext();\n        /* 是否有计数器 */\n        if(appliction.getAttribute(\"count\")==null){\n            /* 存进去，只执行一次 */\n            appliction.setAttribute(\"count\",0);\n        }\n    }\n\n    @Override\n    public void contextDestroyed(ServletContextEvent servletContextEvent) {\n    }\n\n    @Override\n    public void sessionCreated(HttpSessionEvent httpSessionEvent) {\n        /* 获取原来的计数器的值 */\n        Integer count=Integer.valueOf(appliction.getAttribute(\"count\").toString());\n        count++;\n        /* 存进去 */\n        appliction.setAttribute(\"count\",count);\n    }\n\n    @Override\n    public void sessionDestroyed(HttpSessionEvent httpSessionEvent) {\n    \tInteger count=Integer.valueOf(appliction.getAttribute(\"count\").toString());\n        count--;\n        appliction.setAttribute(\"count\",count);\n    }\n}\n```\n\n## JQuery异步调用\n\n**同步和异步**\n\n同步：同步请求，客户端发出请求，等待服务器端返回结果，接着进行下一次的请求。\n\n异步：异步请求，客户端发出请求，无需等待服务器端返回结果，接着进行下一次的请求。\n\n**Ajax简介**\n\nAjax 即“**Asynchronous Javascript And XML**”（异步 JavaScript 和 XML），是指一种创建交互式、快速动态网页应用的网页开发技术，无需重新加载整个网页的情况下，能够更新部分网页的技术。\n\n通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。\n\n原理：\n\n1、客户端发送异步请求\n\nXMLHttpRequest 对象\n\n2、服务器端接收请求，处理数据，通常返回json格式的数据，字符串（文本）\n\n3、客户端获取服务器返回的数据在页面上显示\n\n使用js ,jquery ,dom ,css\n\n### JQuery中的AJAX\n\n**简单使用**\n\n$.get\n\n```xml\n$.get(url,[data],[callback],[type])\nurl:待载入页面的URL地址  @WebServlet(\"/xxxxxxx\") get post\ndata:待发送 Key/value 参数。\ncallback:载入成功时回调函数。 接受 后端响应的数据\ntype:返回内容格式，xml, html, script, json, text, _default。\n```\n\n> 在webapp目录下创建static文件夹,在static下创建js,css,image三个文件夹,将jQuery的文件拷贝到js文件夹中\n\n在webapp下新建 webapp/register.jsp\n\n```jsp\n<%@ page contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\" %>\n<!DOCTYPE html>\n<html>\n<head>\n    <title>JSP - Hello World</title>\n    <script src=\"./static/js/jquery-3.6.0.js\"></script>\n    <script>\n        $(function(){\n            $(\"#dname\").on(\"blur\",function(){\n                $.get(\n                    \"/demo1/checkUsername\",\n                    {username:$(\"#dname\").val()},\n                    function(result){\n                        if(result==1){\n                            $(\"#usermsg\").html(\"<span style='color:red'>用户已存在<span>\");\n                        }else{\n                            $(\"#usermsg\").html(\"<span style='color:red'>true<span>\");\n                        }\n                    }\n                );\n            })\n        })\n    </script>\n</head>\n<body>\n\n<form action=\"/demo1/register\" method=\"post\" id=\"form\">\n    userName:<input name=\"username\" id=\"dname\" type=\"text\"/> <span id=\"usermsg\"></span><br>\n    password:<input name=\"pass\" type=\"password\"/><br>\n    <input type=\"button\"  id=\"btn\" value=\"register\">\n</form>\n\n</body>\n</html>\n```\n\n> 服务端Servlet 拿到username 查询数据库，如果可以查到，就返回1\n\n```java\n@WebServlet(\"/checkUsername\")\npublic class CheckUsernameServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        this.doPost(req, resp);\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        String user=req.getParameter(\"username\");\n\n        /*如果存在就返回1 否则0*/\n        if(\"heda\".equals(user)){\n            resp.getWriter().print(1);\n        }else{\n            resp.getWriter().print(0);\n        }\n    }\n}\n```\n\n### 查询数据库\n\n**前置准备**\n\npom.xml\n\n```xml\n//导入mysql jar包\t\t\n<dependency> \n    <groupId>mysql</groupId>\n    <artifactId>mysql-connector-java</artifactId>\n    <version>5.1.38</version>\n</dependency>\n//导入dbutils jar包\t\t\n<dependency>\n    <groupId>commons-dbutils</groupId>\n    <artifactId>commons-dbutils</artifactId>\n    <version>1.6</version>\n</dependency>\n//导入druid jar包\t\t\n<dependency>\n    <groupId>com.alibaba</groupId>\n    <artifactId>druid</artifactId>\n    <version>1.2.8</version>\n</dependency>\n```\n\nsrc/main/resources 编写好的druid.properties\n\n```java\ndriverClassName=com.mysql.jdbc.Driver\nurl=jdbc:mysql:///db5?useSSL=false&useServerPrepStmts=true&characterEncoding=utf-8\nusername=root\npassword=123456\ninitialSize=5\nmaxActive=10\nmaxWait=3000\n```\n\n在java.com.example.demo1目录下创建controller，dao，pojo，utils文件夹\n\n将DruidUtils 文件拷贝到utils文件夹中\n\n```java\npublic class DruidUtils {\n    public static DataSource dataSource;\n    static {\n        try {\n            Properties p = new Properties();\n            InputStream inputStream = DruidUtils.class.getClassLoader().getResourceAsStream(\"druid.properties\");\n            p.load(inputStream);\n            dataSource = DruidDataSourceFactory.createDataSource(p);\n        } catch (Exception e) {\n            e.printStackTrace();\n            throw new RuntimeException(e);\n        }\n    }\n    public static Connection getConnection(){\n        try {\n            return dataSource.getConnection();\n        } catch (SQLException e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n    public static void close(ResultSet resultSet){\n        try {\n            if (resultSet != null){\n                resultSet.close();\n            }\n        } catch (SQLException e) {\n            throw new RuntimeException(e);\n        }\n    }\n    public static void close(Statement statement){\n        try {\n            if (statement != null){\n                statement.close();\n            }\n        } catch (SQLException e) {\n            throw new RuntimeException(e);\n        }\n    }\n    public static void close(Connection connection){\n        try {\n            if (connection != null){\n                connection.close();\n            }\n        } catch (SQLException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public static void close(ResultSet resultSet,Statement statement,Connection connection){\n        close(resultSet);\n        close(statement);\n        close(connection);\n    }\n\n    public  static DataSource getDataSource(){\n        return dataSource;\n    }\n}\n```\n\n**实现查询数据库**\n\n新建数据库 cell ,存入用户数据\n\n在webapp下新建 register.jsp\n\n```jsp\n<%@ page contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\" %>\n<!DOCTYPE html>\n<html>\n<head>\n    <title>JSP</title>\n    <script src=\"./static/js/jquery-3.6.0.js\"></script>\n    <script>\n        $(function(){\n            $(\"#dname\").on(\"blur\",function(){\n                $.get(\n                    \"/demo1/checkUsername\",\n                    {username:$(\"#dname\").val()},\n                    function(result){\n                        if(result==1){\n                            $(\"#usermsg\").html(\"<span style='color:red'>用户已存在<span>\");\n                            console.log(\"用户已存在\");\n                        }else{\n                            $(\"#usermsg\").html(\"\");\n                        }\n                    }\n                );\n            })\n        })\n    </script>\n</head>\n<body>\n\n\n<form action=\"/demo1/register\" method=\"post\" id=\"form\">\n    userName:<input name=\"username\" id=\"dname\" type=\"text\"/> <span id=\"usermsg\"></span><br>\n    password:<input name=\"pass\" type=\"password\"/><br>\n    <input type=\"button\"  id=\"btn\" value=\"register\">\n</form>\n\n</body>\n</html>\n```\n\n在pojo下新建 Cell.java\n\n```java\npublic class Cell {\n    private String name;\n    private int money;\n    private String phone;\n\n    public Cell(){}\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getMoney() {\n        return money;\n    }\n\n    public void setMoney(int money) {\n        this.money = money;\n    }\n\n    public String getPhone() {\n        return phone;\n    }\n\n    public void setPhone(String phone) {\n        this.phone = phone;\n    }\n\n    @Override\n    public String toString() {\n        return \"Cell{\" +\n                \"name='\" + name + '\\'' +\n                \", money=\" + money +\n                \", phone='\" + phone + '\\'' +\n                '}';\n    }\n\n}\n```\n\n在dao下新建 CellDao.java\n\n```java\npublic interface CellDao {\n    long CellServlet(String name) throws SQLException;\n}\n```\n\n在dao下新建 impl/CellImplement.java\n\n```java\npublic class CellImplement implements CellDao {\n    @Override\n    public long CellServlet(String name) throws SQLException {\n        \n        QueryRunner qr = new QueryRunner(DruidUtils.getDataSource());\n        String sql = \"select * from cell where name = ?;\";\n        List<Cell> query = qr.query(sql, new BeanListHandler<>(Cell.class), name);\n\n        if (query.isEmpty()){\n            return 0;\n        }else {\n            return 1;\n        }\n    }\n}\n```\n\n在controller下新建 CheckUsernameServlet.java\n\n```java\n@WebServlet(\"/checkUsername\")\npublic class CheckUsernameServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        this.doPost(req, resp);\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        String user=req.getParameter(\"username\");\n        /* 通过dao层查询数据库，如果可以查到就通过如下代码返回1 否则返回0  */\n        CellDao cell = new CellImplement();\n        try {\n            long ruelt = cell.CellServlet(user);\n            /*如果存在就返回1 否则0*/\n            if (ruelt>0) {\n                resp.getWriter().print(1);\n            } else {\n                resp.getWriter().print(0);\n            }\n        } catch (SQLException e) {\n            throw new RuntimeException(e);\n        }\n    }\n}\n```\n\n### 插入数据到数据库\n\n在webapp下修改 register.jsp\n\n```jsp\n<%@ page contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\" %>\n<!DOCTYPE html>\n<html>\n<head>\n    <title>JSP - Hello World</title>\n    <script src=\"./static/js/jquery-3.6.0.js\"></script>\n    <script>\n        $(function(){\n            $(\"#dname\").on(\"blur\",function(){\n                $.get(\n                    \"/demo1/checkUsername\",\n                    {username:$(\"#dname\").val()},\n                    function(result){\n                        if(result==1){\n                            $(\"#usermsg\").html(\"<span style='color:red'>用户已存在<span>\");\n                            console.log(\"用户已存在\");\n                        }else{\n                            $(\"#usermsg\").html(\"\");\n                        }\n                    }\n                );\n            })\n            $(\"#btn\").click(function () {\n                $.post(\n                    \"/demo1/register\",\n                    //序列化，拿到所有的表单元素username password\n                    $(\"#form\").serialize(),\n                    function (result) {\n                        if(result==1){\n                            alert(\"插入成功\")\n                        }else{\n                            alert(\"插入失败\")\n                        }\n                    }\n                )\n            })\n        })\n    </script>\n</head>\n<body>\n\n<form action=\"/demo1/register\" method=\"post\" id=\"form\">\n    userName:<input name=\"username\" id=\"dname\" type=\"text\"/> <span id=\"usermsg\"></span><br>\n    money:<input name=\"money\" type=\"text\"/><br>\n    phone:<input name=\"phone\" type=\"text\"/><br>\n    <input type=\"button\"  id=\"btn\" value=\"register\">\n</form>\n\n</body>\n</html>\n```\n\n在dao下修改 CellDao.java\n\n```java\npublic interface CellDao {\n    long CellServlet(String name) throws SQLException;\n    long insertServlet(String name,int money,String phone) throws SQLException;\n}\n```\n\n在dao下修改 impl/CellImplement.java\n\n```java\npublic class CellImplement implements CellDao {\n    @Override\n    public long CellServlet(String name) throws SQLException {\n        QueryRunner qr = new QueryRunner(DruidUtils.getDataSource());\n        String sql = \"select * from cell where name = ?;\";\n        List<Cell> query = qr.query(sql, new BeanListHandler<>(Cell.class), name);\n\n        if (query.isEmpty()){\n            return 0;\n        }else {\n            return 1;\n        }\n    }\n    \n    @Override\n    public long insertServlet(String name, int money, String phone) throws SQLException {\n\n        QueryRunner qr = new QueryRunner(DruidUtils.getDataSource());\n        String sql = \"insert into cell(name,money,phone) values (?,?,?)\";\n        int update = qr.update(sql, name, money, phone);\n        System.out.println(update);\n        return update;\n    }\n}\n```\n\n在dao下新建 RegisterServlet.java\n\n```java\n@WebServlet(\"/register\")\npublic class RegisterServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        this.doPost(req, resp);\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        String name = req.getParameter(\"username\");\n        int money = Integer.parseInt(req.getParameter(\"money\"));\n        String phone = req.getParameter(\"phone\");\n        CellImplement cell = new CellImplement();\n        try {\n            long score = cell.insertServlet(name, money, phone);\n            if (score>0){\n                resp.getWriter().println(1);\n            }else{\n                resp.getWriter().println(0);\n            }\n        } catch (SQLException e) {\n            throw new RuntimeException(e);\n        }\n    }\n}\n```\n\n### 简单封装\n\n在java.com.example.demo1目录下创建service文件夹\n\n在service 下创建 CellService.java\n\n```java\npublic class CellService {\n    public long InsertCell( String name,int money,String phone) throws SQLException {\n        Cell cell = new Cell();\n        cell.setName(name);\n        cell.setMoney(money);\n        cell.setPhone(phone);\n        long row = new CellImplement().insertServlet(cell);\n        return row;\n    }\n}\n```\n\nCellDao 更改\n\n```java\npublic interface CellDao {\n    long CellServlet(String name) throws SQLException;\n    // 更改位置\n    long insertServlet(Cell cell) throws SQLException;\n}\n```\n\nCellImplement 更改\n\n```java\npublic class CellImplement implements CellDao {\n    @Override\n    public long CellServlet(String name) throws SQLException {\n        QueryRunner qr = new QueryRunner(DruidUtils.getDataSource());\n        String sql = \"select * from cell where name = ?;\";\n        List<Cell> query = qr.query(sql, new BeanListHandler<>(Cell.class), name);\n\n        if (query.isEmpty()){\n            return 0;\n        }else {\n            return 1;\n        }\n    }\n\t// 更改位置\n    @Override\n    public long insertServlet(Cell cell) throws SQLException {\n\n        QueryRunner qr = new QueryRunner(DruidUtils.getDataSource());\n        String sql = \"insert into cell(name,money,phone) values (?,?,?)\";\n        int update = qr.update(sql, cell.getName(), cell.getMoney(), cell.getPhone());\n        System.out.println(update);\n        return update;\n    }\n}\n```\n\nRegisterServlet.java 更改\n\n```java\n@WebServlet(\"/register\")\npublic class RegisterServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        this.doPost(req, resp);\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        String name = req.getParameter(\"username\");\n        int money = Integer.parseInt(req.getParameter(\"money\"));\n        String phone = req.getParameter(\"phone\");\n        // 更改位置\n        CellImplement cell = new CellImplement();\n        // 更改位置\n        try {\n            long score = new CellService().InsertCell(name, money, phone);\n            if (score>0){\n                resp.getWriter().println(1);\n            }else{\n                resp.getWriter().println(0);\n            }\n        } catch (SQLException e) {\n            throw new RuntimeException(e);\n        }\n    }\n}\n```\n\n## JSON \n\nJavaScript Object Notation JavaScript 对象表示法 \n\n> JSON的特点: \n\nJSON 是一种轻量级的数据交换格式。\n\nJSON采用完全独立于语言的文本格式，就是说不同的编程语言JSON数据是一致的。 \n\nJSON易于人阅读和编写，同时也易于机器解析和生成(一般用于提升网络传输速率)。\n\n> XML与JSON的区别\n\nXML : 可扩展标记语言，是一种用于标记电子文件使其具有结构性的标记语言。 \n\nJSON: (JavaScript Object Notation, JS 对象简谱) 是一种轻量级的数据交换格式。 \n\n相同点:  它们都可以作为一种数据交换格式。 \n\n> 二者区别:\n\nXML是重量级的，JSON是轻量级的,XML在传输过程中比较占带宽，JSON占带宽少，易于压 缩。 \n\nXML和json都用在项目交互下，XML多用于做配置文件，JSON用于数据交互 \n\nJSON独立于编程语言存在,任何编程语言都可以去解析json \n\n### JSON 基础语法\n\nJSON 本质就是一个字符串，但是该字符串内容是有一定的格式要求的。 定义格式 {\" key\": false }\n\n```json\nvar 变量名 = '{\"key\":value,\"key\":value,...}';\n```\n\n`JSON` 串的键要求必须使用双引号括起来，而值根据要表示的类型确定\n\n> 在前端页面中 转换JSON和字符串\n\n```html\n<script>\n//1. 定义JSON字符串\nvar jsonStr = '{\"name\":\"zhangsan\",\"age\":23,\"addr\":[\"北京\",\"郑州\",\"西安\"]}'\nlet jsObject = JSON.parse(jsonStr);\n//3. 将 JS 对象转换为 JSON 字符串\nlet jsonStr2 = JSON.stringify(jsObject);\n</script>\n```\n\n### JSON串和Java对象的转换\n\n前端发送请求时，如果是复杂的数据就会以 json 提交给后端；而后端如果需要响应一些复杂的数据时，也需要以 json 格式将数据响应回给浏览器\n\n> `Fastjson` 是阿里巴巴提供的一个Java语言编写的高性能功能完善的 `JSON` 库，是目前Java语言中最快的 `JSON` 库，可以实现 `Java` 对象和 `JSON` 字符串的相互转换。\n\n导入依赖 pom.xml\n\n```xml\n<dependency>\n    <groupId>com.alibaba</groupId>\n    <artifactId>fastjson</artifactId>\n    <version>1.2.62</version>\n</dependency>\n```\n\n使用 将 Java 对象转换为 JSON 串，只需要使用 `Fastjson` 提供的 `JSON` 类中的 `toJSONString()` 静态方法\n\n```java\nString jsonStr = JSON.toJSONString(obj);\n```\n\n将 json 转换为 Java 对象，只需要使用 Fastjson 提供的 JSON 类中的 parseObject() 静态方法\n\n```java\nString str = \"{'name'':'zhangxuhui','age':18 }\";\nStudent student = JSON.parseObject(jsonStr, Student.class);\n```\n\n> lombok插件\n\n在 Idea 中下载 lombok 插件\n\n通过 @JSONField 我们可以自定义字段的名称进行输出，并控制字段的排序，还可以进行序列化 标记。 \n\n指定name属性, 字段的名称 \n\n使用 ordinal属性, 指定字段的顺序 \n\n使用 serialize属性, 指定字段不序列化\n\n```java\n//lombok 插件完成set/get方法和toString方法\n@Data\n@ToString\npublic class Person {\n        //自定义输出的名称, 并且进行输出排序\n        @JSONField(name=\"USERNAME\",ordinal = 1)\n        private String username;\n        @JSONField(name=\"AGE\",ordinal = 2)\n        private int age;\n        //排除不需要序列化的字段\n        @JSONField(serialize = false)\n        private String birthday;\n}\n```\n\n> JSON 字符串转换为 Java 对象\n\n**JSON.parseObject()**\n\n- 可以使用 JSON.parseObject() 将 JSON 字符串转换为 Java 对象。\n\n- 注意反序列化时为对象时，必须要有默认无参的构造函数，否则会报异常\n\n**JSON.parseArray()**\n\n可以使用 JSON.parseArray() 将 JSON 字符串转换为 集合对象。\n\n```java\npublic void JSONToJavaBean() {\n        String json = \"{\\\"age\\\":15,\\\"birthday\\\":\\\"2022-10-03 19:54:33\\\",\\\"username\\\":\\\"heda\\\"}\";\n        Person person = JSON.parseObject(json, Person.class);\n        System.out.println(person);\n        //创建Person对象\n        String json2 = \"[{\\\"age\\\":15,\\\"birthday\\\":\\\"2022-10-03 19:59:05\\\",\\\"username\\\":\\\"heda\\\"},{\\\"age\\\":13,\\\"birthday\\\":\\\"2022-10-03 19:59:05\\\",\\\"username\\\":\\\"zy\\\"}]\";\n        List<Person> list = JSON.parseArray(json2, Person.class);\n        System.out.println(list);\n}\n```\n\n## layui框架\n\n使用流程，在layui官网下载 [Layui - 经典开源模块化前端 UI 组件库(官方开发文档)](http://layui.org.cn/index.html)\n\n将 layui 文件放入 webapp 文件夹中\n\n### layui框架效果\n\n在 webapp 下新建 layui.html\n\n在layui官网粘入框架代码并修改引入的 layui.js  和 layui.css 为自己的路径\n\n更改两处语句 实现点击 menu 1 加载http://cn.bing.com页面\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1, maximum-scale=1\">\n  <title>layout 管理系统大布局 - Layui</title>\n  <link rel=\"stylesheet\" href=\"./layui/css/layui.css\">\n</head>\n<body>\n<div class=\"layui-layout layui-layout-admin\">\n  <div class=\"layui-header\">\n    <div class=\"layui-logo layui-hide-xs layui-bg-black\">layout demo</div>\n    <!-- 头部区域（可配合layui 已有的水平导航） -->\n    <ul class=\"layui-nav layui-layout-left\">\n      <!-- 移动端显示 -->\n      <li class=\"layui-nav-item layui-show-xs-inline-block layui-hide-sm\" lay-header-event=\"menuLeft\">\n        <i class=\"layui-icon layui-icon-spread-left\"></i>\n      </li>\n\n      <li class=\"layui-nav-item layui-hide-xs\"><a href=\"\">nav 1</a></li>\n      <li class=\"layui-nav-item layui-hide-xs\"><a href=\"\">nav 2</a></li>\n      <li class=\"layui-nav-item layui-hide-xs\"><a href=\"\">nav 3</a></li>\n      <li class=\"layui-nav-item\">\n        <a href=\"javascript:;\">nav groups</a>\n        <dl class=\"layui-nav-child\">\n          <dd><a href=\"\">menu 11</a></dd>\n          <dd><a href=\"\">menu 22</a></dd>\n          <dd><a href=\"\">menu 33</a></dd>\n        </dl>\n      </li>\n    </ul>\n    <ul class=\"layui-nav layui-layout-right\">\n      <li class=\"layui-nav-item layui-hide layui-show-md-inline-block\">\n        <a href=\"javascript:;\">\n          <img src=\"//tva1.sinaimg.cn/crop.0.0.118.118.180/5db11ff4gw1e77d3nqrv8j203b03cweg.jpg\" class=\"layui-nav-img\">\n          tester\n        </a>\n        <dl class=\"layui-nav-child\">\n          <dd><a href=\"\">Your Profile</a></dd>\n          <dd><a href=\"\">Settings</a></dd>\n          <dd><a href=\"\">Sign out</a></dd>\n        </dl>\n      </li>\n      <li class=\"layui-nav-item\" lay-header-event=\"menuRight\" lay-unselect>\n        <a href=\"javascript:;\">\n          <i class=\"layui-icon layui-icon-more-vertical\"></i>\n        </a>\n      </li>\n    </ul>\n  </div>\n\n  <div class=\"layui-side layui-bg-black\">\n    <div class=\"layui-side-scroll\">\n      <!-- 左侧导航区域（可配合layui已有的垂直导航） -->\n      <ul class=\"layui-nav layui-nav-tree\" lay-filter=\"test\">\n        <li class=\"layui-nav-item layui-nav-itemed\">\n          <a class=\"\" href=\"javascript:;\">menu group 1</a>\n          <dl class=\"layui-nav-child\">\n<!--            修改语句-->\n            <dd><a href=\"http://cn.bing.com\" target=\"fm\">menu 1</a></dd>\n<!--            修改语句-->\n            <dd><a href=\"javascript:;\">menu 2</a></dd>\n            <dd><a href=\"javascript:;\">menu 3</a></dd>\n            <dd><a href=\"\">the links</a></dd>\n          </dl>\n        </li>\n        <li class=\"layui-nav-item\">\n          <a href=\"javascript:;\">menu group 2</a>\n          <dl class=\"layui-nav-child\">\n            <dd><a href=\"javascript:;\">list 1</a></dd>\n            <dd><a href=\"javascript:;\">list 2</a></dd>\n            <dd><a href=\"\">超链接</a></dd>\n          </dl>\n        </li>\n        <li class=\"layui-nav-item\"><a href=\"javascript:;\">click menu item</a></li>\n        <li class=\"layui-nav-item\"><a href=\"\">the links</a></li>\n      </ul>\n    </div>\n  </div>\n\n  <div class=\"layui-body\">\n    <!-- 内容主体区域 -->\n    <div style=\"padding: 15px;\">内容主体区域。记得修改 layui.css 和 js 的路径</div>\n<!--    添加语句-->\n    <iframe name=\"fm\" src=\"\" frameborder=\"0\" style=\"width: 100%;height: 100%\"></iframe>\n<!--    添加语句-->\n  </div>\n\n  <div class=\"layui-footer\">\n    <!-- 底部固定区域 -->\n    底部固定区域\n  </div>\n</div>\n<script src=\"./layui/layui.js\"></script>\n<script>\n  //JS\n  layui.use(['element', 'layer', 'util'], function(){\n    var element = layui.element\n            ,layer = layui.layer\n            ,util = layui.util\n            ,$ = layui.$;\n\n    //头部事件\n    util.event('lay-header-event', {\n      //左侧菜单事件\n      menuLeft: function(othis){\n        layer.msg('展开左侧菜单的操作', {icon: 0});\n      }\n      ,menuRight: function(){\n        layer.open({\n          type: 1\n          ,content: '<div style=\"padding: 15px;\">处理右侧面板的操作</div>'\n          ,area: ['260px', '100%']\n          ,offset: 'rt' //右上角\n          ,anim: 5\n          ,shadeClose: true\n        });\n      }\n    });\n\n  });\n</script>\n</body>\n</html>\n```\n\n###  表格效果\n\n**前置准备**\n\n导入sql 数据\n\n```sql\n-- 删除tb_brand表\ndrop table if exists tb_brand;\n-- 创建tb_brand表\ncreate table tb_brand (\n    -- id 主键\n                          id  int primary key auto_increment,\n    -- 品牌名称\n                          brandName   varchar(20),\n    -- 企业名称\n                          companyName varchar(20),\n    -- 排序字段\n                          ordered      int,\n    -- 描述信息\n                          description  varchar(100),\n    -- 状态：0：禁用  1：启用\n                          status       int\n);\n-- 添加数据\ninsert into tb_brand (brandName, companyName, ordered, description, status)\nvalues\n    ('华为', '华为技术有限公司', 100, '万物互联', 1),\n    ('小米', '小米科技有限公司', 50, 'are you ok', 1),\n    ('格力', '格力电器股份有限公司', 30, '让世界爱上中国造', 1),\n    ('阿里巴巴', '阿里巴巴集团控股有限公司', 10, '买买买', 1),\n    ('腾讯', '腾讯计算机系统有限公司', 50, '玩玩玩', 0),\n    ('百度', '百度在线网络技术公司', 5, '搜搜搜', 0),\n    ('京东', '北京京东世纪贸易有限公司', 40, '就是快', 1),\n    ('小米', '小米科技有限公司', 50, 'are you ok', 1),\n    ('三只松鼠', '三只松鼠股份有限公司', 5, '好吃不上火', 0),\n    ('华为', '华为技术有限公司', 100, '万物互联', 1),\n    ('小米', '小米科技有限公司', 50, 'are you ok', 1),\n    ('格力', '格力电器股份有限公司', 30, '让世界爱上中国造', 1),\n    ('阿里巴巴', '阿里巴巴集团控股有限公司', 10, '买买买', 1),\n    ('腾讯', '腾讯计算机系统有限公司', 50, '玩玩玩', 0),\n    ('百度', '百度在线网络技术公司', 5, '搜搜搜', 0),\n    ('京东', '北京京东世纪贸易有限公司', 40, '就是快', 1),\n    ('华为', '华为技术有限公司', 100, '万物互联', 1),\n    ('小米', '小米科技有限公司', 50, 'are you ok', 1),\n    ('格力', '格力电器股份有限公司', 30, '让世界爱上中国造', 1),\n    ('阿里巴巴', '阿里巴巴集团控股有限公司', 10, '买买买', 1),\n    ('腾讯', '腾讯计算机系统有限公司', 50, '玩玩玩', 0),\n    ('百度', '百度在线网络技术公司', 5, '搜搜搜', 0),\n    ('京东', '北京京东世纪贸易有限公司', 40, '就是快', 1),\n    ('小米', '小米科技有限公司', 50, 'are you ok', 1),\n    ('三只松鼠', '三只松鼠股份有限公司', 5, '好吃不上火', 0),\n    ('华为', '华为技术有限公司', 100, '万物互联', 1),\n    ('小米', '小米科技有限公司', 50, 'are you ok', 1),\n    ('格力', '格力电器股份有限公司', 30, '让世界爱上中国造', 1),\n    ('阿里巴巴', '阿里巴巴集团控股有限公司', 10, '买买买', 1),\n    ('腾讯', '腾讯计算机系统有限公司', 50, '玩玩玩', 0),\n    ('百度', '百度在线网络技术公司', 5, '搜搜搜', 0),\n    ('京东', '北京京东世纪贸易有限公司', 40, '就是快', 1),\n    ('华为', '华为技术有限公司', 100, '万物互联', 1),\n    ('小米', '小米科技有限公司', 50, 'are you ok', 1),\n    ('格力', '格力电器股份有限公司', 30, '让世界爱上中国造', 1),\n    ('阿里巴巴', '阿里巴巴集团控股有限公司', 10, '买买买', 1),\n    ('腾讯', '腾讯计算机系统有限公司', 50, '玩玩玩', 0),\n    ('百度', '百度在线网络技术公司', 5, '搜搜搜', 0),\n    ('京东', '北京京东世纪贸易有限公司', 40, '就是快', 1),\n    ('小米', '小米科技有限公司', 50, 'are you ok', 1),\n    ('三只松鼠', '三只松鼠股份有限公司', 5, '好吃不上火', 0),\n    ('华为', '华为技术有限公司', 100, '万物互联', 1),\n    ('小米', '小米科技有限公司', 50, 'are you ok', 1),\n    ('格力', '格力电器股份有限公司', 30, '让世界爱上中国造', 1),\n    ('阿里巴巴', '阿里巴巴集团控股有限公司', 10, '买买买', 1),\n    ('腾讯', '腾讯计算机系统有限公司', 50, '玩玩玩', 0),\n    ('百度', '百度在线网络技术公司', 5, '搜搜搜', 0),\n    ('京东', '北京京东世纪贸易有限公司', 40, '就是快', 1);\n```\n\n在layui官网下载 layui包，并复制layui文件夹到项目webapp下\n\npom文件 增加依赖\n\n```XML\n<dependency>\n   <groupId>mysql</groupId>\n   <artifactId>mysql-connector-java</artifactId>\n   <version>5.1.38</version>\n</dependency>\n<dependency>\n   <groupId>commons-beanutils</groupId>\n   <artifactId>commons-beanutils</artifactId>\n   <version>1.9.4</version></dependency>\n</dependency>\n<dependency>\n   <groupId>com.alibaba</groupId>\n   <artifactId>druid</artifactId>\n   <version>1.2.8</version>\n</dependency>\n```\n\n在 webapp 下新建文件 table.html\n\n在layui官网粘入数据表格代码并修改引入的 layui.js  和 layui.css 为自己的路径\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n  <meta charset=\"utf-8\">\n  <title>Layui</title>\n  <meta name=\"renderer\" content=\"webkit\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1, maximum-scale=1\">\n  <link rel=\"stylesheet\" href=\"./layui/css/layui.css\"    media=\"all\">\n  <!-- 注意：如果你直接复制所有代码到本地，上述css路径需要改成你本地的 -->\n</head>\n<body>\n           \n<table class=\"layui-hide\" id=\"test\"></table>\n              \n          \n<script src=\"./layui/layui.js\" charset=\"utf-8\"></script>\n<!-- 注意：如果你直接复制所有代码到本地，上述 JS 路径需要改成你本地的 -->\n \n<script>\nlayui.use('table', function(){\n  var table = layui.table;\n  \n  table.render({\n    elem: '#test'\n    ,url: '../demo/table/user/-page=1&limit=20.js'\n    ,cellMinWidth: 80 //全局定义常规单元格的最小宽度，layui 2.2.1 新增\n    ,cols: [[\n      {field:'id', width:80, title: 'ID', sort: true}\n      ,{field:'username', width:80, title: '用户名'}\n      ,{field:'sex', width:80, title: '性别', sort: true}\n      ,{field:'city', width:80, title: '城市'}\n      ,{field:'sign', title: '签名', width: '30%', minWidth: 100} //minWidth：局部定义当前单元格的最小宽度，layui 2.2.1 新增\n      ,{field:'experience', title: '积分', sort: true}\n      ,{field:'score', title: '评分', sort: true}\n      ,{field:'classify', title: '职业'}\n      ,{field:'wealth', width:137, title: '财富', sort: true}\n    ]]\n  });\n});\n</script>\n\n</body>\n</html>\n```\n\n**实现**\n\n> 编写后端查询代码\n\n在 pojo 下新建文件 Brand.java\n\n````java\n@Data\n@ToString\npublic class Brand {\n    private int id;\n    private String brandName;\n    private String companyName;\n    private int ordered;\n    private String description;\n    private int status;\n}\n````\n\n在 dao 下新建文件 BrandDao.java\n\n```java\npublic interface BrandDao {\n    List<Brand> queryDate() throws SQLException;\n}\n```\n\n在 dao 下新建文件 BrandImpl.java\n\n```java\npublic class BrandImpl implements BrandDao {\n    @Override\n    public List<Brand> queryDate() throws SQLException {\n        QueryRunner qr = new QueryRunner(DruidUtils.getDataSource());\n        String sql = \"select * from tb_brand;\";\n        List<Brand> query = qr.query(sql, new BeanListHandler<>(Brand.class));\n        return query;\n    }\n}\n```\n\n> 拉取数据转化成JSON格式\n\n在 pojo下新建文件 ResultBrean.java\n\n```java\n@Data\n@ToString\n@NoArgsConstructor//空参构造\n@AllArgsConstructor//全参构造\npublic class ResultBrean<T> {\n    //编写成JSON模板格式\n    private int code;\n    private String msg;\n    private int count;\n    private List<Brand> data;\n}\n```\n\n在 controller下新建文件 JsonBrand.java\n\n```java\n@WebServlet(\"/static\")\npublic class JsonBrand extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n\n        List<Brand> brands =null;\n        try {\n            brands = new BrandImpl().queryDate();\n            System.out.println(brands);\n        } catch (SQLException e) {\n            throw new RuntimeException(e);\n        }\n\n        ResultBrean<Object> rb = new ResultBrean<>();\n        rb.setCode(0);\n        rb.setMsg(\"\");\n        rb.setCount(50);\n        rb.setData(brands);\n\n        String str = JSON.toJSONString(rb);\n\n        System.out.println(str);\n        resp.setContentType(\"test/html;charset = utf-8\");\n\n        resp.getWriter().println(str);\n    }\n}\n```\n\n> 收到数据前端获取\n\n更改 table.html\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n  <meta charset=\"utf-8\">\n  <title>Layui</title>\n  <meta name=\"renderer\" content=\"webkit\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1, maximum-scale=1\">\n  <link rel=\"stylesheet\" href=\"./layui/css/layui.css\" tppabs=\"http://res.layui.com/layui/dist/css/layui.css\"  media=\"all\">\n  <!-- 注意：如果你直接复制所有代码到本地，上述css路径需要改成你本地的 -->\n</head>\n<body>\n\n<table class=\"layui-hide\" id=\"test\"></table>\n\n\n<script src=\"./layui/layui.js\" charset=\"utf-8\"></script>\n<!-- 注意：如果你直接复制所有代码到本地，上述 JS 路径需要改成你本地的 -->\n\n<script>\n  layui.use('table', function(){\n    var table = layui.table;\n\n    table.render({\n      elem: '#test'\n      ,url: '../demo1/static'\n      ,cellMinWidth: 80 //全局定义常规单元格的最小宽度，layui 2.2.1 新增\n      ,cols: [[\n        {field:'id', width:80, title: 'ID', sort: true}\n        ,{field:'brandName', width:80, title: '品牌名'}\n        ,{field:'companyName', width:200, title: '公司名', sort: true}\n        ,{field:'ordered', width:80, title: '排序'}\n        ,{field:'description', title: '描述信息', width: '30%', minWidth: 100} //minWidth：局部定义当前单元格的最小宽度，layui 2.2.1 新增\n        ,{field:'status', title: '状态', sort: true}\n      ]]\n    });\n  });\n</script>\n\n</body>\n</html>\n```\n\n### 分页\n\n在表格效果中更改\n\ntable.html\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n  <meta charset=\"utf-8\">\n  <title>Layui</title>\n  <meta name=\"renderer\" content=\"webkit\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1, maximum-scale=1\">\n  <link rel=\"stylesheet\" href=\"./layui/css/layui.css\" tppabs=\"http://res.layui.com/layui/dist/css/layui.css\"  media=\"all\">\n  <!-- 注意：如果你直接复制所有代码到本地，上述css路径需要改成你本地的 -->\n</head>\n<body>\n\n<table class=\"layui-hide\" id=\"test\"></table>\n\n\n<script src=\"./layui/layui.js\" charset=\"utf-8\"></script>\n<!-- 注意：如果你直接复制所有代码到本地，上述 JS 路径需要改成你本地的 -->\n\n<script>\n  layui.use('table', function(){\n    var table = layui.table;\n\n    table.render({\n      elem: '#test'\n      ,url: '../demo1/static'\n      ,cellMinWidth: 80 //全局定义常规单元格的最小宽度，layui 2.2.1 新增\n      ,cols: [[\n        {field:'id', width:80, title: 'ID', sort: true}\n        ,{field:'brandName', width:80, title: '品牌名'}\n        ,{field:'companyName', width:200, title: '公司名', sort: true}\n        ,{field:'ordered', width:80, title: '排序'}\n        ,{field:'description', title: '描述信息', width: '30%', minWidth: 100} //minWidth：局部定义当前单元格的最小宽度，layui 2.2.1 新增\n        ,{field:'status', title: '状态', sort: true}\n      ]]\n      ,page: true//开启分页\n    });\n  });\n</script>\n\n</body>\n</html>\n```\n\nJsonBrand.java\n\n```java\n@WebServlet(\"/static\")\npublic class JsonBrand extends HttpServlet {\n\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        //接受前端传过来得分页参数\n        Integer page = Integer.valueOf(req.getParameter(\"page\"));\n        Integer limit = Integer.valueOf(req.getParameter(\"limit\"));\n\n        List<Brand> brands =null;\n        try {\n            //计算分页 开始索引 = （当前页码 -  1）*  每页显示条数\n            brands = new BrandImpl().queryDate((page-1)*10,limit);\n            System.out.println(brands);\n        } catch (SQLException e) {\n            throw new RuntimeException(e);\n        }\n\n        ResultBrean rb = new ResultBrean();\n        rb.setCode(0);\n        rb.setMsg(\"\");\n        rb.setCount(50);\n        rb.setData(brands);\n\n        String str = JSON.toJSONString(rb);\n\n        System.out.println(str);\n        resp.setContentType(\"test/html;charset = utf-8\");\n\n        resp.getWriter().println(str);\n    }\n}\n```\n\nBrandDao.java\n\n```java\npublic interface BrandDao {\n    List<Brand> queryDate(Integer page, Integer limit) throws SQLException;\n}\n```\n\nBrandImpl.java\n\n```java\npublic class BrandImpl implements BrandDao {\n    @Override\n    public List<Brand> queryDate(Integer page,Integer limit) throws SQLException {\n        QueryRunner qr = new QueryRunner(DruidUtils.getDataSource());\n        String sql = \"select * from tb_brand limit ?,?;\";\n        List<Brand> query = qr.query(sql, new BeanListHandler<>(Brand.class),page,limit);\n        return query;\n    }\n}\n```\n\n","tags":["JavaWeb"],"categories":["学习之路"]},{"title":"JDBC","url":"/2022/09/26/JDBC/","content":"\n## JDBC概述\n\n在开发中我们使用的是java语言，那么势必要通过java语言操作数据库中的数据。这就是接下来要学习的JDBC。\n\n**JDBC概念**\nJDBC(Java Data Base Connectivity) 是 Java 访问数据库的标准规范.是一种用于执行SQL语句的Java API，可以为多种关系数据库提供统一访问，它由一组用Java语言编写的类和接口组成。是Java访问数据库的标准规范\n\n**JDBC原理**\nJDBC是接口，驱动是接口的实现，没有驱动将无法完成数据库连接，从而不能操作数据库！每个数据库厂商都需要提供自己的驱动，用来连接自己公司的数据库，也就是说驱动一般都由数据库生成厂商提供。\n\n**JDBC好处**\n\n- 各数据库厂商使用相同的接口，Java代码不需要针对不同数据库分别开发\n\n- 可随时替换底层数据库，访问数据库的Java代码基本不变\n\n以后编写操作数据库的代码只需要面向JDBC（接口），操作哪儿个关系型数据库就需要导入该数据库的驱动包，如需要操作MySQL数据库，就需要再项目中导入MySQL数据库的驱动包。\n\n## JDBC快速入门\n\n> **数据准备**\n\n```sql\n-- 创建 jdbc_user表\nCREATE TABLE jdbc_user(\n    id INT PRIMARY KEY AUTO_INCREMENT,\n    username VARCHAR(50),\n    PASSWORD VARCHAR(50),\n    birthday DATE\n);\n-- 添加数据\nINSERT INTO jdbc_user (username, PASSWORD,birthday)\nVALUES('admin1', '123','1991/12/24'),\n('admin2','123','1995/12/24'),\n('test1', '123','1998/12/24'),\n('test2', '123','2000/12/24');\n```\n\n> **引用驱动包** \n\n在项目根目录新建 lib 文件夹，里面存入 mysql-connector-java-5.1.48.jar 压缩包\n\n打开IDEA，找到  mysql-connector-java-5.1.48.jar 压缩包，右键点击 ADD as Library \n\n出现窗口直接默认，点击确定，完成引用MySQL驱动包\n\n### 第一个JDBC程序\n\n> **API使用**\n\n| 加载注册驱动的方式              | 描述                                                         |\n| ------------------------------- | ------------------------------------------------------------ |\n| Class.forName(数据库驱动实现类) | 加载和注册数据库驱动,数据库驱动由数据库厂商MySql提供\"com.mysql.jdbc.Driver\" |\n\n```java\npublic static void main(String[] args) throws ClassNotFoundException {\n        //1.注册驱动   注册驱动（jar 8以下）\n        // forName 方法执行将类进行初始化\n        Class.forName(\"com.mysql.jdbc.Driver\");\n}\n```\n\n> 注:5.1以后版本需要带.cj 会默认自动注册\n>\n> Class.forName(“com.mysql.cj.jdbc.Driver”);\n\n> **获得连接**\n\nConnection 接口，代表一个连接对象 ,具体的实现类由数据库的厂商实现\n\n使用 DriverManager类的静态方法,getConnection可以获取数据库的连接\n\n| 获取连接的静态方法                                           | 说明                                            |\n| ------------------------------------------------------------ | ----------------------------------------------- |\n| Connection getConnection(String url, String user,String password) | 通过连接字符串和用户名,密码来获取数据库连接对象 |\n\nurl: jdbc:mysql://localhost:3306/db4?characterEncoding=UTF-8\n\n第一部分是协议 jdbc，这是固定的；\n\n第二部分是子协议，就是数据库名称，连接mysql数据库，第二部分当然是mysql了；\n\n第三部分是由数据库厂商规定的，我们需要了解每个数据库厂商的要求，mysql的第三部分分别由数据库服务器的IP地址（localhost）、端口号（3306），以及要使用的数据库名称组成。\n\n```java\npublic static void main(String[] args) throws ClassNotFoundException, SQLException {\n        //1.注册驱动\n        Class.forName(\"com.mysql.jdbc.Driver\");\n        //2.获取连接 url,用户名, 密码\n        String url = \"jdbc:mysql://localhost:3306/db4\";\n        Connection con = DriverManager.getConnection(url, \"root\", \"123456\");\n        //com.mysql.jdbc.JDBC4Connection@2e3fc542\n        System.out.println(con);\n }\n```\n\n> **获取语句执行平台**\n\n通过Connection 的 createStatement方法 获取sql语句执行对象\n\n| Connection接口中的方法      | 说明                 |\n| --------------------------- | -------------------- |\n| Statement createStatement() | 创建 SQL语句执行对象 |\n\nStatement ：代表一条语句对象，用于发送 SQL 语句给服务器，用于执行静态SQL语句并返回它所生成结果的对象。\n\nStatement类常用方法：\n\nint executeUpdate(String sql);\t执行insert update delete语句,返回int类型,代表受影响的行数\n\nResultSet executeQuery(Stringsql);\t执行select语句, 返回ResultSet结果集对象\n\n```java\n public static void main(String[] args) throws Exception {\n\t\t//1.注册驱动\n        Class.forName(\"com.mysql.jdbc.Driver\");\n\t\t//2.获取连接 url,用户名, 密码\n        String url = \"jdbc:mysql://localhost:3306/db4\";\n        Connection con = DriverManager.getConnection(url, \"root\", \"123456\");\n\t\t//3.获取 Statement对象\n        Statement statement = con.createStatement();\n\t\t//4.执行创建表操作\n        String sql = \"create table test01(id int,name varchar(20),age int);\";\n\t\t//5.增删改操作 使用executeUpdate,增加一张表\n        int i = statement.executeUpdate(sql);\n\t\t//6.返回值是受影响的函数\n        System.out.println(i);\n\t\t//7.关闭流 \n        statement.close();\n        con.close();\n}\n```\n\n> **处理结果集**\n\n只有在进行查询操作的时候, 才会处理结果集\n\n```java\npublic static void main(String[] args) throws SQLException {\n        //1.注册驱动 可以省略 \n        //2.获取连接\n        String url = \"jdbc:mysql://localhost:3306/db4\";\n        Connection con = DriverManager.getConnection(url, \"root\", \"123456\");\n        //3.获取 Statement对象 \n        Statement statement = con.createStatement();\n        String sql = \"select * from jdbc_user\";\n        //执行查询操作,返回的是一个 ResultSet 结果对象\n        ResultSet resultSet = statement.executeQuery(sql);\n        //4.处理结果集 resultSet\n}\n```\n\n### ResultSet接口\n\n作用：封装数据库查询的结果集，对结果集进行遍历，取出每一条记录。\n\n```\nboolean next()\n```\n\n1、游标向下一行;\n\n2、返回 boolean 类型，如果还有下一条记录，返回 true，否则返回 false\n\n```\nxxx getXxx( String or int)\n```\n\n1、通过列名，参数是 String 类型。返回不同的类型\n\n2、通过列号，参数是整数，从1开始。返回不同的类型\n\n```java\npublic static void main(String[] args) throws SQLException {\n        //1.注册驱动 可以省略\n        //2.获取连接\n        String url = \"jdbc:mysql://localhost:3306/db4\";\n        Connection con = DriverManager.getConnection(url, \"root\", \"123456\");\n        //3.获取 Statement对象\n        Statement statement = con.createStatement();\n        String sql = \"select * from jdbc_user\";\n        //执行查询操作,返回的是一个 ResultSet 结果对象\n        ResultSet resultSet = statement.executeQuery(sql);\n        //4.处理结果集\n        //next 方法判断是否还有下一条数据\n        // boolean next = resultSet.next();\n        // System.out.println(next);\n        //getXXX 方法获取数据 两种方式\n        // int id = resultSet.getInt(\"id\");//列名\n        // System.out.println(id);\n        int anInt = resultSet.getInt(1);//列号\n        // System.out.println(anInt);\n        //使用while循环\n        while(resultSet.next()){\n            //获取id\n            int id = resultSet.getInt(\"id\");\n            //获取姓名\n            String username = resultSet.getString(\"username\");\n            //获取生日\n            Date birthday = resultSet.getDate(\"birthday\");\n            System.out.println(id + \" = \" +username + \" : \" + birthday);\n        }\n        //关闭连接\n        resultSet.close();\n        statement.close();\n        con.close();\n}\n```\n\n### 释放资源\n\n需要释放的对象：ResultSet 结果集，Statement 语句，Connection 连接\n\n释放原则：先开的后关，后开的先关。ResultSet ==> Statement ==> Connection\n\n放在哪个代码块中：finally 块\n\n与IO流一样，使用后的东西都需要关闭！关闭的顺序是先开后关, 先得到的后关闭，后得到的先关闭\n\n```java\npublic static void main(String[] args) {\n        Connection connection = null;\n        Statement statement = null;\n        ResultSet resultSet = null;\n        try {\n            //1.注册驱动（省略） \n            //2.获取连接 \n            String url = \"jdbc:mysql://localhost:3306/db4\";\n            connection = DriverManager.getConnection(url, \"root\", \"123456\");\n            //3.获取 Statement对象 \n            statement = connection.createStatement();\n            String sql = \"select * from jdbc_user\";\n            resultSet = statement.executeQuery(sql);\n        } catch (SQLException e) {\n            e.printStackTrace();\n        } finally {\n            /**\n             * 开启顺序: connection ==> statement => resultSet \n             * 关闭顺序: resultSet ==> statement ==> connection \n             */\n            try {\n                connection.close();\n                resultSet.close();\n                statement.close();\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n        }\n}\n```\n\n### JDBC流程\n\n> 创建工程，导入驱动jar包\n\n注册驱动（jar 8以下）\n\n```Java\nClass.forName(\"com.mysql.jdbc.Driver\");\n```\n\n获取连接\n\n```java\nConnection conn = DriverManager.getConnection(url, username, password);\n```\n\n> Java代码需要发送SQL给MySQL服务端，就需要先建立连接\n\n定义SQL语句\n\n  ```java\nString sql =  “update…” ;\n  ```\n\n获取执行SQL对象\n\n执行SQL语句需要SQL执行对象，而这个执行对象就是Statement对象\n\n  ```java\nStatement stmt = conn.createStatement();\n  ```\n\n Statement stmt = conn.createStatement();\n\n执行SQL\n\n```java\nstmt.executeUpdate(sql);  \n```\n\n> 处理返回结果 \n\n> 释放资源\n\n```java\nxxxx.close();\n```\n\n## JDBC增删改查\n\n **JDBC工具类**\n\n什么时候自己创建工具类？\n\n如果一个功能经常要用到，我们建议把这个功能做成一个工具类，可以在不同的地方重用。\n\n“获得数据库连接”操作，将在以后的增删改查所有功能中都存在，可以封装工具类JDBCUtils。提供获取连接对象的方法，从而达到代码的重复利用。\n\n工具类包含的内容\n\n可以把几个字符串定义成常量：用户名，密码，URL，驱动类\n\n得到数据库的连接：getConnection()\n\n关闭所有打开的资源：\n\n```java\npublic class JdbcUtils {\n    //定义字符串常量, 记录获取连接所需要的信息\n    public static final String driver = \"com.mysql.jdbc.Driver\";\n    public static final String url = \"jdbc:mysql://localhost:3306/school?useSSL=false\";\n    public static final String username = \"root\";\n    public static final String password = \"123456\";\n\t//静态代码块, 随着类的加载而加载\n    static{\n        try {\n            Class.forName(driver);\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace(); \n            throw new RuntimeException(e);\n        }\n    }\n    //获取连接的静态方法\n    public static Connection getConnection(){\n        Connection conn =null;\n        try {\n            conn = DriverManager.getConnection(url, username, password);\n        } catch (SQLException e) {\n            throw new RuntimeException(e);\n        }\n        //返回连接对象\n        return conn;\n    }\n    //关闭资源的方法\n    public static void close(ResultSet resultSet){\n        try {\n            if (resultSet != null){\n                resultSet.close();\n            }\n        } catch (SQLException e) {\n            throw new RuntimeException(e);\n        }\n    }\n    public static void close(Statement statement){\n        try {\n            if (statement != null){\n                statement.close();\n            }\n        } catch (SQLException e) {\n            throw new RuntimeException(e);\n        }\n    }\n    public static void close(Connection connection){\n        try {\n            if (connection != null){\n                connection.close();\n            }\n        } catch (SQLException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\t//方法重载 关闭资源的方法\n    public static void close(ResultSet resultSet,Statement statement,Connection connection){\n        close(resultSet);\n        close(statement);\n        close(connection);\n    }\n}\n```\n\n### DML操作\n\n**解决插入中文乱码问题**\n\n```java\njdbc:mysql://localhost:3306/db4?characterEncoding=UTF-8\n//characterEncoding=UTF-8 指定字符的编码、解码格式\n```\n\n```java\npublic void testInsert() throws SQLException {\n        //1.通过工具类获取连接\n        Connection connection = JDBCUtils.getConnection();\n        //2.获取Statement\n        Statement statement = connection.createStatement();\n        //2.1 编写Sql\n        String sql = \"insert into jdbc_user values(null,'张百万','123','2020/1/1')\";\n        //2.2 执行Sql\n        int i = statement.executeUpdate(sql);\n        System.out.println(i);\n        //3.关闭流\n        JDBCUtils.close(connection,statement);\n}\n```\n\n### 更新记录\n\n```java\n//修改id为1的用户名为广坤\npublic void testUpdate() throws SQLException {\n        Connection connection = JDBCUtils.getConnection();\n        Statement statement = connection.createStatement();\n        String sql = \"update jdbc_user set username = '广坤' where id = 1\";\n        statement.executeUpdate(sql);\n        JDBCUtils.close(connection,statement);\n}\n```\n\n###  删除记录\n\n```java\n//删除id为3和4的记录\npublic void testDelete() throws SQLException {\n        Connection connection = JDBCUtils.getConnection();\n        Statement statement = connection.createStatement();\n        statement.executeUpdate(\"delete from jdbc_user where id in(3,4)\");\n        JDBCUtils.close(connection,statement);\n}\n```\n\n### DQL操作\n\n```java\n//查询姓名为张百万的一条记录\npublic static void main(String[] args) throws SQLException {\n        //1.获取连接对象\n        Connection connection = JDBCUtils.getConnection();\n        //2.获取Statement对象\n        Statement statement = connection.createStatement();\n        String sql = \"SELECT * FROM jdbc_user WHERE username = '张百万';\";\n        ResultSet resultSet = statement.executeQuery(sql);\n        //3.处理结果集\n        while(resultSet.next()){\n        //通过列名 获取字段信息\n            int id = resultSet.getInt(\"id\");\n            String username = resultSet.getString(\"username\");\n            String password = resultSet.getString(\"password\");\n            String birthday = resultSet.getString(\"birthday\");\n            System.out.println(id+\" \"+username+\" \" + password +\" \" + birthday);\n        }\n        //4.释放资源\n        JDBCUtils.close(connection,statement,resultSet);\n}\n```\n\n## SQL注入\n\n**SQL注入问题**\n\n```sql\n-- 向jdbc_user表中 插入两条数据\nINSERT INTO jdbc_user VALUES(NULL,'jack','123456','2020/2/24');\nINSERT INTO jdbc_user VALUES(NULL,'tom','123456','2020/2/24');\n```\n\n```sql\n## SQL注入演示\n-- 填写一个错误的密码\nSELECT * FROM jdbc_user WHERE username = 'tom' AND PASSWORD = '123' OR '1' = '1';\n```\n\n> 如果这是一个登陆操作,那么用户就登陆成功了.显然这不是我们想要看到的结果\n\n**用户登陆**\n\n用户在控制台上输入用户名和密码, 然后使用 Statement 字符串拼接的方式 实现用户的登录\n\n步骤:\n\n- 得到用户从控制台上输入的用户名和密码来查询数据库\n- 写一个登录的方法\n  - 通过工具类得到连接\n  - 创建语句对象，使用拼接字符串的方式生成 SQL 语句\n  - 查询数据库，如果有记录则表示登录成功，否则登录失败\n  - 释放资源\n\n```java\n/*用户登录案例\n     使用 Statement字符串拼接的方式完成查询*/\n    public static void main(String[] args) throws SQLException {\n        //1.获取连接\n        Connection connection = JDBCUtils.getConnection();\n        //2.获取Statement\n        Statement statement = connection.createStatement();\n        //3.获取用户输入的用户名和密码\n        Scanner sc = new Scanner(System.in);\n        System.out.println(\"请输入用户名: \");\n        String name = sc.nextLine();\n        System.out.println(\"请输入密码: \");\n        String pass = sc.nextLine();\n        System.out.println(pass);\n        //4.拼接Sql,执行查询\n        // String pass = \"xxx' or '1'='1\";\n        String sql = \"select * from jdbc_user where username ='\"+name+\"' and password ='\"+pass+\"';\";\n        System.out.println(sql);\n        ResultSet resultSet = statement.executeQuery(sql);\n        //5.处理结果集,判断结果集是否为空\n        if(resultSet.next()){\n            System.out.println(\"登录成功! 欢迎您: \" + name);\n        }else {\n            System.out.println(\"登录失败!\");\n        }\n        //释放资源\n        JDBCUtils.close(connection,statement,resultSet);\n}\n```\n\n**问题分析：**\n\n1. 什么是SQL注入?\n   我们让用户输入的密码和 SQL 语句进行字符串拼接。用户输入的内容作为了 SQL 语句语法的一部分，改变了 原有SQL 真正的意义，以上问题称为 SQL 注入 \n2. 如何实现的注入\n   根据用户输入的数据,拼接处的字符串\n\n```sql\nselect * from jdbc_user where username = 'abc' and password = 'abc' or '1'='1';\n/*name='abc' and password='abc' 为假'1'='1' 真\n相当于 select * from user where true=true;查询了所有记录*/\n```\n\n> 要解决 SQL 注入就不能让用户输入的密码和我们的 SQL 语句进行简单的字符串拼接\n\n## 预处理对象\n\n**PreparedStatement 接口**\n\nPreparedStatement 是 Statement 接口的子接口，继承于父接口中所有的方法。它是一个预编译的 SQL 语句对象\n\n预编译: 是指SQL 语句被预编译,并存储在 PreparedStatement 对象中。然后可以使用此对象多次高效地执行该语句。\n\n**PreparedStatement 特点**\n\n因为有预先编译的功能，提高 SQL 的执行效率。\n\n可以有效的防止 SQL 注入的问题，安全性更高\n\n**获取PreparedStatement对象**\n\n通过Connection创建PreparedStatement对象\n\n| Connection 接口中的方法                        | 说明                                                         |\n| ---------------------------------------------- | ------------------------------------------------------------ |\n| PreparedStatement prepareStatement(String sql) | 指定预编译的 SQL 语句，SQL 语句中使用占位符 ? 创建一个语句对象 |\n\n**PreparedStatement接口常用方法**\n\n| 常用方法                  | 说明                                   |\n| ------------------------- | -------------------------------------- |\n| int executeUpdate();      | 执行insert update delete语句           |\n| ResultSet executeQuery(); | 执行select语句. 返回结果集对象 Resulet |\n\n> 编写 SQL 语句，未知内容使用?占位：\n\n```slq\n\"SELECT * FROM jdbc_user WHERE username=? AND password=?\";\n```\n\n| setXxx重载方法                               | 说明                                   |\n| -------------------------------------------- | -------------------------------------- |\n| ResultSet executeQuery();                    | 执行select语句. 返回结果集对象 Resulet |\n| void setDouble(int parameterIndex, double x) | 将指定参数设置为给定 Java double 值。  |\n| void setString(int parameterIndex, String x) | 将指定参数设置为给定 Java String 值。  |\n| void setObject(int parameterIndex, Object x) | 使用给定对象设置指定参数的值。         |\n### PreparedStatement完成登录案例\n\n> 使用 PreparedStatement 预处理对象,可以有效的避免SQL注入\n\n```java\npublic static void main(String[] args) throws SQLException {\n        //1.获取连接 \n        Connection connection = JDBCUtils.getConnection();\n        //2.获取Statement \n        Statement statement = connection.createStatement();\n        //3.获取用户输入的用户名和密码\n        Scanner sc = new Scanner(System.in);\n        System.out.println(\"请输入用户名: \");\n        String name = sc.nextLine();\n        System.out.println(\"请输入密码: \");\n        String pass = sc.nextLine();\n        System.out.println(pass);\n        //4.获取 PrepareStatement 预编译对象\n        //4.1 编写SQL 使用 ? 占位符方式\n        String sql = \"select * from jdbc_user where username = ? and password = ?\";\n        PreparedStatement ps = connection.prepareStatement(sql);\n        //4.2 设置占位符参数\n        ps.setString(1,name);\n        ps.setString(2,pass);\n        //5. 执行查询 处理结果集\n        ResultSet resultSet = ps.executeQuery();\n        if(resultSet.next()){\n            System.out.println(\"登录成功! 欢迎您: \" + name);\n        }else{\n            System.out.println(\"登录失败!\");\n        }\n        //6.释放资源 \n        JDBCUtils.close(connection,statement,resultSet);\n}\n```\n\n### PreparedStatement的执行原理\n\n> 分别使用 Statement对象 和 PreparedStatement对象进行插入操作\n\n```java\npublic static void main(String[] args) throws SQLException {\n        Connection con = JDBCUtils.getConnection();\n        //获取 Sql语句执行对象 \n        Statement st = con.createStatement();\n        //插入两条数据 \n        st.executeUpdate(\"insert into jdbc_user values(null,'张三','123','1992/12/26')\");\n        st.executeUpdate(\"insert into jdbc_user values(null,'李四','123','1992/12/26')\");\n\n        //获取预处理对象 \n        PreparedStatement ps = con.prepareStatement(\"insert into jdbc_user values(?,?,?,?)\");\n        //第一条数 设置占位符对应的参数 \n        ps.setString(1,null);\n        ps.setString(2,\"hd\");\n        ps.setString(3,\"qwer\");\n        ps.setString(4,\"2000/1/10\");\n        //执行插入 \n        ps.executeUpdate();\n        //第二条数据 \n        ps.setString(1,null);\n        ps.setString(2,\"jc\");\n        ps.setString(3,\"1122\");\n        ps.setString(4,\"2000/1/10\");\n        //执行插入 \n        ps.executeUpdate();\n        //释放资源 \n        st.close();\n        ps.close();\n        con.close();\n    }\n```\n\n![Prepared](https://image.aobayu.cn/images/Prepared.png)\n\n**Statement 与 PreparedStatement的区别**\n\nStatement用于执行静态SQL语句，在执行时，必须指定一个事先准备好的SQL语句。\n\nPrepareStatement是预编译的SQL语句对象，语句中可以包含动态参数“?”，在执行时可以为“?”动态设置参数值。\n\nPrepareStatement可以减少编译次数提高数据库性能。\n\n## JDBC 控制事务\n\n**数据准备**\n\n```sql\n-- 创建账户表\n    CREATE TABLE account(\n\t-- 主键\n    id INT PRIMARY KEY AUTO_INCREMENT,\n\t-- 姓名\n    NAME VARCHAR(10),\n\t-- 转账金额\n    money DOUBLE\n);\n-- 添加两个用户\n    INSERT INTO account (NAME, money) VALUES ('tom', 1000), ('jack', 1000);\n```\n\n**事务相关API**\n\n| 方法                                   | 说明                                                         |\n| -------------------------------------- | ------------------------------------------------------------ |\n| void setAutoCommit(boolean autoCommit) | 参数是 true 或 false 如果设置为 false，表示关闭自动提交，相当于开启事务 |\n| void commit()                          | 提交事务                                                     |\n| void rollback()                        | 回滚事务                                                     |\n\n**开发步骤**\n\n- 获取连接\n- 开启事务\n- 获取到 PreparedStatement , 执行两次更新操作\n- 正常情况下提交事务\n- 出现异常回滚事务\n- 最后关闭资源\n\n```java\npublic static void main(String[] args) {\n        Connection con = null;\n        PreparedStatement ps = null;\n        try {\n            //1. 获取连接 \n            con = JDBCUtils.getConnection();\n            //2. 开启事务 \n            con.setAutoCommit(false);\n            //3. 获取到 PreparedStatement 执行两次更新操作 \n            //3.1 tom 账户 -500 \n            ps = con.prepareStatement(\"update account set money = money - ? where name = ? \");\n            ps.setDouble(1,500.0);\n            ps.setString(2,\"tom\");\n            ps.executeUpdate();\n            //模拟tom转账后 出现异常 \n            System.out.println(1 / 0);\n            //3.2 jack 账户 +500 \n            ps = con.prepareStatement(\"update account set money = money + ? where name = ? \");\n            ps.setDouble(1,500.0);\n            ps.setString(2,\"jack\");\n            ps.executeUpdate();\n            //4. 正常情况下提交事务 \n            con.commit();\n            System.out.println(\"转账成功!\");\n        } catch (SQLException e) {\n            e.printStackTrace();\n            try {\n                //5. 出现异常回滚事务 \n                con.rollback();\n            } catch (SQLException ex) {\n                ex.printStackTrace();\n            }\n        } finally {\n            //6. 最后关闭资源 \n            JDBCUtils.close(con,ps);\n        }\n}\n```\n\n## 数据库连接池\n\n**连接池介绍**\n\n实际开发中“获得连接”或“释放资源”是非常消耗系统资源的两个过程，为了解决此类性能问题，通常情况我们 采用连接池技术，来共享连接Connection。这样我们就不需要每次都创建连接、释放连接了，这些操作都交给了连接池.\n\n**连接池的好处**\n\n用池来管理Connection，这样可以重复使用Connection。 当使用完Connection后，调用Connection的close()方法也不会真的关闭Connection，而是把Connection“归还”给池。\n\nJava为数据库连接池提供了公共的接口:javax.sql.DataSource，各个厂商需要让自己的连接池实现这个接口。这样应用程序可以方便的切换不同厂商的连接池!\n\n常见的连接池有 DBCP连接池, C3P0连接池, Druid连接池\n\nDruid（德鲁伊）是阿里巴巴开发的号称为监控而生的数据库连接池，Druid是目前最好的数据库连接池。在功能、性能、扩展性方面，都超过其他数据库连接池，同时加入了日志监控，可以很好的监控DB池连接和SQL的执行情况。\n\n**数据准备**\n\n```sql\n#创建数据库\nCREATE DATABASE db5 CHARACTER SET utf8;\n#使用数据库\nUSE db5;\n#创建员工表\nCREATE TABLE employee (\n       eid INT PRIMARY KEY AUTO_INCREMENT,\n       ename VARCHAR (20),-- 员工姓名\n       age INT,-- 员工年龄\n       sex VARCHAR (6), -- 员工性别\n       salary DOUBLE, -- 薪水\n       empdate DATE -- 入职日期\n);\n#插入数据\nINSERT INTO employee (eid, ename, age, sex, salary, empdate) VALUES(NULL,'李清照',22,'女',4000,'2018-11-12');\nINSERT INTO employee (eid, ename, age, sex, salary, empdate) VALUES(NULL,'林黛玉',20,'女',5000,'2019-03-14');\nINSERT INTO employee (eid, ename, age, sex, salary, empdate) VALUES(NULL,'杜甫',40,'男',6000,'2020-01-01');\nINSERT INTO employee (eid, ename, age, sex, salary, empdate) VALUES(NULL,'李白',25,'男',3000,'2017-10-01');\n```\n\n**导入 jar包 配置文件**\n\n在项目根目录 lib 文件夹里存入 druid-1.1.12.jar 压缩包\n\n打开IDEA，找到   druid-1.1.12.jar 压缩包，右键点击 ADD as Library \n\n出现窗口直接默认，点击确定，完成引用MySQL驱动包\n\n在 src 目录下右键创建 druid.properties 存入以下代码\n\n```jso\ndriverClassName=com.mysql.jdbc.Driver\nurl=jdbc:mysql:///db1?useSSL=false&useServerPrepStmts=true&characterEncoding=UTF-8\nusername=root\npassword=123456\n#初始化连接数量\ninitialSize=5\n#最大连接数\nmaxActive=10\n#最大等待时间\nmaxWait=3000\n```\n\n### 编写Druid工具类\n\n获取数据库连接池对象\n通过工厂来来获取 DruidDataSourceFactory类的createDataSource方法\ncreateDataSource(Properties p) 方法参数可以是一个属性集对象\n\n```java\npublic class DruidUtils {\n        //1.定义成员变量 \n        public static DataSource dataSource;\n        //2.静态代码块 \n        static{\n            try {\n                //3.创建属性集对象 \n                Properties p = new Properties();\n                //4.加载配置文件 Druid 连接池不能够主动加载配置文件 ,需要指定文件 \n                InputStream inputStream = DruidUtils.class.getClassLoader().getResourceAsStream(\"druid.properties\");\n                //5. 使用Properties对象的 load方法 从字节流中读取配置信息 \n                p.load(inputStream);\n                //6. 通过工厂类获取连接池对象 \n                dataSource = DruidDataSourceFactory.createDataSource(p);\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n\n        //获取连接的方法 \n        public static Connection getConnection(){\n            try {\n                return dataSource.getConnection();\n            } catch (SQLException e) {\n                e.printStackTrace();\n                return null;\n            }\n        }\n        //释放资源 \n        public static void close(Connection con, Statement statement){\n            if(con != null && statement != null){\n                try {\n                    statement.close();\n                    //归还连接 \n                    con.close();\n                } catch (SQLException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        public static void close(Connection con, Statement statement, ResultSet resultSet){\n            if(con != null && statement != null && resultSet != null){\n                try {\n                    resultSet.close();\n                    statement.close();\n                    //归还连接 \n                    con.close();\n                } catch (SQLException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n}\n```\n\n### 测试工具类\n\n```java\n//需求 查询 薪资在3000 到 5000之间的员工的姓名 \n    public static void main(String[] args) throws SQLException {\n        //1.获取连接 \n        Connection con = DruidUtils.getConnection();\n        //2.获取Statement对象 \n        Statement statement = con.createStatement();\n        //3.执行查询 \n        ResultSet resultSet = statement.executeQuery(\"select ename from employee where salary between 3000 and 5000\");\n        //4.处理结果集 \n        while(resultSet.next()){\n            String ename = resultSet.getString(\"ename\");\n            System.out.println(ename);\n        }\n        //5.释放资源 \n        DruidUtils.close(con,statement,resultSet);\n    }\n```\n\n> 对象数组接收 sql 数据\n\n```java\npublic static void main(String[] args) throws SQLException {\n        Connection conn = DruidUtils.getConnection();\n        Statement statement = conn.createStatement();\n        ResultSet resultSet = statement.executeQuery(\"select * FROM employee\");\n        List<Student> students = new ArrayList<>();\n        while (resultSet.next()){\n            Student student = new Student();\n            String name =resultSet.getString(\"ename\");\n            int age = resultSet.getInt(\"age\");\n            student.setName(name);\n            student.setAge(age);\n            System.out.println(student);\n        }\n        DruidUtils.close(resultSet,statement,conn);\n}\n```\n\n```java\npublic class Student {\n    String name;\n    int age;\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    @Override\n    public String toString() {\n        return \"Student{\" +\n                \"name='\" + name + '\\'' +\n                \", age=\" + age +\n                '}';\n    }\n}\n```\n\n## DBUtils工具类\n\n**DBUtils简介**\n\n使用JDBC我们发现冗余的代码太多了,为了简化开发 我们选择使用 DbUtils\n\nCommons DbUtils是Apache组织提供的一个对JDBC进行简单封装的开源工具类库，使用它能够简化JDBC应用程序的开发，同时也不会影响程序的性能。\n\n使用方式:\n\nDBUtils就是JDBC的简化开发工具包。需要项目导入**commons-dbutils-1.6.jar**。\n\n**Dbutils核心功能介绍**\n\n- **QueryRunner** 中提供对sql语句操作的API.\n- **ResultSetHandler**接口，用于定义select操作后，怎样封装结果集.\n- DbUtils类,他就是一个工具类,定义了关闭资源与事务处理相关方法.\n\n**JavaBean组件**\n\nJavaBean 就是一个类, 开发中通常用于封装数据,有一下特点\n\n1. 需要实现 序列化接口, Serializable (暂时可以省略)\n\n1. 提供私有字段: private 类型 变量名;\n\n1. 提供 getter 和 setter\n\n1. 提供 空参构造\n\n创建Employee类和数据库的employee表对应，我们可以创建一个 entity包,专门用来存放 JavaBean类\n\n### QueryRunner核心类\n\n**构造方法**\n\n- QueryRunner()\n\n- QueryRunner(DataSource ds) ,提供数据源（连接池），DBUtils底层自动维护连接connection\n\n**常用方法**\n\n- update(Connection conn, String sql, Object… params) ，用来完成表数据的增加、删除、更新操作\n\n- query(Connection conn, String sql, ResultSetHandler rsh, Object… params) ，用来完成表数据的查询操作\n\n```java\n//手动方式 创建QueryRunner对象具体使用到的时候在给信息\nQueryRunner qr = new QueryRunner();\n//自动创建 传入数据库连接池对象  直接给DataSource\nQueryRunner qr2 = new QueryRunner(DruidUtils.getDataSource());\n```\n\n> 工具类需要返回dataSource\n\n```java\n//获取连接池对象\npublic static DataSource getDataSource(){\n\treturn dataSource;\n}\n```\n\n### 增、删、改操作\n\n**核心方法**\n\n- update(Connection conn, String sql, Object… params)\n\n- Object... param Object类型的 可变参,用来设置占位符上的参数\n\n**步骤:**\n\n1.创建QueryRunner(手动或自动)\n\n2.占位符方式 编写SQL\n\n3.设置占位符参数\n\n4.执行\n\n>添加\n\n```java\n@Test\n    public void testInsert() throws SQLException {\n        //1.创建 QueryRunner 手动模式创建\n        QueryRunner qr = new QueryRunner();\n\n        //2.编写 占位符方式\n        String sql = \"insert into employee values(?,?,?,?,?,?)\";\n\n        //3.设置占位符的参数\n        Object[] param = {null,\"张百万\",20,\"女\",10000,\"1990-12-26\"};\n\n        //4.执行 update方法\n        Connection con = DruidUtils.getConnection();\n        int i = qr.update(con, sql, param);\n\n        //5.释放资源\n        DbUtils.closeQuietly(con);\n    }\n```\n\n> 修改\n\n```java\n//修改操作 修改姓名为张百万的员工工资 \n    @Test\n    public void testUpdate() throws SQLException {\n        //1.创建QueryRunner对象 自动模式,传入数据库连接池 \n        QueryRunner qr = new QueryRunner(DruidUtils.getDataSource());\n\n        //2.编写SQL \n        String sql = \"update employee set salary = ? where ename = ?\";\n\n        //3.设置占位符参数 \n        Object[] param = {0,\"张百万\"};\n\n        //4.执行update, 不需要传入连接对象 \n        qr.update(sql,param);\n    }\n```\n\n> 删除\n\n```java\n//删除操作 删除id为1 的数据 \n    @Test\n    public void testDelete() throws SQLException {\n        QueryRunner qr = new QueryRunner(DruidUtils.getDataSource());\n        String sql = \"delete from employee where eid = ?\";\n        //只有一个参数,不需要创建数组 \n        qr.update(sql,1);\n    }\n```\n\n### 实现查询操作\n\n**ResultSetHandler接口简介**\n\nResultSetHandler可以对查询出来的ResultSet结果集进行处理，达到一些业务上的需求。\n\n**ResultSetHandler 结果集处理类**\n\n本例展示的是使用ResultSetHandler接口的几个常见实现类实现数据库的增删改查，可以大大减少代码量，优化程序。\n\n每一种实现类都代表了对查询结果集的一种处理方式\n\n**ResultSetHandler 实现类**\t\n\n- ArrayHandler\t将结果集中的第一条记录封装到一个Object[]数组中，数组中的每一个元素就是这条记录中的每一个字段的值 id,ename,eage\n\n- ArrayListHandler\t将结果集中的每一条记录都封装到一个Object[]数组中，将这些数组在封装到List集合中。\n\n- BeanHandler\t将结果集中第一条记录封装到一个指定的javaBean中.\n\n- BeanListHandler\t将结果集中每一条记录封装到指定的javaBean中，再将这些javaBean在封装到List集合中\n\n- ColumnListHandler\t将结果集中指定的列的字段值，封装到一个List集合中\n\n- KeyedHandler\t将结果集中每一条记录封装到Map<String,Object>,在将这个map集合做为另一个Map的value,另一个Map集合的key是指定的字段的值。\n\n- MapHandler\t将结果集中第一条记录封装到了Map<String,Object>集合中，key就是字段名称，value就是字段值\n\n- MapListHandler\t将结果集中每一条记录封装到了Map<String,Object>集合中，key就是字段名称，value就是字段值，在将这些Map封装到List集合中。\n\n- ScalarHandler\t它是用于封装单个数据。例如 select count(*) from 表操作。\n\n**ResultSetHandler 常用实现类测试**\n\n- QueryRunner的查询方法\n\n- query方法的返回值都是泛型,具体的返回值类型,会根据结果集的处理方式,发生变化\n\n**方法**\t\n\n- query(String sql, handler ,Object[] param)\t自动模式创建QueryRunner, 执行查询\n\n- query(Connection con,String sql,handler,Object[] param)\t手动模式创建QueryRunner, 执行查询\n\n> 查询id为5的记录,封装到数组中\n\n```java\n\t/**查询id为5的记录,封装到数组中 \n     * ArrayHandler 将结果集的第一条数据封装到数组中 \n     */\n    @Test\n    public void testFindById() throws SQLException {\n        //1.创建QueryRunner \n        QueryRunner qr = new QueryRunner(DruidUtils.getDataSource());\n        //2.编写SQL \n        String sql = \"select * from employee where eid = ?\";\n        //3.执行查询 \n        Object[] query = qr.query(sql, new ArrayHandler(), 5);\n        //4.获取数据 \n        System.out.println(Arrays.toString(query));\n    }\n```\n\n> 查询所有数据,封装到List集合中\n\n```java\n\t/**\n     * 查询所有数据,封装到List集合中  \n     * ArrayListHandler可以将每条数据先封装到数组中, 再将数组封装到集合中 \n     */\n    @Test\n    public void testFindAll() throws SQLException {\n        //1.创建QueryRunner \n        QueryRunner qr = new QueryRunner(DruidUtils.getDataSource());\n        //2.编写SQL \n        String sql = \"select * from employee\";\n        //3.执行查询 \n        List<Object[]> query = qr.query(sql, new ArrayListHandler());\n        //4.遍历集合获取数据 \n        for (Object[] objects : query) {\n            System.out.println(Arrays.toString(objects));\n        }\n    }\n```\n\n> 根据ID查询,封装到指定JavaBean中\n\n```java\n\t/**\n     * 查询id为3的记录,封装到指定JavaBean中 \n     * BeanHandler 将结果集的第一条数据封装到 javaBean中 \n     */\n    @Test\n    public void testFindByIdJavaBean() throws SQLException {\n        QueryRunner qr = new QueryRunner(DruidUtils.getDataSource());\n        String sql = \"select * from employee where eid = ?\";\n        Employee employee = qr.query(sql,\n                new BeanHandler<Employee>(Employee.class), 3);\n        System.out.println(employee);\n    }\n```\n\n> 查询薪资大于 3000 的所员工信息,封装到JavaBean中再封装到List集合中\n\n```java\n\t/**\n     * 查询薪资大于 3000 的所员工信息,封装到JavaBean中再封装到List集合中 \n     * BeanListHandler 将结果集的每一条和数据封装到 JavaBean中 \n     * 再将JavaBean 放到list集合中 \n     **/\n    @Test\n    public void testFindBySalary() throws SQLException {\n        QueryRunner qr = new QueryRunner(DruidUtils.getDataSource());\n        String sql = \"select * from employee where salary > ?\";\n        List<Employee> list = qr.query(sql,\n                new BeanListHandler<Employee>(Employee.class), 3000);\n        for (Employee employee : list) {\n            System.out.println(employee);\n        }\n    }\n```\n\n> 查询姓名是 张百万的员工信息,将结果封装到Map集合中\n\n```java\n\t/**\n     * 查询姓名是 张百万的员工信息,将结果封装到Map集合中 \n     * MapHandler 将结果集的第一条记录封装到 Map<String,Object>中 \n     * key对应的是 列名 value对应的是 列的值 \n     **/\n    @Test\n    public void testFindByName() throws SQLException {\n        QueryRunner qr = new QueryRunner(DruidUtils.getDataSource());\n        String sql = \"select * from employee where ename = ?\";\n        Map<String, Object> map = qr.query(sql, new MapHandler(), \"张百万\");\n        Set<Map.Entry<String, Object>> entries = map.entrySet();\n        for (Map.Entry<String, Object> entry : entries) {\n            //打印结果 \n            System.out.println(entry.getKey() +\" = \" +entry.getValue());\n        }\n    }\n```\n\n> 查询所有员工的薪资总额\n\n```java\n\t/**\n     * 查询所有员工的薪资总额 \n     * ScalarHandler 用于封装单个的数据 \n     **/\n    @Test\n    public void testGetSum() throws SQLException {\n        QueryRunner qr = new QueryRunner(DruidUtils.getDataSource());\n        String sql = \"select sum(salary) from employee\";\n        Double sum = (Double)qr.query(sql, new ScalarHandler<>());\n        System.out.println(\"员工薪资总额: \" + sum);\n    }\n```\n\n## MySql元数据\n\n**除了表之外的数据都是元数据,可以分为三类**\n\n- 查询结果信息： UPDATE 或 DELETE语句 受影响的记录数。\n\n- 数据库和数据表的信息： 包含了数据库及数据表的结构信息。\n\n- MySQL服务器信息： 包含了数据库服务器的当前状态，版本号等。\n\n**常用命令**\n\n```sql\n-- 元数据相关的命令介绍\n-- 1.查看服务器当前状态\nshow status;\n-- 2.查看MySQl的版本信息\nselect version();\n-- 3.查询表中的详细信息   和desc table_name一样\nshow columns from table_name;\n-- 4.显示数据表的详细索引信息\nshow index from table_name;\n-- 5.列出所有数据库 \nshow databases;\n-- 6.显示当前数据库的所有表\nshow tables;\n-- 7.获取当前的数据库名\nselect database();\n```\n\n> 使用JDBC 获取元数据\n\n通过JDBC 也可以获取到元数据,比如数据库的相关信息,或者当我们使用程序查询一个不熟悉的表时, 我们可以通过获取元素据信息,了解表中有多少个字段,字段的名称 和 字段的类型.\n\n> JDBC中描述元数据的类\n\n| 元数据类          | 作用                   |\n| ----------------- | ---------------------- |\n| DatabaseMetaData  | 描述数据库的元数据对象 |\n| ResultSetMetaData | 描述结果集的元数据对象 |\n\n- 获取元数据对象的方法 : getMetaData ()\n  - connection 连接对象, 调用 getMetaData () 方法,获取的是DatabaseMetaData 数据库元数据对象\n  - PrepareStatement 预处理对象调用 getMetaData () , 获取的是ResultSetMetaData , 结果集元数据对象\n\n- DatabaseMetaData的常用方法\n  - getURL() : 获取数据库的URL\n  - getUserName(): 获取当前数据库的用户名\n  - getDatabaseProductName(): 获取数据库的产品名称\n  - getDatabaseProductVersion(): 获取数据的版本号\n  - getDriverName(): 返回驱动程序的名称\n  - isReadOnly(): 判断数据库是否只允许只读 true 代表只读\n\n- ResultSetMetaData的常用方法\n  - getColumnCount() : 当前结果集共有多少列\n  - getColumnName(int i) : 获取指定列号的列名, 参数是整数 从1开始\n  - getColumnTypeName(int i): 获取指定列号列的类型, 参数是整数 从1开始\n\n```java\n//1.获取数据库相关的元数据信息 使用DatabaseMetaData \n    @Test\n    public void testDataBaseMetaData() throws SQLException {\n        //1.获取数据库连接对象 \n        Connection connection = DruidUtils.getConnection();\n        //2.获取代表数据库的 元数据对象 \n        DatabaseMetaData DatabaseMetaData metaData = connection.getMetaData();\n        //3.获取数据库相关的元数据信息 \n        String url = metaData.getURL();\n        System.out.println(\"数据库URL: \" + url);\n        String userName = metaData.getUserName();\n        System.out.println(\"当前用户: \" + userName );\n        String productName = metaData.getDatabaseProductName();\n        System.out.println(\"数据库产品名: \" + productName);\n        String version = metaData.getDatabaseProductVersion();\n        System.out.println(\"数据库版本: \" + version);\n\n        String driverName = metaData.getDriverName();\n        System.out.println(\"驱动名称: \" + driverName);\n        //判断当前数据库是否只允许只读 \n        boolean b = metaData.isReadOnly();\n        //如果是 true 就表示 只读 \n        if(b){\n            System.out.println(\"当前数据库只允许读操作!\");\n        }else{\n            System.out.println(\"不是只读数据库\");\n        }\n        connection.close();\n    }\n    //获取结果集中的元数据信息 \n    @Test\n    public void testResultSetMetaData() throws SQLException {\n        //1.获取连接 \n        Connection con = DruidUtils.getConnection();\n        //2.获取预处理对象 \n        PreparedStatement ps = con.prepareStatement(\"select * from employee\");\n        ResultSet resultSet = ps.executeQuery();\n        //3.获取结果集元素据对象 \n        ResultSetMetaData metaData = ps.getMetaData();\n        //1.获取当前结果集 共有多少列 \n        int count = metaData.getColumnCount();\n        System.out.println(\"当前结果集中共有: \" + count + \" 列\");\n        //2.获结果集中 列的名称 和 类型 \n        for (int i = 1; i <= count; i++) {\n            String columnName = metaData.getColumnName(i);\n            System.out.println(\"列名: \"+ columnName);\n            String columnTypeName = metaData.getColumnTypeName(i);\n            System.out.println(\"类型: \" +columnTypeName);\n        }\n    //释放资源 \n        DruidUtils.close(con,ps,resultSet);\n    }\n```\n\n## Dao模式\n\n**什么是Dao模式**\n\nDAO（Data Access Object）顾名思义是一个为数据库或其他持久化机制提供了抽象接口的对象，在不暴露底层持久化方案实现细节的前提下提供了各种数据访问操作\n\n**为什么要使用DAO模式**\n\n在目前的企业应用系统设计中，MVC，即 Model（模型）- View（视图）- Control（控制）为主要的系统架构模式。MVC 中的 Model 包含了复杂的业务逻辑和数据逻辑，以及数据存取机制（如 JDBC的连接、SQL生成和Statement创建、还有ResultSet结果集的读取等）等。将这些复杂的业务逻辑和数据逻辑分离，以将系统的紧耦合关系转化为松耦合关系（即解耦合），是降低系统耦合度迫切要做的。MVC 模式需要解决2个问题：\n\n- 将表现层（即View）和数据处理层（即Model）分离的解耦合。\n\n- 将数据处理层内部的业务逻辑和数据访问分离的解耦合。\n\n第一个问题可以使用控制器来解决，第二个问题可以使用DAO模式来解决。\n\n（1）JDBC访问数据时，将业务代码和数据访问代码混在一起编写（藕合），造成程序的\n\n-  可读性差。\n\n-  不利于后期修改和维护。\n\n-  不利于代码复用。\n\n（2）用面向接口编程，可以降低代码间的耦合性。\n\n-  隔离业务逻辑代码和数据访问代码。\n\n-  隔离不同数据库的实现。\n\n业务逻辑代码是指程序需要实现的功能算法，如银行ATM机实现的功能有存款、取款、转账等，这些属于程序需要实现的功能。而数据访问代码是指对存储在数据库的数据进行CRUD（增、查、改、删）操作代码。存款、取款和转账的逻辑代码是不同的，但最终都是对数据库中的余额进行修改，使用Dao模式可以将业务逻辑代码和数据访问代码分离，降低代码间的耦合性\n\n**对象关系映射ORM**\n\n**什么是ORM**\n\n对象关系映射（Object Relational Mapping，简称ORM）。ORM指的是面向对象的对象模型和关系型数据库的数据结构之间的相互转换。它的作用是在关系型数据库和对象之间作一个映射，这样，我们在具体的操作数据库的时候，就不需要再去和复杂的SQL语句打交道，也不需要数据编写大量的DAO层的代码，用来从数据库保存、删除和读取对象信息，只要像平时操作对象一样操作它就可以了 。ORM很好的实现了数据持久化。数据持久化就是将内存中的数据模型转换为存储模型，以及将存储模型转换为内存中的数据模型的统称。\n\nORM拱了三种映射为实现数据持久化\n\n- 类—表映射。在开发系统时，数据库中有几张表，在Java中就应该编写几个类。\n\n- 属性—列映射。表对应的类的属性名与列名一样，数据类型与列的数据类型一样。\n\n- 对象—行映射。一个对象可以转化为一行数据，同样，一行数据也可以转化为一个对象。\n\nDao模式项目结构\n\n实体类:和数据库表格一一对应的类,单独放入一个包中,包名往往是 pojo/entity/bean,要操作的每个表格都应该有对应的实体类\n\nemp > class Emp  \n\ndept > class Dept  \n\naccount > class Account \n\nDAO 层:定义了对数据要执行那些操作的接口和实现类,包名往往是 dao/mapper,要操作的每个表格都应该有对应的接口和实现类\n\nemp > interface EmpDao >EmpDaoImpl\n\ndept > interface DeptDao> DeptDaoImpl\n\nMybatis/Spring JDBCTemplate 中,对DAO层代码进行了封装,代码编写方式会有其他变化\n\n**简单的Java对象POJO**\n\n**什么是POJO**\n\nPOJO（Plain Ordinary Java Object）简单的Java对象，实际就是普通JavaBeans。方便程序员使用数据库中的数据表，POJO有一些private的参数作为对象的属性。然后针对每个参数定义了get和set方法作为访问的接口。\n\n**POJO的作用**\n\n在MVC的设计模式，视图层、业务层、数据访问层和数据库之间都是通过JavaBean进行数据封装和传递。\n\n- 持久化对象**Entity**：Entity称为实体类，封装持久化的数据，数据库做orm映射，一个Entity对应一数据库中一张表。\n\n- 查询参数对象**VO**：VO（View object）被称为视图对象，html jsp 上显示的对象\n\n- 数据转换对象**DTO**：data transfer object 数据传输对象 并不在页面上做展示，只是传输用 简化数据\n\n- **domain** 领域模型 银行 保险 电商 物流 医疗 DDD 领域驱动设计\n\n- 银行职员 user Account 账户 VIP 积分\n\n### 准备测试数据\n\n```sql\n# 创建数据库\ncreate database db6 character set utf8;\n# 创建商品表\nCREATE TABLE product (\n       pid varchar(32)  PRIMARY KEY, -- 商品id\n       pname varchar(50) , -- 商品名称\n       price double, -- 商品价格\n       pdesc varchar(255), -- 商品描述\n       pflag int(11) -- 商品状态 1 上架 ,0 下架\n);\nINSERT INTO `product` VALUES\n('1','小米12',2200,'小米 移动联通电信4G手机 双卡双待',0),\n('2','华为Mate50',2599,'华为 双卡双待 高清大屏',0),\n('3','OPPO',3000,'移动联通 双4G手机',0),\n('4','华为荣耀',1499,'3GB内存标准版 黑色 移动4G手机',0),\n('5','华硕台式电脑',5000,'爆款直降，满千减百',0),\n('6','MacBook',6688,'128GB 闪存',0),\n('7','ThinkPad',4199,'轻薄系列1)',0),\n('8','联想小新',4499,'14英寸超薄笔记本电脑',0),\n('9','李宁音速',500,'实战篮球鞋',0),\n('10','AJ11',3300,'乔丹实战系列',0),\n('11','AJ1',5800,'精神小伙系列',0);\n```\n\n**项目结构**\n\ncom.aaa.app 测试包 用于对DAO代码进行测试\n\ncom.aaa.dao dao包 数据访问层,包含所有对数据库的相关操作的类\n\ncom.aaa.entity 实体包 保存根据数据库表 对应创建的JavaBean类\n\ncom.aaa.utils 工具包 \n\n**导入所需Jar包**\n\ncommons-dbutils-1.6.jar\n\ndruid-1.1.21.jar\n\nmysql-connector-java-5.1.48.jar\n\n**导入配置文件及工具类**\n\nresource --> druid.properties\n\nutils-------->DruidUtils\n\n### JavaBean类创建\n\n```java\npublic class Product {\n \n        private String pid;\n \n        private String pname;\n \n        private double price;\n \n        private String pdesc;\n \n        private int pflag; //是否上架 1 上架 ,0 下架\n\n        //提供 get set toString方法\n}\n```\n\n### 编写DAO类\n\n```java\npublic class ProductDao {\n    //查询所有商品信息\n    public List<Product> findProduct() throws SQLException {\n        \n    QueryRunner qr = new QueryRunner(DruidUtils.getDataSource());\n    String sql = \"select * from product\";\n           //查询结果是一个List集合, 使用BeanListHandler 封装结果集\n    List<Product> list = qr.query(sql, new BeanListHandler<Product>(Product.class));\n    return list;\n    }\n    //根据商品ID 获取商品\n    public Product findProductById(String pid) throws SQLException {\n           QueryRunner qr = new QueryRunner(DruidUtils.getDataSource());\n           String sql = \"select * from product where pid = ?\";\n           Product product = qr.query(sql, new BeanHandler<Product>(Product.class), pid);\n           return product;\n    }\n\n\t//2查询商品个数\n    public int getCount() throws SQLException {\n           QueryRunner qr = new QueryRunner(DruidUtils.getDataSource());\n           String sql = \"select count(*) from product\";\n           //获取的单列数据 ,使用ScalarHandler 封装\n           Long count = (Long)qr.query(sql,new ScalarHandler<>());\n           //将Lang类型转换为 int 类型,并返回\n           return count.intValue();\n    }\n}\n```\n\n### 测试 ProductDao\n\n```java\npublic class TestProductDao {\n \n        ProductDao productDao = new ProductDao();\n \n        @Test\n        public void testFindProduct() throws SQLException {\n            List<Product> list = productDao.findProduct();\n            for (Product product : list) {\n                System.out.println(product);\n            }\n        }\n    \n        @Test\n        public void testFindProductById() throws SQLException {\n            Product product = productDao.findProductById(\"1\");\n            System.out.println(product);\n        }\n\n        @Test\n        public void testGetCount() throws SQLException {\n            //查询商品总数量\n            int count = productDao.getCount();\n            System.out.println(\"商品个数: \" + count);\n        }\n    }\n```","tags":["JDBC"],"categories":["学习之路"]},{"title":"MySQL","url":"/2022/09/23/MySQL/","content":"\n## 数据库相关概念\n\n**数据库**: 存储数据的仓库，数据是有组织的进行存储,英文：DataBase，简称 DB\n\n- 存储和管理数据的仓库 \n\n- 其本质是一个文件系统, 还是以文件的方式,将数据保存在电脑上\n\n| 存储方 | 优点                                                         | 缺点                                           |\n| ------ | ------------------------------------------------------------ | ---------------------------------------------- |\n| 内存   | 速度快                                                       | 不能够永久保存,数据是临时状态的                |\n| 文件   | 数据是可以永久保存的                                         | 使用IO流操作文件,不方便                        |\n| 数据库 | 1.数据可以永久保存<br>2.方便存储和管理数据<br>3.使用统一的方式操作数据库 | 占用资源,有些数据库需要付费(比如Oracle数据库） |\n\n**数据库管理系统：**管理数据库的大型软件英文：DataBase Management System，简称 DBMS，指一种操作和管理维护数据库的大型软件。\n\nMySQL就是一个 数据库管理系统软件, 安装了Mysql的电脑,我们叫它数据库服务器\n\n**数据库管理系统的作用**\n\n用于建立、使用和维护数据库，对数据库进行统一的管理\n\n**SQL**英文：Structured Query Language，简称 SQL，结构化查询语言\n\n是一种特殊目的的编程语言，是一种数据库 查询和程序设计语言，用于存取数据以及查询、更新和管理关系数据库系统。\n\n**常见的关系型数据库管理系统:**\n\n- **Oracle**：收费的大型数据库，Oracle 公司的产品 ---->甲骨文  银行Oracle \n- **MySQL**： 开源免费的中小型数据库。后来 Sun 公司收购了 MySQL，而 Sun 公司又被 Oracle 收购  java\n- **SQL Server**：MicroSoft 公司收费的中型的数据库。C#、.net 等语言常使用\n- **PostgreSQL**：开源免费中小型的数据库 定位\n- **DB2**：IBM 公司的大型收费数据库产品 \n- **SQLite**：嵌入式的微型数据库。如：作为 Android 内置数据库  \n- **MariaDB**：开源免费中小型的数据库--mysql 的一个分支\n\n## SQL \n\n**SQL 简介**\n\n- 英文：Structured Query Language，简称 SQL\n\n- 结构化查询语言，一门操作关系型数据库的编程语言\n\n- 定义操作所有关系型数据库的统一标准\n\n- 对于同一个需求，每一种数据库操作的方式可能会存在一些不一样的地方，我们称为“方言”\n\n**通用语法**\n\n- SQL语句可以单行 或者 多行书写，以分号 结尾 ; \n- 可以使用空格和缩进来增加语句的可读性。\n- MySql中使用SQL不区分大小写，一般关键字大写，数据库名 表名列名 小写。 \n- 注释方式\n\n| 注释语法 | 说明                        |\n| :------- | --------------------------- |\n| #        | Mysql特有的单行注释(不建议) |\n| /**/     | 多行注释                    |\n| -- 空格  | 单行注释                    |\n\n**SQL分类**\n\n| 分类         | 说明                                                         |\n| ------------ | ------------------------------------------------------------ |\n| 数据定义语言 | 简称DDL(Data Definition Language)，用来定义数据库对象:数据库，表，列 |\n| 数据操作语言 | 简称DML(Data Manipulation Language)，用来对数据库中表的记录进行更新。 |\n| 数据查询语言 | 简称DQL(Data Query Language)，用来查询数据库中表的记录。     |\n| 数据查询语言 | 简称DCL(Data Control Language)，用来定义数据库的访问权限和安全级别，<br>及创建用户。(了解) |\n\n## MySQL 数据库\n\n**关系型数据库：**\n\n> 关系型数据库是建立在关系模型基础上的数据库，简单说，关系型数据库是由多张能互相连接的 二维表组成的数据库\n\n**关系型数据库的优点**：\n\n- 都是使用表结构，格式一致，易于维护。\n\n- 使用通用的 SQL 语言操作，使用方便，可用于复杂查询。\n\n- 关系型数据库都可以通过SQL进行操作，所以使用方便。\n\n- 数据存储在磁盘中，安全。\n\n**数据模型：**\n\n![数据模型](https://image.aobayu.cn/images/mysql.png)\n\n创建一个数据库，会在本地文件夹生成.frm 表文件 和 .MYD 数据文件，在安装目录下的 data文件下\n\n```sql\nmysql> create database db1;\n```\n\n- MySQL中可以创建多个数据库，每个数据库对应到磁盘上的一个文件夹\n\n- 在每个数据库中可以创建多个表，每张都对应到磁盘上一个 frm 文件\n\n- 每张表可以存储多条数据，数据会被存储到磁盘中  MYD 文件中\n\n## 数据定义语言DDL\n\n### DDL:操作数据库\n\n| 命令                                        | 说明                                               |\n| ------------------------------------------- | -------------------------------------------------- |\n| create database数据库名;                    | 创建指定名称的数据库。                             |\n| create database数据库名character set字符集; | 创建指定名称的数据库，并且指定字符集（一般都utf-8) |\n| use数据库                                   | 切换数据库                                         |\n| select database();                          | 查看当前正在使用的数据库                           |\n| show databases;                             | 查看Mysql中都有哪些数据库                          |\n| show create database 数据库名;              | 查看一个数据库的定义信息                           |\n| alter database数据库名character set字符集;  | 数据库的字符集修改操作                             |\n| drop database 数据库名                      | 从MySql中永久的删除某个数据库                      |\n\n```sql\nnet start mysql -- 启动mysql\nmysql -uroot -p123456-- 连接数据库\nmysql> --成功进入mysql \nupdate mysq1.user set authentication_string=password('123456') where user='root' and Host ='localhost';-- 修改root用户密码\nflush privileges;--刷新权限\n\nshow databases;--查看所有的数据库\nuse schoo1--切换数据库use数据库名\n-- tab键的上面,如果你的表名或者字段名是一个特殊字符，就需要带` `\nuse `schoo1`\n\nshow tables; --查看数据库中所有的表\ndescribe student; --显示数据库中所有的表的信息\n\ncreate database westos; --创建一个数据库\nCREATE database if not exists westos;--为了避免错误IF NOT EXISTS\nDROP DATABASE westos;-- 删除某个数据库\nDROP DATABASE IF EXISTS westos;-- 删除某个数据库 为了避免错误IF EXISTS\n\nexit--退出连接\nnet stop mysql -- 关闭mysql\n```\n\n### DDL:操作表\n\n操作表也就是对表进行增（Create）删（Retrieve）改（Update）查（Delete）。\n\n> 查询当前数据库下所有表名称\n\n```sql\nSHOW TABLES;\n```\n\n> 查询表结构\n\n```sql\nDESC 表名称;\n```\n\n> 创建表\n\n```java\nCREATE TABLE 表名(\n    字段名称1 字段类型(长度),\n    字段名称2 字段类型(长度) /*注意 最后一列不要加逗号*/\n);\n```\n\n**常见数据类型**\n\n| 整型    | 描述                                               |\n| ------- | -------------------------------------------------- |\n| int     | 整型                                               |\n| double  | 浮点型                                             |\n| varchar | 字符串型                                           |\n| date    | 日期类型，给是为yyyy-MM-dd ,只有年月日，没有时分秒 |\n\n注意：MySQL中的 char类型与 varchar类型，都对应了 Java中的字符串类型，\n\n**区别在于：** \n\nchar类型是固定长度的： 根据定义的字符串长度分配足够的空间。\n\nvarchar类型是可变长度的： 只使用字符串长度所需的空间 \n\n**适用场景：** char类型适合存储 固定长度的字符串，比如 密码，性别一类，varchar类型适合存储 在一定范围内，有长度变化的字符串 \n\n> 创建测试表 \n\n```sql\n--切换到数据库\nUSE db1;\n-- 创建表\nCREATE TABLE test1(\n    cid INT,\n    cname VARCHAR(20)\n);\n```\n\n> 快速创建一个表结构相同的表（复制表结构）\n\n```sql\ncreate table 新表名 like 旧表名\n```\n\n```sql\n-- 创建一个表结构与 test1 相同的 test2表\nCREATE TABLE test2 LIKE test1;\n-- 查看表结构\nDESC test2;\n-- 查看创建表的SQL语句\nSHOW CREATE TABLE category;\n```\n\n> 删除表\n\n| 命令                      | 说明                                              |\n| ------------------------- | ------------------------------------------------- |\n| drop table表名;           | 删除表（从数据库中永久删除某一张表)               |\n| drop table if exists表名; | 判断表是否存在，存在的话就删除,不存在就不执行删除 |\n\n```sql\n-- 直接删除test1表\nDROP TABLE test1;\n-- 先判断再删除test2表\nDROP TABLE IF EXISTS test2;\n```\n\n> 修改表名 \n\n```sql\nrename table 旧表名 to 新表名\n```\n\n> 修改表的字符集 \n\n```sql\nalter table 表名 character set 字符集\n```\n\n> 向表中添加列， 关键字 ADD \n\n```sql\nalert table 表名 add 字段名称 字段类型\n```\n\n> 修改表中列的 数据类型或长度 ， 关键字 MODIFY \n\n```sql\nalter table 表名 modify 字段名称 字段类型\n```\n\n> 修改列名称 , 关键字 CHANGE\n\n```sql\nalter table 表名 change 旧列名 新列名 类型(长度);\n```\n\n> 删除列 ，关键字 DROP\n\n```sql\nalter table 表名 drop 列名;\n```\n\n## 数据操作语言DML\n\nDML主要是对数据进行增（insert）删（delete）改（update）操作。\n\n### 添加数据\n\n```sql\ninsert into 表名 （字段名1，字段名2...） values(字段值1，字段值2...);\n```\n\n```sql\n/*表名：student 表中字段：\n学员 ID,sid int,\n姓名 sname varchar(20),\n年龄 age int,\n性别 sex char(1),\n地址 address varchar(40)  */\n# 创建学生表\nCREATE TABLE student(\n    sid INT,\n    sname VARCHAR(20),\n    age INT,\n    sex CHAR(1),\n    address VARCHAR(40)\n);\n```\n\n> 向学生表中添加数据，3种方式\n\n```sql\n-- 插入全部字段， 将所有字段名都写出来\nINSERT INTO student (sid,sname,age,sex,address)\nVALUES(1,'孙悟空',20,'男','花果山');\n```\n\n```sql\n-- 插入全部字段，不写字段名 \nINSERT INTO student VALUES(2,'孙悟饭',10,'男','地球');\n```\n\n```sql\n-- 插入指定字段的值 \nINSERT INTO category (cname) VALUES('白骨精');\n```\n\n> 批量添加数据\n\n```sql\nINSERT INTO 表名(列名1,列名2,…) VALUES(值1,值2,…),(值1,值2,…),(值1,值2,…)…;\nINSERT INTO 表名 VALUES(值1,值2,…),(值1,值2,…),(值1,值2,…)…;\n```\n\n```sql\nINSERT INTO student VALUES\n(2,'孙悟饭',10,'男','地球'),\n(3,'孙悟饭1',10,'男','地球');\n```\n\n### 修改数据\n\n> 不带条件的修改 \n\n```sql\nupdate 表名 set 列名 = 值\n```\n\n> 带条件的修改 \n\n```sql\nupdate 表名 set 列名 = 值 [where 条件表达式：字段名 = 值 ]\n```\n\n```sql\n-- 一次修改多个列，将sid为 2 的学员，年龄改为 20，地址改为 北京\nUPDATE student SET age = 20,address = '北京' WHERE sid = 2;\n```\n\n### 删除数据\n\n```sql\nDELETE FROM 表名 [WHERE 条件];\n```\n\n> 删除 sid 为 1 的数据 \n\n```sql\nDELETE FROM student WHERE sid = 1;\n```\n\n> 删除所有数据\n\n```sql\nDELETE FROM student;\ntruncate table student;\n```\n\n如果要删除表中的所有数据,有两种做法:\n\ndelete from 表名; 不推荐. 有多少条记录 就执行多少次删除操作. 效率低 \n\ntruncate table 表名: 推荐. 先删除整张表, 然后再重新创建一张一模一样的表. 效率高 \n\n## 数据查询语言DQL\n\n### 查询表中数据\n\n```sql\n-- 查询语法\nSELECT 字段列表(想要查询的字段)\nFROM 表名列表（来源表）\nWHERE 条件列表 \nGROUP BY 分组字段\nHAVING 分组后条件\nORDER BY 排序字段\nLIMIT 分页限定\n```\n\n> 准备初试数据\n\n```sql\nuse school;\n# 删除emp表\ndrop table if exists emp;\n# 创建员工表\nCREATE TABLE emp\n(\n    eid       INT,\n    ename     VARCHAR(20),\n    sex       CHAR(1),\n    salary    DOUBLE,\n    hire_date DATE,\n    dept_name VARCHAR(20)\n);\n# 添加数据\nINSERT INTO emp\nVALUES (1, '孙悟空', '男', 7200, '2013-02-04', '教学部');\nINSERT INTO emp\nVALUES (2, '猪八戒', '男', 3600, '2010-12-02', '教学部');\nINSERT INTO emp\nVALUES (3, '唐僧', '男', 9000, '2022-09-08', '教学部');\nINSERT INTO emp\nVALUES (4, '白骨精', '女', 5000, '2022-10-07', '市场部');\nINSERT INTO emp\nVALUES (5, '蜘蛛精', '女', 5000, '2022-09-14', '市场部');\nINSERT INTO emp\nVALUES (6, '玉兔精', '女', 200, '2022-03-14', '市场部');\nINSERT INTO emp\nVALUES (7, '林黛玉', '女', 10000, '2019-10-07', '财务部');\nINSERT INTO emp\nVALUES (8, '黄蓉', '女', 3500, '2022-09-14', '财务部');\nINSERT INTO emp\nVALUES (9, '吴承恩', '男', 20000, '2022-03-14', NULL);\nINSERT INTO emp\nVALUES (10, '孙悟饭', '男', 10, '2020-03-14', '财务部');\nINSERT INTO emp\nVALUES (11, '兔八哥', '女', 300, '2022-03-14', '财务部');\n```\n\n### 简单查询\n\n```sql\n-- 查询多个字段\nSELECT 字段列表 FROM 表名;\nSELECT * FROM 表名;-- 查询所有数据\n-- 去除重复记录\nSELECT DISTINCT 字段列表 FROM 表名;\n--起别名\nAS: AS --也可以省略\n```\n\n```sql\n-- 查询emp中的 所有数据 \nSELECT * FROM emp;-- 使用 * 表示所有列\n-- 查询emp表中的所有记录，仅显示id和name字段\nSELECT eid,ename FROM emp;\n-- 将所有的员工信息查询出来，并将列名改为中文\n# 使用 AS关键字,为列起别名\nSELECT  \neid AS '编号',\nename AS '姓名' ,\nsex AS '性别',\nsalary AS '薪资',\nhire_date '入职时间',-- AS 可以省略\ndept_name '部门名称'\nFROM emp;\n-- 查询一共有几个部门 \n-- 使用distinct 关键字,去掉重复部门信息\nSELECT DISTINCT dept_name FROM emp;\n-- 将所有员工的工资 +1000 元进行显示\nSELECT ename , salary + 1000 FROM emp;\n```\n\n### 条件查询\n\n```sql\n SELECT 字段列表 FROM 表名 WHERE 条件列表;\n```\n\n| 符号               | 功能                               |\n| ------------------ | ---------------------------------- |\n| >                  | 大于                               |\n| <                  | 小于                               |\n| >=                 | 大于等于                           |\n| <=                 | 小于等于                           |\n| =                  | 等于                               |\n| <>或!=             | 不等于                             |\n| BETWEEN ...AND ... | 在某个范围之内(都包含)             |\n| IN(...)            | 多选一                             |\n| LIKE占位符         | 模糊查询_单个任意字符%多个任意字符 |\n| lS NULL            | 是NULL                             |\n| IS NOT NULL        | 不是NULL                           |\n| AND或&&            | 并且                               |\n| OR或\\|\\|           | 或者                               |\n| NOT或!             | 非，不是                           |\n\n```sql\n# 查询员工姓名为黄蓉的员工信息\nSELECT * FROM emp WHERE ename = '黄蓉';\n# 查询薪水价格为5000的员工信息\nSELECT * FROM emp WHERE salary = 5000;\n# 查询薪水价格不是5000的所有员工信息\nSELECT * FROM emp WHERE salary != 5000;\nSELECT * FROM emp WHERE salary <> 5000;\n# 查询薪水价格大于6000元的所有员工信息\nSELECT * FROM emp WHERE salary > 6000;\n# 查询薪水价格在5000到10000之间所有员工信息\nSELECT * FROM emp WHERE salary BETWEEN 5000 AND 10000;\n# 查询薪水价格是3600或7200或者20000的所有员工信息\n-- 方式1: or\nSELECT * FROM emp WHERE salary = 3600 OR salary = 7200 OR salary = 20000;\n-- 方式2: in()匹配括号中指定的参数\nSELECT * FROM emp WHERE salary IN(3600,7200,20000);\n```\n\n> 模糊查询练习\n\n模糊查询使用like关键字，可以使用通配符进行占位:\n\n- _ : 代表单个任意字符\n- % : 代表任意个数字符\n\n```sql\n# 查询含有'精'字的所有员工信息\nSELECT * FROM emp WHERE ename LIKE '%精%';\n# 查询以'孙'开头的所有员工信息\nSELECT * FROM emp WHERE ename LIKE '孙%';\n# 查询第二个字为'兔'的所有员工信息\nSELECT * FROM emp WHERE ename LIKE '_兔%';\n# 查询没有部门的员工信息\nSELECT * FROM emp WHERE dept_name IS NULL;\n-- SELECT * FROM emp WHERE dept_name = NULL;\n# 查询有部门的员工信息\nSELECT * FROM emp WHERE dept_name IS NOT NULL;\n```\n\n###  排序查询\n\n```sql\nSELECT 字段列表 FROM 表名 ORDER BY 排序字段名1 [排序方式1],排序字段名2 [排序方式2] …;\n```\n\n上述语句中的排序方式有两种，分别是：\n\n- ASC ： 升序排列 **（默认值）**\n\n- DESC ： 降序排列\n\n> 注意：如果有多个排序条件，当前边的条件值一样时，才会根据第二条件进行排序\n\n> 单列排序  使用 salary 字段,对emp 表数据进行排序 (升序/降序)\n\n```sql\n-- 默认升序排序\nASCSELECT * FROM emp ORDER BY salary;\n-- 降序排序\nSELECT * FROM emp ORDER BY salary DESC;\n```\n\n> 组合排序 \n\n同时对多个字段进行排序, 如果第一个字段相同 就按照第二个字段进行排序,以此类推\n\n在薪水排序的基础上,再使用id进行排序, 如果薪水相同就以id 做降序排序\n\n```sql\n-- 组合排序\nSELECT * FROM emp ORDER BY salary DESC, eid DESC;\n```\n\n### 聚合函数   \n\n之前我们做的查询都是横向查询，它们都是根据条件一行一行的进行判断，而使用聚合函数查询是纵向查询，它是对某一列的值进行计算，然后返回一个单一的值(另外聚合函数会忽略null空值。)；\n\n **聚合函数分类**\n\n| 函数名      | 功能                             |\n| ----------- | -------------------------------- |\n| count(列名) | 统计数量（一般选用不为null的列） |\n| max(列名)   | 最大值                           |\n| min(列名)   | 最小值                           |\n| sum(列名)   | 求和                             |\n| avg(列名)   | 平均值                           |\n\n**聚合函数语法**\n\n```sql\nSELECT 聚合函数名(列名) FROM 表;\n```\n\n```sql\n# 1 查询员工的总数\n-- 统计表中的记录条数 使用 count()\nSELECT COUNT(*) FROM emp;-- 使用 *\n#2 查看员工总薪水、最高薪水、最小薪水、薪水的平均值\n-- sum函数求和, max函数求最大, min函数求最小, avg函数求平均值\nSELECTSUM(salary) AS '总薪水',\nMAX(salary) AS '最高薪水',\nMIN(salary) AS '最低薪水',\nAVG(salary) AS '平均薪水'FROM emp;\n#3 查询薪水大于4000员工的个数\nSELECT COUNT(*) FROM emp WHERE salary > 4000;\n#4 查询部门为'教学部'的所有员工的个数\nSELECT COUNT(*) FROM emp WHERE dept_name = '教学部';\n#5 查询部门为'市场部'所有员工的平均薪水\nSELECT AVG(salary) AS '市场部平均薪资' FROM emp WHERE dept_name = '市场部';\n```\n\n### 分组查询\n\n**语法**\n\n```sql\nSELECT 字段列表 FROM 表名 [WHERE 分组前条件限定] GROUP BY 分组字段名 [HAVING 分组后条件过滤];\n```\n\n> 注意：分组之后，查询的字段为聚合函数和分组字段，查询其他字段无任何意义\n\n```sql\n-- 通过性别字段 进行分组,求各组的平均薪资\nSELECT sex, AVG(salary) FROM emp GROUP BY sex;\n-- 查询有几个部门\nSELECT dept_name AS '部门名称' FROM emp GROUP BY dept_name;\n-- 查询每个部门的平均薪资\nSELECT dept_name AS '部门名称', AVG(salary) AS '平均薪资' FROM emp GROUP BY dept_name;\n-- 查询每个部门的平均薪资, 部门名称不能为null\nSELECT dept_name AS '部门名称', AVG(salary) AS '平均薪资' FROM emp WHERE dept_name IS NOT NULL GROUP BY dept_name;\n-- 查询平均薪资大于6000的部门\nSELECT dept_name,AVG(salary) FROM emp WHERE dept_name IS NOT NULL GROUP BY dept_name HAVING AVG(salary) > 6000 ;\n```\n\n**where 和 having 区别：**\n\n- 执行时机不一样：where 是分组之前进行限定，不满足where条件，则不参与分组，而having是分组之后对结果进行过滤。\n\n- 可判断的条件不一样：where 不能对聚合函数进行判断，having 可以。\n\n### 分页查询\n\n**语法**\n\n```sql\nSELECT 字段1,字段2... FROM 表名 LIMIT offset , length;\n# limit offset , length;关键字可以接受一个 或者两个 为0 或者正整数的参数\n# offset 起始行数, 从0开始记数, 如果省略 则默认为 0\n# length 返回的行数\n```\n\n> 注意： 上述语句中的起始索引是从0开始\n\n```sql\n# 查询emp表中的前5条数据\n# 参数1 起始值,默认是0 , 参数2 要查询的条数\nSELECT * FROM emp LIMIT 5;\nSELECT * FROM emp LIMIT 0 , 5;\n# 查询emp表中 从第4条开始,查询6条\nSELECT * FROM emp LIMIT 3 , 6;\n```\n\n> 分页操作 每页显示3条数据\n\n```sql\n-- 分页操作 每页显示3条数据\nSELECT * FROM emp LIMIT 0,3;-- 第1页\nSELECT * FROM emp LIMIT 3,3;-- 第2页2-1=1 1*3=3\nSELECT * FROM emp LIMIT 6,3;-- 第三页\n-- 分页公式 起始索引 = (当前页 - 1) * 每页条数\n-- limit是MySql中的方言\n/*\n起始索引计算公式：起始索引 = (当前页码 - 1) * 每页显示的条数\n*/\n```\n\n### 附加查询\n\n> **UNION ALL**\n\nUNION 操作符用于合并两个或多个 SELECT 语句的结果集。\n\n请注意，UNION 内部的 SELECT 语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每条 SELECT 语句中的列的顺序必须相同。\n\n```sql\n-- UNION 语法\nSELECT column_name(s) FROM table_name1\nUNION\nSELECT column_name(s) FROM table_name2;\n```\n\n**注释：**默认地，UNION 操作符选取不同的值。如果允许重复的值，请使用 UNION ALL。\n\n```sql\n-- UNION ALL 语法\nSELECT column_name(s) FROM table_name1\nUNION ALL\nSELECT column_name(s) FROM table_name2;\n```\n\n> **case when用法**\n\n当我们需要从数据源上 直接判断数据显示代表的含义的时候 ,就可以在SQL语句中使用 Case When这个函数了\n\nCase具有两种格式。简单Case函数和Case搜索函数。\n\n**简单Case函数**\n\n```sql\n/*case 列名\n\n　　　　when 条件值1 then 选择项1\n\n　　　　when 条件值2 then 选项2.......\n\n　　　　else 默认值 end*/\nSELECT name,\nCASE score\n\tWHEN 'A' THEN '优'\n    WHEN 'B' THEN '良'\n    WHEN 'C' THEN '不及格'\n    ELSE '不及格' END\nFROM studen;\n```\n\n**Case搜索函数**\n\n```sql\n　/*case\n\n　　　　when 列名= 条件值1 then 选择项1\n\n　　　　when 列名=条件值2 then 选项2.......\n\n　　　　else 默认值 end*/\nSELECT name,\nCASE \n\tWHEN score>90 THEN '优'\n    WHEN score>70 THEN '良'\n    WHEN score<60 THEN '不及格'\n    ELSE '不及格' END AS get\nFROM studen;\n```\n\n## MySQL约束\n\n**约束的作用:** \n\n对表中的数据进行进一步的限制，从而保证数据的正确性、有效性、完整性. 违反约束的不正确数据,将无法插入到表中 \n\n**常见的约束**\n\n| 约束名 | 约束关键字  |\n| ------ | ----------- |\n| 主键   | primary key |\n| 唯一   | unique      |\n| 非空   | not null    |\n| 外键   | foreign key |\n\n### 主键约束\n\n> 不可重复唯一非空，用来表示数据库中的每一条记录\n\n```sql\n字段名 字段类型 primary key\n```\n\n```sql\n# 方式1 创建一个带主键的表\nCREATE TABLE emp2(\n    -- 设置主键 唯一 非空 \n    eid INT PRIMARY KEY,\n    ename VARCHAR(20),\n    sex CHAR(1)\n);\n# 方式2 创建一个带主键的表\nCREATE TABLE emp2(\n    eid INT ,\n    ename VARCHAR(20),\n    sex CHAR(1),\n    -- 指定主键为 eid字段\n    PRIMARY KEY(eid)\n);\n# 方式3 创建一个带主键的表\n# 创建的时候不指定主键,然后通过 DDL语句进行设置 \nCREATE TABLE emp2(\n    eid INT,\n    ename VARCHAR(20),\n    sex CHAR(1)\n);\nALTER TABLE emp2 ADD PRIMARY KEY(eid);\n```\n\n> 测试主键的唯一性 非空性\n\n```sql\n# 正常插入一条数据\nINSERT INTO emp2 VALUES(1,'宋江','男');\n# 插入一条数据,主键为空\n-- Column 'eid' cannot be null 主键不能为空\nINSERT INTO emp2 VALUES(NULL,'李逵','男');\n# 插入一条数据,主键为 1\n-- Duplicate entry '1' for key 'PRIMARY' 主键不能重复\nINSERT INTO emp2 VALUES(1,'孙二娘','女');\n```\n\n> 删除主键约束\n\n```sql\n-- 使用DDL语句 删除表中的主键\nALTER TABLE emp2 DROP PRIMARY KEY;\nDESC emp2;\n```\n\n> 主键的自增\n>\n> 主键如果让我们自己添加很有可能重复,我们通常希望在每次插入新记录时,数据库自动生成主键字段的值\n\n```sql\n-- 创建主键自增的表\nCREATE TABLE emp2(\n    -- 关键字 AUTO_INCREMENT,主键类型必须是整数类型\n    eid INT PRIMARY KEY AUTO_INCREMENT,\n    ename VARCHAR(20),\n    sex CHAR(1)\n);\n```\n\n> 修改主键自增的起始值\n>\n> 默认地 AUTO_INCREMENT 的开始值是 1,\n\n```sql\n-- 创建主键自增的表,自定义自增其实值\nCREATE TABLE emp2(\n    eid INT PRIMARY KEY AUTO_INCREMENT,\n    ename VARCHAR(20),\n    sex CHAR(1)\n)AUTO_INCREMENT=100;\n```\n\n> DELETE和TRUNCATE对自增长的影响\n\n| 清空表数据 | 特点                                                         |\n| ---------- | ------------------------------------------------------------ |\n| DELETE     | 只是删除表中所有数据,对自增没有影响                          |\n| TRUNCATE   | truncate 是将整个表删除掉,然后创建一个新的表 自增的主键,重新从 1开始 |\n\n通常针对业务去设计主键,每张表都设计一个主键id\n\n主键是给数据库和程序使用的,跟最终的客户无关,所以主键没有意义没有关系,只要能够保证不重复 就好,比如 身份证就可以作为主键\n\n### 非空约束\n\n> 非空约束的特点: 某一列不允许为空\n\n```sql\n字段名 字段类型 not null\n```\n\n```sql\n# 非空约束CREATE TABLE emp2(\n    eid INT PRIMARY KEY AUTO_INCREMENT,\n    -- 添加非空约束, ename字段不能为空\n    ename VARCHAR(20) NOT NULL,\n    sex CHAR(1)\n);\n```\n\n### 唯一约束\n\n> 唯一约束的特点: 表中的某一列的值不能重复( 对null不做唯一的判断 )\n\n```sql\n字段名 字段类型 unique\n```\n\n```sql\n#创建emp3表 为ename 字段添加唯一约束\nCREATE TABLE emp3(\n    eid INT PRIMARY KEY AUTO_INCREMENT,\n    ename VARCHAR(20) UNIQUE,\n    sex CHAR(1)\n);\n```\n\n```sql\n-- 测试唯一约束 添加一条数据\nINSERT INTO emp3 (ename,sex) VALUES('张百万','男');\n-- 添加一条 ename重复的 数据\n-- Duplicate entry '张百万' for key 'ename' ename不能重复\nINSERT INTO emp3 (ename,sex) VALUES('张百万','女');\n```\n\n**主键约束与唯一约束的区别:**\n\n- 主键约束 唯一且不能够为空\n- 唯一约束,唯一 但是可以为空\n- 一个表中只能有一个主键 , 但是可以有多个唯一约束\n\n###  默认约束\n\n> 默认值约束用来指定某列的默认值\n\n```sql\n字段名 字段类型 DEFAULT 默认值 \n```\n\n```sql\n-- 创建带有默认值的表\nCREATE TABLE emp4(\n    eid INT PRIMARY KEY AUTO_INCREMENT,\n    -- 为ename 字段添加默认值\n    ename VARCHAR(20) DEFAULT '奥利给',\n    sex CHAR(1)\n);\n```\n\n```sql\n-- 添加数据 使用默认值\nINSERT INTO emp4(ename,sex) VALUES(DEFAULT,'男');\nINSERT INTO emp4(sex) VALUES('女');\n-- 不使用默认值\nINSERT INTO emp4(ename,sex) VALUES('艳秋','女');\n```\n\n### 外键约束\n\n>FOREIGN KEY 表示外键约束\n>\n>外键用来让两个表的数据之间建立链接，保证数据的一致性和完整性。\n\n```sql\n-- 创建表时添加外键约束\nCREATE TABLE 表名( 列名 数据类型,…[CONSTRAINT] [外键名称] FOREIGN KEY(外键列名) REFERENCES 主表(主表列名) );\n-- 建完表后添加外键约束\nALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称);\n-- 删除外键约束\nALTER TABLE 表名 DROP FOREIGN KEY 外键名称;\n```\n\n```sql\n-- 部门表\nCREATE TABLE dept(\n    id int primary key auto_increment,\n    dep_name varchar(20),\n    addr varchar(20)\n);\n-- 员工表\nCREATE TABLE emp(\n    id int primary key auto_increment,\n    name varchar(20),\n    age int,\n    dep_id int,\n    -- 添加外键 dep_id,关联 dept 表的id主键\n    CONSTRAINT fk_emp_dept FOREIGN KEY(dep_id) REFERENCES dept(id)\n);\n\n-- 添加 2 个部门\ninsert into dept(dep_name,addr) values('研发部','郑州'),\n('销售部', '北京');\n-- 添加员工,dep_id 表示员工所在的部门\nINSERT INTO emp (NAME, age, dep_id) VALUES ('张三', 20, 1),\n('李四', 20, 1),\n('王五', 20, 1),\n('赵六', 20, 2),\n('孙七', 22, 2),\n('周八', 18, 2);\n-- 此时删除研发部这条数据,会发现无法删除。\n-- 删除外键\nalter table emp drop FOREIGN key fk_emp_dept;\n-- 重新添加外键\nalter table emp add CONSTRAINT fk_emp_dept FOREIGN key(dep_id) REFERENCES dept(id);\n```\n\n## 数据库设计\n\n### 数据库设计简介\n\n**数据库设计概念**\n\n- 数据库设计就是根据业务系统的具体需求，结合我们所选用的DBMS，为这个业务系统构造出最优的数据存储模型。\n\n- 建立数据库中的表结构以及表与表之间的关联关系的过程。\n\n- 有哪些表？表里有哪些字段？表和表之间有什么关系？\n\n**数据库设计的步骤**\n\n- 需求分析（数据是什么? 数据具有哪些属性? 数据与属性的特点是什么）\n\n  逻辑分析（通过ER图对数据库进行逻辑建模，不需要考虑我们所选用的数据库管理系统）\n\n- ER图（entity relationship diagram) 实体关系图 ：提供了实体类型、属性和关系的方法，用来描述现实世界的概念模型\n\n- 实体用矩形表示，属性用椭圆表示，主键学号需要加下划线\n\n- 表关系\n\n    - 一对一  一夫一妻制\n      - 如：用户（用户名字 密码 ） 和 用户详情 ()\n      - 一对一关系多用于表拆分，将一个实体中经常使用的字段放一张表，不经常使用的字段放另一张表，用于提升查询性能\n\n  - 一对多\n\n    - 如：部门 和 员工\n\n    - 一个部门对应多个员工，一个员工对应一个部门。\n\n  - 多对多\n\n     - 如：商品 和 订单\n     \n     - 一个商品对应多个订单，一个订单包含多个商品。\n\n###  表关系(一对多)\n\n>实现方式：在多的一方建立外键，指向一的一方的主键\n\n我们还是以 员工表 和 部门表 举例:\n员工表属于多的一方，而部门表属于一的一方，此时我们会在员工表中添加一列(dep_id)，指向于部门表的主键（id）\n\n```sql\n-- 部门表\nCREATE TABLE tb_dept(\n    id int primary key auto_increment,\n    dep_name varchar(20),\n    addr varchar(20)\n);\n-- 员工表\nCREATE TABLE tb_emp(\n    id int primary key auto_increment,\n    name varchar(20),\n    age int,\n    dep_id int,\n    -- 添加外键 dep_id,关联 dept 表的id主键\n    CONSTRAINT fk_emp_dept FOREIGN KEY(dep_id) REFERENCES tb_dept(id)\n);\n```\n\n###  表关系(多对多)\n\n>实现方式：建立第三张中间表，中间表至少包含两个外键，分别关联两方主键\n\n我们以 订单表 和 商品表 举例：\n经过分析发现，订单表和商品表都属于多的一方，此时需要创建一个中间表，在中间表中添加订单表的外键和商品表的外键指向两张表的主键\n\n```sql\n-- 订单表\nCREATE TABLE tb_order(\n    id int primary key auto_increment,\n    payment double(10,2),\n    payment_type TINYINT,\n    status TINYINT\n);\n-- 商品表\nCREATE TABLE tb_goods(\n    id int primary key auto_increment,\n    title varchar(100),\n    price double(10,2)\n);\n-- 订单商品中间表\nCREATE TABLE tb_order_goods(\n    id int primary key auto_increment,\n    order_id int,\n    goods_id int,\n    count int\n);\n-- 建完表后，添加外键\nalter table tb_order_goods add\nCONSTRAINT fk_order_id FOREIGN key(order_id) REFERENCES tb_order(id);\nalter table tb_order_goods add\nCONSTRAINT fk_goods_id FOREIGN key(goods_id) REFERENCES tb_goods(id);\n```\n\n###  表关系(一对一)\n\n>实现方式：在任意一方加入外键，关联另一方主键，并且设置外键为唯一(UNIQUE)\n\n```sql\ncreate table tb_user_desc (\n    id int primary key auto_increment,\n    city varchar(20),\n    edu varchar(10),\n    income int,\n    status char(2),\n    des varchar(100)\n);\ncreate table tb_user (\n    id int primary key auto_increment,\n    photo varchar(100),\n    nickname varchar(50),\n    age int,\n    gender char(1),\n    desc_id int unique,\n    -- 添加外键\n    CONSTRAINT fk_user_desc FOREIGN KEY(desc_id)\n    REFERENCES tb_user_desc(id)\n);\n```\n\n## 多表查询\n\n> DQL: 查询多张表,获取到需要的数据\n\n```sql\n-- 创建 db3_2 数据库,指定编码\nCREATE DATABASE db3_2 CHARACTER SET utf8;\n-- 分类表 (一方 主表)\nCREATE TABLE category (\n    cid VARCHAR(32) PRIMARY KEY,\n    cname VARCHAR(50)\n);\n-- 商品表 (多方 从表)\nCREATE TABLE products(\n    pid VARCHAR(32) PRIMARY KEY,\n    pname VARCHAR(50),\n    price INT,\n    flag VARCHAR(2),\n    -- 是否上架标记为:1表示上架、0表示下架\n    category_id VARCHAR(32),\n    -- 添加外键约束\n    FOREIGN KEY (category_id) REFERENCES category (cid)\n);\n\n-- 插入数据\n-- 分类数据\nINSERT INTO category(cid,cname) VALUES('c001','家电');\nINSERT INTO category(cid,cname) VALUES('c002','鞋服');\nINSERT INTO category(cid,cname) VALUES('c003','化妆品');\nINSERT INTO category(cid,cname) VALUES('c004','汽车');\n-- 商品数据\nINSERT INTO products(pid, pname,price,flag,category_id) VALUES('p001','小米电视 机',5000,'1','c001');\nINSERT INTO products(pid, pname,price,flag,category_id) VALUES('p002','格力空调',3000,'1','c001');\nINSERT INTO products(pid, pname,price,flag,category_id) VALUES('p003','美的冰箱',4500,'1','c001');\nINSERT INTO products(pid, pname,price,flag,category_id) VALUES('p004','篮球鞋',800,'1','c002');\nINSERT INTO products(pid, pname,price,flag,category_id) VALUES('p005','运动裤',200,'1','c002');\nINSERT INTO products(pid, pname,price,flag,category_id) VALUES('p006','T恤',300,'1','c002');\nINSERT INTO products(pid, pname,price,flag,category_id) VALUES('p007','冲锋衣',2000,'1','c002');\nINSERT INTO products(pid, pname,price,flag,category_id) VALUES('p008','神仙水',800,'1','c003');\nINSERT INTO products(pid, pname,price,flag,category_id) VALUES('p009','大宝',200,'1','c003');\n```\n\n### 笛卡尔积\n\n> 交叉连接查询,因为会产生笛卡尔积,所以 基本不会使用\n\n```sql\nSELECT 字段名 FROM 表1, 表2;\n```\n\n```sql\n-- 使用交叉连接查询 商品表与分类表\nSELECT * FROM category,products;\n```\n\n### 内连接查询\n\n> 通过指定的条件去匹配两张表中的数据, 匹配上就显示,匹配不上就不显示\n\n**隐式内连接**\n\n>from子句后面直接写多个表名使用where指定连接条件的 这种连接方式是 隐式内连接\n>\n>使用where条件过滤无用的数据\n\n```sql\nSELECT 字段名 FROM 左表, 右表 WHERE 连接条件;\n```\n\n```sql\n-- 查询所有商品信息和对应的分类信息\nSELECT * FROM products,category WHERE category_id = cid;\n```\n\n查询商品表的商品名称 和 价格,以及商品的分类信息\n\n可以通过给表起别名的方式, 方便我们的查询\n\n```sql\nSELECT\np.`pname`,\np.`price`,\nc.`cname`FROM products p,category c WHERE p.`category_id` = c.`cid`;\n-- 查询 格力空调是属于哪一分类下的商品\nSELECT p.`pname`,c.`cname`\nFROM products p,category c\nWHERE p.`category_id` = c.`cid` AND p.`pid` = 'p002';\n```\n\n**显式内连接**\n\n> 使用 inner join …on 这种方式, 就是显式内连接\n\n```sql\nSELECT 字段名 FROM 左表 [INNER] JOIN 右表 ON 条件-- inner 可以省略\n```\n\n```sql\n-- 查询所有商品信息和对应的分类信息\nSELECT * FROM products p INNER JOIN category c ON p.category_id = c.cid;\n-- 查询鞋服分类下,价格大于500的商品名称和价格\n-- 我们需要确定的几件事\n-- 1.查询几张表 products & category\n-- 2.表的连接条件 从表.外键 = 主表的主键\n-- 3.查询的条件 cname = '鞋服' and price > 500 \n-- 4.要查询的字段 pname price\nSELECT p.pname,p.price\nFROM products p INNER JOIN category c\nON p.category_id = c.cid\nWHERE p.price > 500 AND cname = '鞋服';\n```\n\n### 外连接查询\n\n**左外连接**\n\n- 左外连接 , 使用 LEFT OUTER JOIN , OUTER 可以省略\n\n- 左外连接的特点\n  - 以左表为基准, 匹配右边表中的数据,如果匹配的上,就展示匹配到的数据\n  - 如果匹配不到, 左表中的数据正常展示, 右边的展示为null\n\n```sql\nSELECT 字段名 FROM 左表 LEFT [OUTER] JOIN 右表 ON 条件\n-- 左外连接查询\nSELECT * FROM category c LEFT JOIN products p ON c.`cid`= p.`category_id`;\n-- 查询每个分类下的商品个数\n/*1.连接条件: 主表.主键 = 从表.外键\n2.查询条件: 每个分类 需要分组\n3.要查询的字段: 分类名称, 分类下商品个数*/\nSELECT\tc.`cname` AS '分类名称',\nCOUNT(p.`pid`) AS '商品个数'\nFROM category c LEFT JOIN products p\nON c.`cid` = p.`category_id`\nGROUP BY c.`cname`;\n```\n\n**右外连接**\n\n- 右外连接 , 使用 RIGHT OUTER JOIN , OUTER 可以省略\n\n- 右外连接的特点\n  - 以右表为基准，匹配左边表中的数据，如果能匹配到，展示匹配到的数据\n  - 如果匹配不到，右表中的数据正常展示, 左边展示为null\n\n  ```sql\nSELECT 字段名 FROM 左表 RIGHT [OUTER ]JOIN 右表 ON 条件\n-- 右外连接查询\nSELECT * FROM products p RIGHT JOIN category c ON p.`category_id` = c.`cid`;\n  ```\n\n![SQL JOINS](https://image.aobayu.cn/images/join.png)\n\n### 子查询\n\n- 子查询概念\n  - 一条select 查询语句的结果, 作为另一条 select 语句的一部分\n\n- 子查询的特点\n  - 子查询必须放在小括号中\n  - 子查询一般作为父查询的查询条件使用\n\n- 子查询常见分类\n  - where型 子查询: 将子查询的结果, 作为父查询的比较条件\n  - from型 子查询 : 将子查询的结果, 作为 一张表,提供给父层查询使用\n  - exists型 子查询: 子查询的结果是单列多行, 类似一个数组, 父层查询使用 IN 函数 ,包含子查询的结果\n\n```sql\nSELECT 查询字段 FROM 表 WHERE 字段=(子查询);\n```\n\n```sql\n-- 通过子查询的方式, 查询价格最高的商品信息\n-- 1.先查询出最高价格\nSELECT MAX(price) FROM products;\n-- 2.将最高价格作为条件,获取商品信息\nSELECT * FROM products WHERE price = (SELECT MAX(price) FROM products);\n-- #查询化妆品分类下的 商品名称 商品价格\n-- 先查出化妆品分类的id\nSELECT cid FROM category WHERE cname = '化妆品';\n-- 根据分类id ,去商品表中查询对应的商品信息\nSELECT\tp.`pname`,p.`price` FROM products p WHERE p.`category_id` = (SELECT cid FROM category WHERE cname = '化妆品');\n-- 1.查询平均价格\nSELECT AVG(price) FROM products;-- 1866\n-- 2.查询小于平均价格的商品\nSELECT * FROM products WHERE price < (SELECT AVG(price) FROM products);\n```\n\n**子查询的结果作为一张表**\n\n```sql\nSELECT 查询字段 FROM (子查询)表别名 WHERE 条件;\n```\n\n```sql\n-- 查询商品中,价格大于500的商品信息,包括 商品名称 商品价格 商品所属分类名称\n-- 1.先查询分类表的数据\nSELECT * FROM category;\n-- 2.将上面的查询语句 作为一张表使用 \nSELECT p.`pname`,p.`price`,c.cname FROM products p\n-- 子查询作为一张表使用时 要起别名 才能访问表中字段\nINNER JOIN (SELECT * FROM category) c\nON p.`category_id` = c.cid WHERE p.`price` > 500;\n```\n\n**子查询结果是单列多行**\n\n子查询的结果类似一个数组, 父层查询使用 IN 函数 ,包含子查询的结果\n\n```sql\nSELECT 查询字段 FROM 表 WHERE 字段 IN (子查询);\n```\n\n```sql\n-- 查询价格小于两千的商品,来自于哪些分类(名称)\n-- 先查询价格小于2000 的商品的,分类\nIDSELECT DISTINCT category_id FROM products WHERE price < 2000;\n-- 在根据分类的id信息,查询分类名称\n-- 报错: Subquery returns more than 1 row\n-- 子查询的结果 大于一行\nSELECT * FROM category WHERE cid = (SELECT DISTINCT category_id FROM products WHERE price < 2000);\n-- 子查询获取的是单列多行数据\nSELECT * FROM category WHERE cid\nIN (SELECT DISTINCT category_id FROM products WHERE price < 2000);\n```\n\n```sql\n-- 查询家电类 与 鞋服类下面的全部商品信息\n-- 先查询出家电与鞋服类的 分类ID\nSELECT cid FROM category WHERE cname IN ('家电','鞋服');\n-- 根据cid 查询分类下的商品信息\nSELECT * FROM products\nWHERE category_id\nIN (SELECT cid FROM category WHERE cname IN ('家电','鞋服'));\n```\n\n**子查询总结**\n\n- 子查询如果查出的是一个字段(单列), 那就在where后面作为条件使用\n- 子查询如果查询出的是多个字段(多列), 就当做一张表使用(要起别名)\n\n## 事务\n\n>数据库的事务（Transaction）是一种机制、一个操作序列，包含了一组数据库操作命令。\n>\n>事务把所有的命令作为一个整体一起向系统提交或撤销操作请求，即这一组数据库命令要么同时成功，要么同时失败。\n>\n>事务是一个不可分割的工作逻辑单元。\n\n张三和李四账户中各有100块钱，现李四需要转换500块钱给张三，具体的转账操作为\n\n- 第一步：查询李四账户余额\n\n- 第二步：从李四账户金额 -500\n\n- 第三步：给张三账户金额 +500\n\n现在假设在转账过程中第二步完成后出现了异常第三步没有执行，就会造成李四账户金额少了500，而张三金额并没有多500；这样的系统是有问题的。如果解决呢？使用事务可以解决上述问题\n\n **语法**\n\n```sql\n-- 开启事务\nSTART TRANSACTION; 或者 BEGIN;\n-- 提交事务\ncommit;\n-- 回滚事务\nrollback;\n```\n\n### 模拟转账操作\n\n```sql\n-- 创建账户表\nCREATE TABLE account(\n    -- 主键\n    id INT PRIMARY KEY AUTO_INCREMENT,\n    -- 姓名\n    NAME VARCHAR(10),\n    -- 余额\n    money DOUBLE\n);\n-- 添加两个用户\nINSERT INTO account (NAME, money) VALUES ('tom', 1000), ('jack', 1000);\n```\n\n> 模拟tom 给 jack 转 500 元钱，一个转账的业务操作最少要执行下面的 2 条语句:\n\n```sql\n-- tom账户 -500元\nUPDATE account SET money = money - 500 WHERE NAME = 'tom';\n-- jack账户 + 500元\nUPDATE account SET money = money + 500 WHERE NAME = 'jack';\n```\n\n假设当tom 账号上 -500 元,服务器崩溃了。jack 的账号并没有+500 元，数据就出现问题了。 我们要保证整个事务执行的完整性,要么都成功, 要么都失败. 这个时候我们就要学习如何操作事务\n\n### Mysql事务操作\n\nMYSQL 中可以有两种方式进行事务的操作:\n\n- 手动提交事务\n\n- 自动提交事务\n\n| 功能     | 语句                           |\n| -------- | ------------------------------ |\n| 开启事务 | start transaction; 或者 BEGIN; |\n| 提交事务 | commit;                        |\n| 回滚事务 | rollback;                      |\n\n```sql\nSTART TRANSACTION\n    -- 这个语句显式地标记一个事务的起始点。\nCOMMIT\n    -- 表示提交事务，即提交事务的所有操作，具体地说，\n    -- 就是将事务中所有对数据库的更新都写到磁盘上的物理数据库中，事务正常结束。\nROLLBACK\n    -- 表示撤销事务，即在事务运行的过程中发生了某种故障，事务不能继续执行，\n    -- 系统将事务中对数据库的所有已完成的操作全部撤销，回滚到事务开始时的状态\n```\n\n**手动提交事务流程**\n\n- 执行成功的情况: 开启事务 -> 执行多条 SQL 语句 -> 成功提交事务\n\n- 执行失败的情况: 开启事务 -> 执行多条 SQL 语句 -> 事务的回滚\n\n模拟张三给李四转 500 元钱\n\n```sql\n-- 开启事务\nstart transaction;\n```\n\n```sql\n-- tom账户 -500\nupdate account set money = money - 500 where name = 'tom'\n-- jack账户 +500\nupdate account set money = money + 500 where name = 'jack';\n```\n\n```sql\n-- 注：由于未提交事务，此时数据并未变化\n-- 在控制台执行 commit 提交事务\ncommit;\n```\n\n以上操作为提交事务后，才会真正执行，中间有异常也不会对数据有影响\n\n如是自动事务，每次update数据都会真实改变\n\n> 查看autocommit状态\n\n```sql\nSHOW VARIABLES LIKE 'autocommit';\n-- on :自动提交\n-- off : 手动提交\nSELECT @@autocommit;\n\n-- 把 autocommit 改成 off;\nSET @@autocommit=off;\n-- 1表示自动 0 表示手动\nset @@autocommit = 0;\n\n-- 修改数据\nupdate account set money = money - 500 where name = 'jack';\n-- 手动提交\ncommit;\n```\n\n### 事务的四大特征\n\n- 原子性（Atomicity）: 事务是不可分割的最小操作单位，要么同时成功，要么同时失败\n\n- 一致性（Consistency） :事务完成时，必须使所有的数据都保持一致状态\n\n- 隔离性（Isolation） :多个事务之间，操作的可见性\n\n- 持久性（Durability） :事务一旦提交或回滚，它对数据库中的数据的改变就是永久的\n\n### 事务的隔离级别（了解）\n\nMySQL是一个客户端／服务器架构的软件，对于同一个服务器来说，可以有若干个客户端与之连接，每个客户端与服务器连接上之后，就可以称之为一个会话（Session）。每个客户端都可以在自己的会话中向服务器发出请求语句，一个请求语句可能是某个事务的一部分，也就是对于服务器来说可能同时处理多个事务。\n\n**事务并发执行遇到的问题**\n\n> **脏读(Dirty Read)**\n\n 如果一个事务读到了另一个未提交事务修改过的数据，那就意味着发生了**脏读**\n\n![Dirty Read](https://image.aobayu.cn/images/DirtyRead.png)\n\n如上图，Session A和Session B各开启了一个事务，Session B中的事务先将number列为1的记录的name列更新为'关羽'，然后Session A中的事务再去查询这条number为1的记录，如果读到列name的值为'关羽'，而Session B中的事务稍后进行了回滚，那么Session A中的事务相当于读到了一个不存在的数据，这种现象就称之为脏读。\n\n> **不可重复读（ Non-Repeatable Read）**\n\n如果一个事务只能读到另一个已经提交的事务**修改**过的数据，并且其他事务每对该数据进行一次修改并提交后，该事务都能查询得到最新值，那就意味着发生了**不可重复读**\n\n![Non-Repeatable Read](https://image.aobayu.cn/images/Non-Repeatable-Read.png))\n\n如上图，我们在Session B中提交了几个隐式事务（注意是隐式事务，意味着语句结束事务就提交了），这些事务都修改了number列为1的记录的列name的值，每次事务提交之后，如果Session A中的事务都可以查看到最新的值，这种现象也被称之为不可重复读。\n\n> **幻读（Phantom）**\n\n如果一个事务先根据某些条件查询出一些记录，之后另一个事务又向表中**插入**了符合这些条件的记录，原先的事务再次按照该条件查询时，能把另一个事务插入的记录也读出来，那就意味着发生了幻读\n\n![Phantom](https://image.aobayu.cn/images/Phantom.png)\n\n如上图，Session A中的事务先根据条件number > 0这个条件查询表hero，得到了name列值为'刘备'的记录；之后Session B中提交了一个隐式事务，该事务向表hero中插入了一条新记录；之后Session A中的事务再根据相同的条件number > 0查询表hero，得到的结果集中包含Session B中的事务新插入的那条记录，这种现象也被称之为幻读。\n\n**tips:**\n\n那对于先前已经读到的记录，之后又读取不到这种情况，算啥呢？其实这相当于对每一条记录都发生了不可重复读的现象。幻读只是重点强调了读取到了之前读取没有获取到的记录\n\n**SQL标准中的四种隔离级别**\n\n根据以上严重程度，做一个排序\n\n脏读 > 不可重复读 > 幻读\n\n根据以上问题 ，SQL设置了隔离级别\n\n- READ UNCOMMITTED：未提交读。\n- READ COMMITTED：已提交读。\n- REPEATABLE READ：可重复读。\n- SERIALIZABLE：可串行化。\n\n**存在的问题:**\n\n| **隔离级别**               | **脏读** | **不可重复读** | **幻读** |\n| -------------------------- | -------- | -------------- | -------- |\n| 读未提交(READ UNCOMMITTED) | √        | √              | √        |\n| 读已提交(READ COMMITTED)   | ×        | √              | √        |\n| 可重复读(REPEATABLE READ)  | ×        | ×              | √        |\n| 可串行化(SERIALIZABLE)     | ×        | ×              | ×        |\n\n也就是说:\n\n- READ UNCOMMITTED 隔离级别下，可能发生脏读、不可重复读和幻读问题。\n- READ COMMITTED 隔离级别下，可能发生不可重复读和幻读问题，但是不可以发生脏读问题。\n- REPEATABLE READ 隔离级别下，可能发生幻读问题，但是不可以发生脏读和不可重复读的问题。\n- SERIALIZABLE隔离级别下，各种问题都不可以发生。\n\n## 数据库设计三大范式\n\n**第一范式（1NF）**: 确保每一列的原子性（做到每列不可拆分）\n\n**第二范式（2NF）**:在第一范式的基础上，每一行必须可以唯一的被区分，因此需要为表加上主键列\n\n**第三范式（3NF）**:在第二范式的基础上，一个表中不包含已在其他表中包含的非主关键字信息（外键）\n\n**反范式**: 有时候为了兼顾效率，可以不遵循范式，设计冗余字段，如订单（总价）和订单项（单价）\n\n## 数据库的备份和还原\n\n```sql\n-- 备份\nmysqldump -u用户名 -p密码 数据库名 > 保存的路径\nmysqldump -uroot -p123456 db1 > d://a.sql\n```\n\n```sql\n-- 还原\ndrop database db1;\ncreate database db1;\nuse db1;\nsource d://a.sql\n```\n\n## MySQL存储引擎\n\n**什么是存储引擎：**\n\nsql  ----> 解析器 ------>优化器 ----->搜索引擎\n\n数据库存储引擎是数据库底层软件组织，数据库管理系统（DBMS）使用数据引擎进行创建、查询、更新和删除数据。不同的存储引擎提供不同的**存储机制、索引技巧、锁定水平**等功能，使用不同的存储引擎，还可以 获得特定的功能。现在许多不同的数据库管理系统都支持多种不同的数据引擎。MySQL的核心就是存储引擎。\n\n```sql\n-- 查看当前mysql默认引擎: \nshow variables like '%engine%';\n```\n\n```sql\n-- 查看mysql支持哪些引擎：\nshow engines;\n```\n\n```sql\n-- 修改默认存储引擎\n-- 如果修改本次会话的默认存储引擎(重启后失效)，只对本会话有效，其他会话无效：\nset default_storage_engine=innodb;\n```\n\n```sql\n-- 修改全局会话默认存储引擎(重启后失效)，对所有会话有效\nset global default_storage_engine=innodb;\n```\n\n### InnoDB\n\nInnoDB是一个健壮的事务型存储引擎，这种存储引擎已经被很多互联网公司使用，为用户操作非常大的数据存储提供了一个强大的解决方案。\n\nInnoDB还引入了行级锁定和外键约束，在以下场合下，使用InnoDB是最理想的选择：\n\n **优点:**\n\n-  更新密集的表。 InnoDB存储引擎特别适合处理多重并发的更新请求。 \n\n-  事务。 InnoDB存储引擎是支持事务的标准MySQL存储引擎。 \n\n-  自动灾难恢复。 与其它存储引擎不同，InnoDB表能够自动从灾难中恢复。 \n\n-  外键约束。 MySQL支持外键的存储引擎只有InnoDB。 \n\n-  支持自动增加列AUTO_INCREMENT属性。 \n\n-  从5.5开始innodb存储引擎成为默认的存储引擎。 \n\n一般来说，如果需要事务支持，并且有较高的并发读取频率，InnoDB是不错的选择。\n\nInnoDB是一个健壮的事务型存储引擎,这种存储引擎已经被很多互联网公司使用,为用户操作非常大的数据存储提供了一个强大的解决方案。 \n\nInnoDB还引入了行级锁定和外键约東,在以下场合下,使用 InnoDB是最理想的选择\n\n**优点**\n\n- Innodb引擎提供了对数据库ACID事务的支持,并且实现了SQL标准的四种隔离级别\n\n- 支持多版本并发控制的行级锁,由于锁粒度小,写操作和更新操作并发高、速度快\n\n- 支持自增长列。\n\n- 支持外键 \n\n- 适合于大容量数据库系统,\n\n- 支持自动灾难恢复\n\n**缺点**\n\n- 它没有保存表的行数 SELECT COUNT(*) FROM TABLE时需要扫描全表\n\n**应用场景**\n\n- 当需要使用数据库事务时,该引擎当然是首选。由于锁的粒度更小,写操作不会锁定全表,所以在并发较高时,使用 Innodb引擎会提升效率。更新密集的表, InnoDB.存储引擎特别适合处理多重并发的更新请求\n\n### MyISAM\n\nMyISam引擎不支持事务、也不支持外键,优势是访问速度快,对事务完整性没有要求或者以 select, Insert为主的应用基本上可以用这个引擎来创建表\n\n**优点**\n\n- MyISAM表是独立于操作系统的,这说明可以轻松地将其从 windows服务器移植到Liux服务器\n\n- MyISAM存储引擎在查询大量数据时非常迅速,这是它最突出的优点\n\n- 另行大批量插入操作时执行速度也比较快\n\n**缺点**\n\n- MyISAM表没有提供对数据库事务的支持。\n\n- 不支持行级锁和外键。\n\n- 不适合用于经常 UPDATE(更新)的表\n\n**应用场景**\n\n- 以读为主的业务,例如:图片信息数据库,博客数据库,商品库等业务\n\n- 对数据一致性要求不是非常高的业务(不支持事务)\n\n- 硬件资源比较差的机器可以用 MyISAM(占用资源少)\n\n### MEMORY\n\nMEMORY的特点是将表中的数据放在内存中,适用于存储临时数据的临时表和数据仓库中的纬度表\n\n**优点**\n\n- memory类型的表访问非常的快,因为它的数据是放在内存中的\n\n**缺点**\n\n- 一旦服务关闭,表中的数据就会丢失掉\n\n- 只支持表锁,并发性能差,不支持TEXT和BLOB列类型,存储 varchar时是按照char的方式\n\n**应用场景**\n\n- 目标数据较小,而且被非常频繁地访问。\n\n- 如果数据是临时的,而且要求必须立即可用,那么就可以存放在内存表中。\n\n- 存储在 Memory表中的数据如果突然丢失,不会对应用服务产生实质的负面影响\n\n**存储引擎的选择**\n\n不同的存储引擎都有各自的特点，以适应不同的需求，如下表所示：\n\n| **功 能**    | **MYISAM** | **Memory** | **InnoDB** | **Archive** |\n| ------------ | ---------- | ---------- | ---------- | ----------- |\n| 存储限制     | 256TB      | RAM        | 64TB       | None        |\n| 支持事务     | No         | No         | Yes        | No          |\n| 支持全文索引 | Yes        | No         | No         | No          |\n| 支持数索引   | Yes        | Yes        | Yes        | No          |\n| 支持哈希索引 | No         | Yes        | No         | No          |\n| 支持数据缓存 | No         | N/A        | Yes        | No          |\n| 支持外键     | No         | No         | Yes        | No          |\n\n- 如果要提供提交、回滚、崩溃恢复能力的事物安全（ACID兼容）能力，并要求实现并发控制，InnoDB是一个好的选择\n\n- 如果数据表主要用来插入和查询记录，则MyISAM引擎能提供较高的处理效率\n\n- 如果只是临时存放数据，数据量不大，并且不需要较高的数据安全性，可以选择将数据保存在内存中的Memory引擎，MySQL中使用该引擎作为临时表，存放查询的中间结果\n\n- 如果只有INSERT和SELECT操作，可以选择Archive，Archive支持高并发的插入操作，但是本身不是事务安全的。Archive非常适合存储归档数据，如记录日志信息可以使用Archive\n\n使用哪一种引擎需要灵活选择，**一个数据库中多个表可以使用不同引擎以满足各种性能和实际需求**，使用合适的存储引擎，将会提高整个数据库的性能。\n\n### Mysql索引数据结构 B-树和B+树\n\n**索引类型:**\n\n- 哈希索引 \n  - 只能做等值比较，不支持范围查找\n  - 无法利用索引完成排序\n  - 如果存在大量重复键值的情况下，哈希索引效率会比较低，可能存在哈希碰撞\n\n- B-树/B+树\n  - B 代表 balance 平衡的意思，是一种多路自平衡的搜索树\n  - InnoDB 引擎 默认使用B+树，Memory默认使用 B树\n  - B树所有节点都储存数据，B+树只在叶子节点储存，为了降低树的高度，每一层可以保存多个节点（>2个）\n  - 为了支持范围查询，B+树在叶子节点之间加上了双向链表，减少IO次数","tags":["MySQL"],"categories":["学习之路"]},{"title":"集合","url":"/2022/09/20/集合/","content":"\n## 集合概述\n\n当需要在Java程序中记录单个数据内容时，则声明一个变量。 \n\n当需要在Java程序中记录多个类型相同的数据内容时，声明一个一维数组。 \n\n当需要在Java程序中记录多个类型不同的数据内容时，则创建一个对象。 \n\n当需要在Java程序中记录多个类型相同的对象数据时，创建一个对象数组。 \n\n当需要在Java程序中记录多个类型不同的对象数据时，则准备一个集合。\n\n### 集合的框架结构\n\n集合的框架结构 Java中集合框架顶层框架是：java.util.**Collection**集合 和 java.util.**Map**集合。 \n\n其中Collection集合中存取元素的基本单位是：单个元素。 \n\n其中Map集合中存取元素的基本单位是：单对元素。\n\n### Collection集合\n\njava.util.Collection接口是List接口、Queue 接口以及Set接口的父接口，因此该接口里定义的方法 既可用于操作List集合，也可用于操作Queue集合和Set集合。\n\n### 常用的方法\n\n方法如下：\n\n- `public boolean add(E e)`：  把给定的对象添加到当前集合中 。\n\n- `public void clear()` :清空集合中所有的元素。\n\n- `public boolean remove(E e)`: 把给定的对象在当前集合中删除。\n\n- `public boolean contains(E e)`: 判断当前集合中是否包含给定的对象。\n\n- `public boolean isEmpty()`: 判断当前集合是否为空。\n\n- `public int size()`: 返回集合中元素的个数。\n\n- `public Object[] toArray()`: 把集合中的元素，存储到数组中。\n\n```java\npublic static void main(String[] args) {\n        //创建集合对象\n        //使用多态形式\n        Collection<String> coll = new ArrayList<String>();\n        //使用方法\n        //添加功能boolean add(String s)\n        coll.add(\"小李广\");\n        coll.add(\"扫地僧\");\n        coll.add(\"石破天\");\n        System.out.println(coll);\n        //boolean contains(E e) 判断o是否在集合中存在\n        System.out.println(\"判断 扫地僧 是否在集合中\"+coll.contains(\"扫地僧\"));\n        //boolean remove(E e) 删除在集合中的o元素\n        System.out.println(\"删除石破天：\"+coll.remove(\"石破天\"));\n        System.out.println(\"操作之后集合中元素:\"+coll);\n        //size() 集合中有几个元素\n        System.out.println(\"集合中有\"+coll.size()+\"个元素\");\n        //Object[] toArray()转换成一个Object数组\n        Object[] objects = coll.toArray();\n        //遍历数组\n        for (int i = 0; i < objects.length; i++) {\n            System.out.println(objects[i]);\n        }\n        //void clear() 清空集合\n        coll.clear();\n        System.out.println(\"集合中内容为：\"+coll);\n        //boolean isEmpty() 判断是否为空\n        System.out.println(coll.isEmpty());\n\n}\n```\n\n## Iterator接口\n\njava.util.Iterator接口主要用于描述迭代器对象，可以遍历Collection集合中的所有元素。 java.util.Collection接口继承Iterator接口，因此所有实现Collection接口的实现类都可以使用该迭代器对象。\n\n| 方法声明          | 功能介绍                            |\n| ----------------- | ----------------------------------- |\n| boolean hasNext() | 判断集合中是否有可以迭代/访问的元素 |\n| E next()          | 用于取出一个元素并指向下一个元素    |\n| void remove()     | 用于删除访问到的最后一个元素        |\n\n```java\npublic static void main(String[] args) {\n     //1.准备一个Collection集合并放入元素后打印\n     Collection c1 = new ArrayList();\n     c1.add(\"one\");\n     c1.add(2);\n     c1.add(new Person(\"zhangfei\", 30));//遍历方式一：自动调用toString方法 String类型的整体\n     System.out.println(\"c1 = \" + c1);\n     //[one, 2, Person{name='zhangfei', age=30}]\n     System.out.println(\"-----------------------------\");\n     //2.遍历方式二：使用迭代器来遍历集合中的所有元素 更加灵活\n     //2.1获取当前集合中的迭代器对象\n     Iterator iterator1 = c1.iterator();//2.2判断是否有元素可以访问\n     System.out.println(iterator1.hasNext()); //true//2.3取出一个元素并指向下一个\n     System.out.println(\"获取到的元素是：\" + iterator1.next());//one\n     System.out.println(iterator1.hasNext());//true\n     System.out.println(\"获取到的元素是：\" + iterator1.next());//2\n     System.out.println(iterator1.hasNext());//true\n     System.out.println(\"获取到的元素是：\" + iterator1.next());\n     //Person{name='zhangfei', age=30}\n     System.out.println(iterator1.hasNext());//false\n     //编译ok，运行发生NoSuchElementException没有这样的元素异常\n     System.out.println(\"获取到的元素是：\" + iterator1.next());\n     while(iterator1.hasNext()){\n         System.out.println(\"获取到的元素是：\" + iterator1.next());\n     }\n}\n```\n\n> 遍历集合\n\n```java\npublic static void main(String[] args) {\n    Collection<String> coll = new ArrayList<String>();\n    coll.add(\"hd\");\n    coll.add(\"jc\");\n    coll.add(\"wyb\");\n    //使用增强for遍历\n    for(String s :coll){\n        //接收变量s代表 代表被遍历到的集合元素\n        System.out.println(s);\n    }\n}\n```\n\n## List集合\n\n**基本概念**\n\njava.util.List集合是Collection集合的子集合，该集合中允许有重复的元素并且有先后放入次序。 \n\n该集合的主要实现类有：ArrayList类、LinkedList类、Stack类、Vector类。 \n\n其中ArrayList类的底层是采用动态数组进行数据管理的，支持下标访问，增删元素不方便。 \n\n其中LinkedList类的底层是采用双向链表进行数据管理的，访问不方便，增删元素方便。\n\nArrayList 更适合于随 机访问而LinkedList更适合于插入和删除；在性能要求不是特别苛刻的情形下可以忽略这个差别。 \n\n其中Stack类的底层是采用动态数组进行数据管理的，该类主要用于描述一种具有后进先出特征的 数据结构，叫做栈(last in first out LIFO)。\n\n其中Vector类的底层是采用动态数组进行数据管理的，该类与ArrayList类相比属于线程安全的 类，效率比较低，以后开发中基本不用。\n\n### 常用方法\n\nList作为Collection集合的子接口，不但继承了Collection接口中的全部方法，而且还增加了一些根据元素索引来操作集合的特有方法，如下：\n\n- `public void add(int index, E element)`: 将指定的元素，添加到该集合中的指定位置上。\n\n- `public E get(int index)`:返回集合中指定位置的元素。\n\n- `public E remove(int index)`: 移除列表中指定位置的元素, 返回的是被移除的元素。\n\n- `public E set(int index, E element)`:用指定元素替换集合中指定位置的元素,返回值的更新前的元素。\n\n```java\npublic static void main(String[] args){\n    //创建List集合对象\n    List<String> list = new ArrayList<String>();\n    //往尾部添加指定元素\n    list.add(\"图图\");\n    list.add(\"小美\");\n    list.add(\"不高兴\");\n    System.out.println(list);\n    //add(int index,String s)往指定位置添加\n    list.add(1,\"没头脑\");\n    System.out.println(list);\n    //String remove(int index) 删除指定位置元素返回被删除元素\n    //删除索引位置为2的元素\n    System.out.println(\"删除索引位置为2的元素\");\n    System.out.println(list.remove(2));\n    System.out.println(list);\n    //String set(int index,String s)在指定位置进行元素替代（改）\n    //修改指定位置元素\n    list.set(0, \"三毛\");\n    System.out.println(list);\n    //String get(int index)获取指定位置元素\n    //跟size()方法一起用来遍历的\n    for(int i = 0;i<list.size();i++){\n        System.out.println(list.get(i));\n    }\n    //还可以使用增强for\n    for (String string : list) {\n        System.out.println(string);\n    }\n}\n```\n\n### List的子类\n\n**ArrayList集合**\n\n`java.util.ArrayList`集合数据存储的结构是数组结构。元素**增删慢**，**查找快**，由于日常开发中使用最多的功能为查询数据、遍历数据，所以`ArrayList`是最常用的集合。 \n\n**LinkedList集合**\n\n`java.util.LinkedList`集合数据存储的结构是链表结构。方便元素添加、删除的集合。 \n\n常用方法\n\n- `public void addFirst(E e)`:将指定元素插入此列表的开头。\n\n- `public void addLast(E e)`:将指定元素添加到此列表的结尾。\n\n- `public E getFirst()`:返回此列表的第一个元素。\n\n- `public E getLast()`:返回此列表的最后一个元素。\n\n- `public E removeFirst()`:移除并返回此列表的第一个元素。\n\n- `public E removeLast()`:移除并返回此列表的最后一个元素。\n\n- `public E pop()`:从此列表所表示的堆栈处弹出一个元素。\n\n- `public void push(E e)`:将元素推入此列表所表示的堆栈。\n\n- `public boolean isEmpty()`：如果列表不包含元素，则返回true。\n\n```java\npublic static void main(String[] args) {\n    LinkedList<String> link = new LinkedList<String>();\n    //添加元素\n    link.addFirst(\"abc1\");\n    link.addFirst(\"abc2\");\n    link.addFirst(\"abc3\");\n    System.out.println(link);\n    //获取元素\n    System.out.println(link.getFirst());\n    System.out.println(link.getLast());\n    //删除元素\n    System.out.println(link.removeFirst());\n    System.out.println(link.removeLast());\n    while (!link.isEmpty()) {\n        //判断集合是否为空\n        System.out.println(link.pop());\n        //弹出集合中的栈顶元素\n    }\n    System.out.println(link);\n}\n```\n\n## Set接口\n\n`java.util.Set`接口和`java.util.List`接口一样，同样继承自`Collection`接口，它与`Collection`接口中的方法基本一致，并没有对`Collection`接口进行功能上的扩充，只是比`Collection`接口更加严格了。与`List`接口不同的是，`Set`接口中元素无序，并且都会以某种规则保证存入的元素**不出现重复**。\n\n`Set`集合有多个子类，这里我们介绍其中的`java.util.HashSet`、`java.util.LinkedHashSet`这两个集合。 \n\n### HashSet集合\n\n- 底层数据结构是哈希表  \n\n- 存取无序\n\n- 不可以存储重复元素\n\n- 没有索引,不能使用普通for循环遍历\n\n```java\npublic static void main(String[] args) throws Exception {\n    Student stu1=new Student(\"令狐冲\",19);\n    Student stu2=new Student(\"令狐冲\",19);\n    Student stu3=new Student(\"风清扬\",79);\n    Student stu4=new Student(\"岳不群\",49);\n    HashSet<Student> set=new HashSet<Student>();\n    set.add(stu1);\n    set.add(stu2);\n    set.add(stu3);\n    set.add(stu4);\n    System.out.println(set.contains(stu2));\n    for(Student stu:set){\n        System.out.println(stu);\n    }\n}\n```\n\n> 覆盖Student中的equals和hashCode方法\n\n```java\n@Override\npublic boolean equals(Object obj){\n    if(obj instanceof  Student){\n        Student stu= (Student) obj;\n        if(stu.age==this.age&&stu.name.equals(this.name)){\n            return true;\n        }\n    }\n    return false;\n}\n@Override\npublic int hashCode(){\n    return name.hashCode()+age;\n}\n```\n\n>for循环遍历后删除\n\n```java\npublic static void main(String[] args) {\n        Student stu1=new Student(\"吴作成\",18);\n        Student stu2=new Student(\"杨志超\",19);\n        Student stu3=new Student(\"商政\",21);\n        Student stu4=new Student(\"商政\",21);\n        Student stu5=new Student(\"靳东升\",20);\n        HashSet<Student> set=new HashSet<Student>();\n        set.add(stu1);\n        set.add(stu2);\n        set.add(stu3);\n        set.add(stu4);\n        set.add(stu5);\n        System.out.println(set);\n        HashSet<Student> setDel=new HashSet<Student>();\n        for(Student stu:set){\n            if(stu.name.startsWith(\"商\")){\n                setDel.add(stu);\n            }\n        }\n        set.removeAll(setDel);\n        System.out.println(set);\n    }\n```\n\n### LinkedHashSet\n\n我们知道HashSet保证元素唯一，可是元素存放进去是没有顺序的，那么我们要保证有序，怎么办呢？\n\n在HashSet下面有一个子类`java.util.LinkedHashSet`，它是链表和哈希表组合的一个数据存储结构。 \n\n```java\npublic static void main(String[] args) {\n    Set<String> set = new LinkedHashSet<String>();\n    set.add(\"bbb\");\n    set.add(\"aaa\");\n    set.add(\"abc\");\n    set.add(\"bbc\");\n    Iterator<String> it = set.iterator();\n    while (it.hasNext()){\n        System.out.println(it.next());\n    }\n}\n```\n\n### TreeSet集合\n\n **TreeSet集合概述和特点【应用】**\n\n- 不可以存储重复元素\n\n- 没有索引\n\n- 红黑树  TreeSet\n\n- 可以将元素按照规则进行排序\n\n- TreeSet()：根据其元素的自然排序进行排序\n\n- TreeSet(Comparator comparator) ：根据指定的比较器进行排序\n\n> TreeSet集合基本使用\n\n```java\n//1.准备一个TreeSet集合并打印\nSet<String> s1 = new TreeSet<>();\nSystem.out.println(\"s1 = \" + s1);\n//[啥也没有]//2.向集合中添加String类型的对象并打印\nboolean b1 = s1.add(\"aa\");\nSystem.out.println(\"b1 = \" + b1);//true\nSystem.out.println(\"s1 = \" + s1);//[aa]\nb1 = s1.add(\"cc\");\nSystem.out.println(\"b1 = \" + b1);//true\nSystem.out.println(\"s1 = \" + s1);//[aa, cc]\nb1 = s1.add(\"bb\");\nSystem.out.println(\"b1 = \" + b1);//true\n//由于TreeSet集合的底层是采用红黑树实现的，因此元素有大小次序，默认从小到大打印\nSystem.out.println(\"s1 = \" + s1);//[aa, bb, cc]\n```\n\n> 排序Comparator和Comparable接口\n\n实现Comparable 接口 并重写方法\n\n```java\npublic class Student implements Comparable<Student>{\n    @Override\n    public int compareTo(Student stu) {\n        if(this.age>stu.age) return -1;\n        if(this.age<stu.age) return 1;\n        return 0;\n    }\n}\n```\n\n```java\npublic static void main(String[] args) throws Exception {\n    Student stu1=new Student(\"令狐冲\",19);\n    Student stu2=new Student(\"令狐冲\",19);\n    Student stu3=new Student(\"风清扬\",79);\n    Student stu4=new Student(\"岳不群\",49);\n    TreeSet<Student> set= new TreeSet<Student>();\n    set.add(stu1);\n    set.add(stu2);\n    set.add(stu3);\n    set.add(stu4);\n    System.out.println(set.contains(stu2));\n    for(Student stu:set){\n        System.out.println(stu);\n    }\n}\n```\n\n> 实现Comparator接口的比较器\n\n```java\npublic class StuComptor implements Comparator<Student> {\n    @Override\n    public int compare(Student stu1, Student stu2) {\n        if(stu1.age>stu2.age)return 1;\n        if(stu1.age<stu2.age)return -1;\n        return 0;\n    }\n}\n```\n\n```java\npublic static void main(String[] args) throws Exception {    \n    Student stu1=new Student(\"令狐冲\",19);\n    Student stu2=new Student(\"令狐冲\",19);\n    Student stu3=new Student(\"风清扬\",79);\n    Student stu4=new Student(\"岳不群\",49);\n    TreeSet<Student> set= new TreeSet<Student>(new StuComptor());\n    set.add(stu1);\n    set.add(stu2);\n    set.add(stu3);\n    set.add(stu4);\n    System.out.println(set.contains(stu2));\n    for(Student stu:set){\n        System.out.println(stu);\n    }\n}\n```\n\n- 两种比较方式小结\n  \n  - 自然排序: 自定义类实现Comparable接口,重写compareTo方法,根据返回值进行排序\n  - 比较器排序: 创建TreeSet对象的时候传递Comparator的实现类对象,重写compare方法,根据返回值进行排序\n  \n  - 在使用的时候,默认使用自然排序,当自然排序不满足现在的需求时,必须使用比较器排序\n- 两种方式中关于返回值的规则\n\n  - 如果返回值为负数，表示当前存入的元素是较小值，存左边\n  - 如果返回值为0，表示当前存入的元素跟集合中元素重复了，不存\n  - 如果返回值为正数，表示当前存入的元素是较大值，存右边\n\n\n## Collections\n\n- `java.utils.Collections`是集合工具类，用来对集合进行操作。部分方法如下：\n\n- `public static <T> boolean addAll(Collection<T> c, T... elements)`:往集合中添加一些元素。\n\n- `public static void shuffle(List<?> list)`:打乱集合顺序。\n\n- `public static <T> void sort(List<T> list)`:将集合中元素按照默认规则排序。\n\n- `public static <T> void sort(List<T> list，Comparator<? super T> )`:将集合中元素按照指定规则排序。\n\n```java\npublic static void main(String[] args) {\n    ArrayList<Integer> list = new ArrayList<Integer>();\n    //原来写法\n    //list.add(12);\n    //list.add(14);\n    //list.add(15);\n    //list.add(1000);\n    //采用工具类 完成 往集合中添加元素\n    Collections.addAll(list, 5, 222, 1，2);\n    System.out.println(list);\n    //排序方法\n    Collections.sort(list);\n    System.out.println(list);\n}\n```\n\n## 泛型\n\n**泛型的介绍**\n\n- 常情况下集合中可以存放不同类型的对象，是因为将所有对象都看做Object类型放入的，因此 从集合中取出元素时也是Object类型，为了表达该元素真实的数据类型，则需要强制类型转换， 而强制类型转换可能会引发类型转换异常。\n\n- 为了避免上述错误的发生，从Java5开始增加泛型机制，也就是在集合名称的右侧使用<数据类型> 的方式来明确要求该集合中可以存放的元素类型，若放入其它类型的元素则编译报错。\n\n- 泛型只在编译时期有效，在运行时期不区分是什么类型。\n\n定义格式：修饰符 class 类名<类型> {}\n\n```java\nclass ArrayList<E>{\n    public boolean add(E e){}\n    public E get(int index){}\n    ....\n}\n```\n\n> 使用在类上的语法\n\n```java\npublic class JavaBean<T> {\n    private T t;\n    public T getT() {\n        return t;\n    }\n    public void setT(T t) {\n        this.t = t;\n    }\n}\n```\n\n**泛型方法**\n\n定义格式：修饰符 <类型> 返回值类型 方法名(类型 变量名) {}\n\npublic  <T> void/Integer test(T t)\n\n> 带有泛型方法的类\n\n```java\npublic class JavaObject {\n    public <T> void set(T t){\n        System.out.println(t);\n    }\n}\n```\n\n```java\npublic static void main(String[] args) {\n    JavaObject j = new JavaObject();\n    j.set(\"hd\");\n    j.set(88);\n}\n```\n\n**泛型接口**\n\n定义格式： 修饰符 interface 接口名<类型> {}\n\n```java\npublic interface JavaInterface<T> {\nvoid set(T t);\n}\n```\n\n```java\npublic class JavaObjectImpl1 implements JavaInterface<Integer>{\n    @Override\n    public void set(Integer t) {\n        System.out.println(t);\n    }\n}\n```\n\n```java\npublic static void main(String[] args) {\n    JavaObjectImpl<String> obj1= new JavaObjectImpl<String>();\n    obj1.set(\"hd\");\n    JavaObjectImpl<Integer> obj2= new JavaObjectImpl<Integer>();\n    obj2.set(88);\n}\n```\n\n**类型通配符**\n\n当使用泛型类或者接口时，传递的数据中，泛型类型不确定，可以通过通配符<?>表示。但是一旦使用泛型的通配符后，只能使用Object类中的共性方法，集合中元素自身方法无法使用。\n\n**通配符高级使用----受限泛型**\n\n之前设置泛型的时候，实际上是可以任意设置的，只要是类就可以设置。但是在JAVA的泛型中可以指定一个泛型的**上限**和**下限**。\n\n**泛型的上限**：\n\n- **格式**： `类型名称 <? extends 类 > 对象名称`\n\n- **意义**： `只能接收该类型及其子类`\n\n**泛型的下限**：\n\n- **格式**： `类型名称 <? super 类 > 对象名称`\n\n- **意义**： `只能接收该类型及其父类型`\n\n```java\npublic static void main(String[] args) {\n    Collection<Integer> list1 = new ArrayList<Integer>();\n    Collection<String> list2 = new ArrayList<String>();\n    Collection<Number> list3 = new ArrayList<Number>();\n    Collection<Object> list4 = new ArrayList<Object>();\n    getElement(list1);\n    getElement(list2);//报错\n    getElement(list3);\n    getElement(list4);//报错\n    getElement2(list1);//报错\n    getElement2(list2);//报错\n    getElement2(list3);\n    getElement2(list4);\n}\n// 泛型的上限：此时的泛型?，必须是Number类型或者Number类型的子类\npublic static void getElement1(Collection<? extends Number> coll){}\n// 泛型的下限：此时的泛型?，必须是Number类型或者Number类型的父类\npublic static void getElement2(Collection<? super Number> coll){}\n```\n\n## Map集合\n\n**Map集合概述**\n\n interface Map<K,V>  K：键的类型；V：值的类型\n\n- Map集合的特点\n\n- 双列集合,一个键对应一个值\n\n- 键不可以重复,值可以重复\n\n**Map集合的基本功能**\n\n| 方法名                              | 说明                                 |\n| ----------------------------------- | ------------------------------------ |\n| V   put(K key,V   value)            | 添加元素                             |\n| V   remove(Object key)              | 根据键删除键值对元素                 |\n| void   clear()                      | 移除所有的键值对元素                 |\n| boolean containsKey(Object key)     | 判断集合是否包含指定的键             |\n| boolean containsValue(Object value) | 判断集合是否包含指定的值             |\n| boolean isEmpty()                   | 判断集合是否为空                     |\n| int size()                          | 集合的长度，也就是集合中键值对的个数 |\n\n遍历方法\n\n| 方法名                           | 说明                     |\n| -------------------------------- | ------------------------ |\n| V   get(Object key)              | 根据键获取值             |\n| Set<K>   keySet()                | 获取所有键的集合         |\n| Collection<V>   values()         | 获取所有值的集合         |\n| Set<Map.Entry<K,V>>   entrySet() | 获取所有键值对对象的集合 |\n\n```java\npublic static void main(String[] args) {\n    //1.准备一个Map集合并打印\n    Map<String, String> m1 = new HashMap<>();\n    //自动调用toString方法，默认打印格式为：{key1=value1, key2=value2, ...}\n    System.out.println(\"m1 = \" + m1);//{啥也没有}\n    //2.向集合中添加元素并打印\n    String str1 = m1.put(\"1\", \"one\");\n    System.out.println(\"原来的value数值为：\" + str1);//null\n    System.out.println(\"m1 = \" + m1);//{1=one}\n    str1 = m1.put(\"2\", \"two\");\n    System.out.println(\"原来的value数值为：\" + str1);//null\n    System.out.println(\"m1 = \" + m1);//{1=one, 2=two}\n    str1 = m1.put(\"3\", \"three\");\n    System.out.println(\"原来的value数值为：\" + str1);//null\n    System.out.println(\"m1 = \" + m1);//{1=one, 2=two, 3=three}\n    //实现了修改的功能\n    str1 = m1.put(\"1\", \"eleven\");\n    System.out.println(\"原来的value数值为：\" + str1);//one\n    System.out.println(\"m1 = \" + m1);//{1=eleven, 2=two, 3=three}\n    System.out.println(\"----------------\");\n    //3.实现集合中元素的查找操作\n    boolean b1 = m1.containsKey(\"11\");\n    System.out.println(\"b1 = \" + b1);//false\n    b1 = m1.containsKey(\"1\");\n    System.out.println(\"b1 = \" + b1);//true\n    b1 = m1.containsValue(\"one\");\n    System.out.println(\"b1 = \" + b1);//false\n    b1 = m1.containsValue(\"eleven\");\n    System.out.println(\"b1 = \" + b1);//true\n    String str2 = m1.get(\"5\");\n    System.out.println(\"str2 = \" + str2);//null\n    str2 = m1.get(\"3\");\n    System.out.println(\"str2 = \" + str2);//three\n    System.out.println(\"-------------------------------------\");\n    //4.实现集合中元素的删除操作\n    str2 = m1.remove(\"1\");\n    System.out.println(\"被删除的value是：\" + str2);//eleven\n    System.out.println(\"m1 = \" + m1);//{2=two, 3=three}\n    System.out.println(\"---------------------------------------\");\n    //5.获取Map集合中所有的key并组成Set视图\n    Set<String> s1 = m1.keySet();\n    //遍历所有的key\n    for (String ts : s1) {\n        System.out.println(ts + \"=\" + m1.get(ts));\n    }\n    System.out.println(\"-----------------------------------\");\n    //6.获取Map集合中所有的Value并组成Collection视图\n    Collection<String> co = m1.values();\n    for (String ts : co) {\n        System.out.println(\"ts = \" + ts);\n    }\n    System.out.println(\"------------------------------------------\");\n    //7.获取Map集合中所有的键值对并组成Set视图\n    Set<Map.Entry<String, String>> entries = m1.entrySet();\n    for (Map.Entry<String, String> me : entries) {\n        System.out.println(me);\n    }\n}\n```\n\n## HashMap集合\n\n**HashMap集合概述和特点**\n\n- HashMap底层是哈希表结构的\n\n- 依赖hashCode方法和equals方法保证键的唯一\n\n- 如果键要存储的是自定义对象，需要重写hashCode和equals方法\n\n```java\npublic static void main(String[] args) {\n    //1.遍历字符串\n    String str = \"abcaba\";\n    //声明一个集合 把所有的字母 都加进去\n    //字母就是key 次数 int value\n    HashMap<Character, Integer> map = new HashMap<>();\n    for (char zimu:str.toCharArray()) {\n        // 如果 字母 存在，次数+1\n        if(map.containsKey(zimu)){\n            // 存在，就把value的值+1\n            Integer cishu = map.get(zimu);\n            // map.getOrDefault()\n            cishu++;\n            map.put(zimu,cishu);\n        }else{\n            //如果不存在，就说明是第1次来，存1次\n            map.put(zimu,1);\n        }\n    }\n}\n```\n\n## TreeMap集合\n\n- TreeMap底层是红黑树结构\n\n- 依赖自然排序或者比较器排序,对键进行排序\n\n- 如果键存储的是自定义对象,需要实现Comparable接口或者在创建TreeMap对象时候给出比较器排序规则\n\n```java\npublic class Student implements Comparable<Student>{\n    private String name;\n    private int age;\n    public Student() {}\n    public Student(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n    public String getName() {\n        return name;\n    }\n    public void setName(String name) {\n        this.name = name;\n    }\n    public int getAge() {\n        return age;\n    }\n    public void setAge(int age) {\n        this.age = age;\n    }\n    @Override\n    public String toString() {\n        return \"Student{\"+\"name='\" + name + '\\'' +\", age=\" + age +'}';\n    }\n    @Override\n    public int compareTo(Student o) {\n        /*按照年龄进行排序*/\n        int result = o.getAge() - this.getAge();\n        /*次要条件，按照姓名排序*/\n        result = result == 0 ? o.getName().compareTo(this.getName()) : result;\n        return result;\n    }s\n}\n```\n\n```java\npublic class Test1 {\n    public static void main(String[] args) {\n        TreeMap<Student,String> tm = new TreeMap<>();\n        Student s1 = new Student(\"hd\",88);\n        Student s2 = new Student(\"jc\",99);\n        /*将学生对象添加到TreeMap集合中*/\n        tm.put(s1,\"郑州\");\n        tm.put(s2,\"北京\");\n        /*遍历TreeMap集合,打印每个学生的信息*/\n        Set<Map.Entry<Student, String>> entries = tm.entrySet();\n        for (Map.Entry<Student, String> entry:entries) {\n            Student key = entry.getKey();\n            String value = entry.getValue();\n            System.out.println(\"key:\" + key + \"value:\" + value);\n        }\n    }\n}\n```\n\n","tags":["集合","泛型"],"categories":["学习之路"]},{"title":"IO流","url":"/2022/09/15/IO流/","content":"\n## IO流\n\n### IO流简介\n\n当你编辑一个文本文件，忘记了`ctrl+s` ，可能文件就白白编辑了。当你电脑上插入一个U盘，可以把一个视频，拷贝到你的电脑硬盘里。那么数据都是在哪些设备上的呢？键盘、内存、硬盘、外接设备等等。\n\n我们把这种数据的传输，可以看做是一种数据的流动，按照流动的方向，以内存为基准，分为`输入input` 和`输出output` ，即流向内存是输入流，流出内存的输出流。\n\nJava中I/O操作主要是指使用`java.io`包下的内容，进行输入、输出操作。**输入**也叫做**读取**数据，**输出**也叫做作**写出**数据。\n\n流的定义：流是指一连串流动的字符,是以先进先出方式发送信息的通道。\n\n按流向分：\n\n- 输出流：OutputStream和Writer为基类\n- 输入流：InputStream和Reader为基类\n\n按处理数据单元划分：\n\n- 字节流：字节输入流：InputStream基类\n- 字节输出流：OutputStream基类\n- 字符流：字符输入流：Reader基类\n- 字节输出流：Writer基类\n\n（字节流是 8 位通用字节流，字符流是16位Unicode字符流）\n\n### File字节流\n\n#### File类概述\n\n- java.io.File类主要用于描述文件或目录路径的抽象表示信息，可以获取文件或目录的特征信息， 如：大小等\n\n- `public File (String pathname)` ：通过将给定的**路径名字符串**转换为抽象路径名来创建新的 File实例。  \n\n- `public File (String parent, String child)` ：从**父路径名字符串和子路径名字符串**创建新的 File实例。\n\n- `public File (File parent, String child)` ：从**父抽象路径名和子路径名字符串**创建新的 File实例。  \n\n```java\n// 文件路径名\nString pathname = \"D:\\\\aaa.txt\";\nFile file1 = new File(pathname);\n// 文件路径名\nString pathname2 = \"D:\\\\aaa\\\\bbb.txt\";\nFile file2 = new File(pathname2);\n// 通过父路径和子路径字符串\nString parent = \"d:\\\\aaa\";\nString child = \"bbb.txt\";\nFile file3 = new File(parent,child);\n// 通过父级File对象和子路径字符串\nFile parentDir = new File(\"d:\\\\aaa\");\nString child = \"bbb.txt\";\nFile file4 = new File(parentDir,child);\n```\n\n**tips:**\n\n1. 一个File对象代表硬盘中实际存在的一个文件或者目录。\n1. 无论该路径下是否存在文件或者目录，都不影响File对象的创建。\n\n#### 常用方法\n\n- `public String getAbsolutePath()` ：返回此File的绝对路径名字符串。\n\n- `public String getPath()` ：将此File转换为路径名字符串。 \n\n- `public String getName()`  ：返回由此File表示的文件或目录的名称。  \n\n- `public long length()`  ：返回由此File表示的文件的长度。 \n\n```java\npublic static void main(String[] args) {\n    File f = new File(\"d:/aaa/bbb.java\");\n    System.out.println(\"文件绝对路径:\"+f.getAbsolutePath());\n    System.out.println(\"文件构造路径:\"+f.getPath());\n    System.out.println(\"文件名称:\"+f.getName());\n    System.out.println(\"文件长度:\"+f.length()+\"字节\");\n    File f2 = new File(\"d:/aaa\");\n    System.out.println(\"目录绝对路径:\"+f2.getAbsolutePath());\n    System.out.println(\"目录构造路径:\"+f2.getPath());\n    System.out.println(\"目录名称:\"+f2.getName());\n    System.out.println(\"目录长度:\"+f2.length());\n}\n```\n\n#### 绝对路径和相对路径\n\n- **绝对路径**：从盘符开始的路径，这是一个完整的路径。\n\n- **相对路径**：相对于项目目录的路径，这是一个便捷的路径，开发中经常使用。\n\n#### 判断功能的方法\n\n- `public boolean exists()` ：此File表示的文件或目录是否实际存在。\n\n- `public boolean isDirectory()` ：此File表示的是否为目录。\n\n- `public boolean isFile()` ：此File表示的是否为文件。\n\n```java\npublic static void main(String[] args) {\n    File f = new File(\"d:\\\\aaa\\\\bbb.java\");\n    File f2 = new File(\"d:\\\\aaa\");\n    // 判断是否存在\n    System.out.println(\"d:\\\\aaa\\\\bbb.java 是否存在:\"+f.exists());\n    System.out.println(\"d:\\\\aaa 是否存在:\"+f2.exists());\n    // 判断是文件还是目录\n    System.out.println(\"d:\\\\aaa 文件?:\"+f2.isFile());\n    System.out.println(\"d:\\\\aaa 目录?:\"+f2.isDirectory());\n}\n```\n\n#### 创建删除功能的方法\n\n- `public boolean createNewFile()` ：当且仅当具有该名称的文件尚不存在时，创建一个新的空文件。 \n- `public boolean delete()` ：删除由此File表示的文件或目录。  \n- `public boolean mkdir()` ：创建由此File表示的目录。\n- `public boolean mkdirs()` ：创建由此File表示的目录，包括任何必需但不存在的父目录。\n\n```java\n//文件的创建\nFile f = new File(\"aaa.txt\");\nSystem.out.println(\"是否存在:\"+f.exists());//false\nSystem.out.println(\"是否创建:\"+f.createNewFile());//true\nSystem.out.println(\"是否存在:\"+f.exists());//true\n//目录的创建\nFile f2= new File(\"newDir\");\nSystem.out.println(\"是否存在:\"+f2.exists());//false\nSystem.out.println(\"是否创建:\"+f2.mkdir());//true\nSystem.out.println(\"是否存在:\"+f2.exists());//true\n//创建多级目录\nFile f3= new File(\"newDira\\\\newDirb\");\nSystem.out.println(f3.mkdir());//false\nFile f4= new File(\"newDira\\\\newDirb\");\nSystem.out.println(f4.mkdirs());//true\n//文件的删除\nSystem.out.println(f.delete());//true\n//目录的删除\nSystem.out.println(f2.delete());//true\nSystem.out.println(f4.delete());//false\n```\n\n> API中说明：delete方法，如果此File表示目录，则目录必须为空才能删除。\n\n#### 目录的遍历\n\n- `public String[] list()` ：返回一个String数组，表示该File目录中的所有子文件或目录。\n\n- `public File[] listFiles()` ：返回一个File数组，表示该File目录中的所有的子文件或目录。\n\n```java\npublic static void main(String[] args) {\n    File dir = new File(\"d:\\\\java_code\");\n    //获取当前目录下的文件以及文件夹的名称。\n    String[] names = dir.list();\n    for(String name : names){\n        System.out.println(name);\n    }\n    //获取当前目录下的文件以及文件夹对象，只要拿到了文件对象，那么就可以获取更多信息  \n    File[] files = dir.listFiles();\n    for (File file : files) {\n        System.out.println(file);\n    }\n}\n```\n\n### 字节输出流(OutputStream)\n\njava.io.OutputStream抽象类是表示字节输出流的所有类的超类，将指定的字节信息写出到目的地。它定义了字节输出流的基本共性功能方法。\n\n- public void close() ：关闭此输出流并释放与此流相关联的任何系统资源。 \n\n- public void flush() ：刷新此输出流并强制任何缓冲的输出字节被写出。 \n\n- public void write(byte[] b)：将 b.length字节从指定的字节数组写入此输出流。 \n\n- public void write(byte[] b, int off, int len) ：从指定的字节数组写入 len字节，从偏移量 off开始输出到此输出流。 \n\n-  public abstract void write(int b) ：将指定的字节输出流。\n\ntips：close方法，当完成流的操作时，必须调用此方法，释放系统资源。\n\n> FileOutputStream类\n\n```java\npublic static void main(String[] args) {\n    //使用File对象创建流对象\n    File file = new File(\"a.txt\");\n    FileOutputStream fos = new FileOutputStream(file);\n    //使用文件名称创建流对象\n    FileOutputStream fos = new FileOutputStream(\"b.txt\");\n}\n```\n\n> `write(int b)` 方法，每次可以写出一个字节数据\n\n```java\npublic static void main(String[] args) throws IOException {\n    //使用文件名称创建流对象\n    FileOutputStream fos = new FileOutputStream(\"fos.txt\");\n    //写出数据\n    fos.write(97);//写出第1个字节\n    fos.write(98);//写出第2个字节\n    fos.write(99);//写出第3个字节\n    //关闭资源\n    fos.close();\n}\n```\n\n> 写出字节数组：`write(byte[] b)`，每次可以写出数组中的数据\n\n```java\npublic static void main(String[] args) throws IOException {\n    //使用文件名称创建流对象\n    FileOutputStream fos = new FileOutputStream(\"fos.txt\");\n    //字符串转换为字节数组\n    byte[] b = \"我爱学习\".getBytes();\n    //写出字节数组数据\n    fos.write(b);\n    //关闭资源\n    fos.close();\n}\n```\n\n> 写出指定长度字节数组：`write(byte[] b, int off, int len)` ,每次写出从off索引开始，len个字节\n\n```java\npublic static void main(String[] args) throws IOException {\n    //使用文件名称创建流对象\n    FileOutputStream fos = new FileOutputStream(\"fos.txt\");\n    //字符串转换为字节数组\n    byte[] b = \"abcde\".getBytes();\n    //写出从索引2开始，2个字节。索引2是c，两个字节，也就是cd.\n    fos.write(b,2,2);\n    //关闭资源 \n    fos.close();\n}\n```\n\n> 数据追加续写\n\n```java\npublic static void main(String[] args) throws IOException {\n    //使用文件名称创建流对象\n    FileOutputStream fos = new FileOutputStream(\"fos.txt\",true);\n    //字符串转换为字节数组\n    byte[] b = \"abcde\".getBytes();\n    //写出从索引2开始，2个字节。索引2是c，两个字节，也就是cd。\n    fos.write(b);\n    //关闭资源\n    fos.close();\n}\n```\n\n> Windows系统里，换行符号是`\\r\\n` 。\n\n```java\npublic static void main(String[] args) throws IOException {\n    FileOutputStream fos = new FileOutputStream(\"fos.txt\");\n    byte[] words = {97,98,99,100,101};\n    //遍历数组\n    for (int i = 0; i < words.length; i++) {\n        //写出一个字节\n        fos.write(words[i]);\n        //写出一个换行, 换行符号转成数组写出\n        fos.write(\"\\r\\n\".getBytes());\n    }\n    fos.close();\n}\n```\n\n### 字节输入流(InputStream)\n\n`java.io.InputStream`抽象类是表示字节输入流的所有类的超类，可以读取字节信息到内存中。它定义了字节输入流的基本共性功能方法。\n\n- `public void close()` ：关闭此输入流并释放与此流相关联的任何系统资源。    \n\n- `public abstract int read()`： 从输入流读取数据的下一个字节。 \n\n- `public int read(byte[] b)`： 从输入流中读取一些字节数，并将它们存储到字节数组 b中 。\n\n> FileInputStream类\n\n```java\npublic static void main(String[] args) {\n    //使用File对象创建流对象\n    File file = new File(\"a.txt\");\n    FileInputStream fos = new FileInputStream(file);\n    //使用文件名称创建流对象\n    FileInputStream fos = new FileInputStream(\"b.txt\");\n}\n```\n\n> 读取字节数据\n\n> read方法，每次可以读取一个字节的数据，提升为int类型，读取到文件末尾，返回 -1\n\n```java\npublic static void main(String[] args) throws IOException{\n    //使用文件名称创建流对象\n    FileInputStream fis = new FileInputStream(\"read.txt\");\n    //读取数据，返回一个字节\n    int read = fis.read();\n    System.out.println((char) read);\n    read = fis.read();\n    System.out.println((char) read);\n    read = fis.read();\n    System.out.println((char) read);\n    read = fis.read();\n    System.out.println((char) read);\n    read = fis.read();\n    System.out.println((char) read);\n    //读取到末尾,返回-1\n    read = fis.read();\n    System.out.println(read);\n   \tfis.close();\n}\n```\n\n> 循环读取方式\n\n```java\npublic static void main(String[] args) throws IOException{\n    //使用文件名称创建流对象\n    FileInputStream fis = new FileInputStream(\"read.txt\");\n    //定义变量，保存数据\n    int b;\n    //循环读取\n    while ((b = fis.read())!=-1) {\n        System.out.println((char)b);\n    }\n    fis.close();\n}\n```\n\n> 字节数组读取：read(byte[] b)\n\n```java\npublic static void main(String[] args) throws IOException{\n    //使用文件名称创建流对象\n    FileInputStream fis = new FileInputStream(\"read.txt\");\n    // 定义变量，作为有效个数\n    int b;\n    //定义字节数组，作为装字节数据的容器\n    byte[] by = new byte[2];\n    //循环读取\n    while ((b = fis.read(by))!=-1) {\n        System.out.println(new String(by,0,b));\n        //b每次读取的有效字节个数\n    }\n    fis.close();\n}\n```\n\n### 字节缓冲流\n\n缓冲流的基本原理，是在创建流对象时，会创建一个内置的默认大小的缓冲区数组，通过缓冲区读写，减少系统IO次数，从而提高读写的效率。\n\n**构造方法**\n\n- `public BufferedInputStream(InputStream in)` ：创建一个 新的缓冲输入流。 \n\n- `public BufferedOutputStream(OutputStream out)`： 创建一个新的缓冲输出流。\n\n```java\n//创建字节缓冲输入流\nBufferedInputStream bis = new BufferedInputStream(new FileInputStream(\"bis.txt\"));\n//创建字节缓冲输出流\nBufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(\"bos.txt\"));\n```\n\n```java\npublic static void main(String[] args) {\n        //获取当前系统时间距离1970年1月1日0时0分0秒的毫秒数\n        long g1 = System.currentTimeMillis();\n        BufferedInputStream bis = null;\n        BufferedOutputStream bos = null;\n        try {\n            //1.创建BufferedInputStream类型的对象与d:/视频文件1.mp4文件关联\n            bis = new BufferedInputStream(new FileInputStream(\"d:/视频文件1.mp4\"));\n            //2.创建BufferedOuputStream类型的对象与d:/视频文件2.mp4文件关联\n            bos = new BufferedOutputStream(new FileOutputStream(\"d:/视频文件2.mp4\"));\n            //3.不断地从输入流中读取数据并写入到输出流中\n            System.out.println(\"正在玩命地拷贝...\");\n            byte[] bArr = new byte[1024];\n            int res = 0;\n            while ((res = bis.read(bArr)) != -1) {\n                bos.write(bArr, 0, res);\n            }\n            System.out.println(\"拷贝文件成功！\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            //4.关闭流对象并释放有关的资源\n            if (null != bos) {\n                try {\n                    bos.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (null != bis) {\n                    try {\n                        bis.close();\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                    long g2 = System.currentTimeMillis();\n                    System.out.println(\"使用缓冲区拷贝视频文件消耗的时间为：\" + (g2 - g1));\n                }\n            }\n        }\n}\n```\n\n## 字符流\n\n字符 --->1010101 + 编码表  \n\n计算机中储存的信息都是用二进制数表示的，而我们在屏幕上看到的数字、英文、标点符号、汉字等字符是二进制数转换之后的结果。按照某种规则，将字符存储到计算机中，称为**编码** 。反之，将存储在计算机中的二进制数按照某种规则解析显示出来，称为**解码** 。比如说，按照A规则存储，同样按照A规则解析，那么就能显示正确的文本符号。反之，按照A规则存储，再按照B规则解析，就会导致乱码现象。\n\n编码:字符(能看懂的)--字节(看不懂的)\n\n解码:字节(看不懂的)-->字符(能看懂的)\n\n**字符编码**`Character Encoding` : 就是一套自然语言的字符与二进制数之间的对应规则。\n\n- 编码表:生活中文字和计算机中二进制的对应规则\n\n### 字符集\n\n- **字符集** `Charset`：也叫编码表。是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等。\n\n- 计算机要准确的存储和识别各种字符集符号，需要进行字符编码，一套字符集必然至少有一套字符编码。常见字符集有ASCII字符集、GBK字符集、Unicode字符集等。\n\n- **ASCII字符集** ：\n\n- ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）是基于拉丁字母的一套电脑编码系统，用于显示现代英语，主要包括控制字符（回车键、退格、换行键等）和可显示字符（英文大小写字符、阿拉伯数字和西文符号）。\n\n- 基本的ASCII字符集，使用7位（bits）表示一个字符，共128字符。ASCII的扩展字符集使用8位（bits）表示一个字符，共256字符，方便支持欧洲常用字符。\n\n- **ISO-8859-1字符集**：\n\n- 拉丁码表，别名Latin-1，用于显示欧洲使用的语言，包括荷兰、丹麦、德语、意大利语、西班牙语等。\n\n- ISO-8859-1使用单字节编码，兼容ASCII编码。\n\n- **GBxxx字符集**：\n\n- GB就是国标的意思，是为了显示中文而设计的一套字符集。\n\n- **GB2312**：简体中文码表。一个小于127的字符的意义与原来相同。但两个大于127的字符连在一起时，就表示一个汉字，这样大约可以组合了包含7000多个简体汉字，此外数学符号、罗马希腊的字母、日文的假名们都编进去了，连在ASCII里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的\"全角\"字符，而原来在127号以下的那些就叫\"半角\"字符了。\n\n- **GBK**：最常用的中文码表。是在GB2312标准基础上的扩展规范，使用了双字节编码方案，共收录了21003个汉字，完全兼容GB2312标准，同时支持繁体汉字以及日韩汉字等。\n\n- **GB18030**：最新的中文码表。收录汉字70244个，采用多字节编码，每个字可以由1个、2个或4个字节组成。支持中国国内少数民族的文字，同时支持繁体汉字以及日韩汉字等。\n\n- **Unicode字符集** ：\n\n- Unicode编码系统为表达任意语言的任意字符而设计，是业界的一种标准，也称为统一码、标准万国码。\n\n- 它最多使用4个字节的数字来表达每个字母、符号，或者文字。有三种编码方案，UTF-8、UTF-16和UTF-32。最为常用的UTF-8编码。\n\n- UTF-8编码，可以用来表示Unicode标准中任何字符，它是电子邮件、网页及其他存储或传送文字的应用中，优先采用的编码。互联网工程工作小组（IETF）要求所有互联网协议都必须支持UTF-8编码。所以，我们开发Web应用，也要使用UTF-8编码。它使用一至四个字节为每个字符编码，编码规则：\n\n- 128个US-ASCII字符，只需一个字节编码。\n\n- 拉丁文等字符，需要二个字节编码。 \n\n- 大部分常用字（含中文），使用三个字节编码。\n\n- 其他极少使用的Unicode辅助字符，使用四字节编码。\n\n### 字符输入流(Reader)\n\n`java.io.Reader`抽象类是表示用于读取字符流的所有类的超类，可以读取字符信息到内存中。它定义了字符输入流的基本共性功能方法。\n\n- `public void close()` ：关闭此流并释放与此流相关联的任何系统资源。    \n\n- `public int read()`： 从输入流读取一个字符。 \n\n- `public int read(char[] cbuf)`： 从输入流中读取一些字符，并将它们存储到字符数组 cbuf中 。\n\n> FileReader类  \n\n```java\n//当你创建一个流对象时，必须传入一个文件路径。类似于FileInputStream\npublic static void main(String[] args) {\n    //使用File对象创建流对象\n    File file = new File(\"a.txt\");\n    FileReader fr = new FileReader(file);\n    //使用文件名称创建流对象\n    FileReader fr = new FileReader(\"b.txt\");\n}\n```\n\n> 读取字符数据\n\n```java\npublic static void main(String[] args) throws IOException {\n    //使用文件名称创建流对象\n    FileReader fr = new FileReader(\"read.txt\");\n    //定义变量，保存数据\n    int b;\n    //循环读取\n    while ((b = fr.read())!=-1) {\n        System.out.println((char)b);\n    }\n    fr.close();\n}\n```\n\n> 使用字符数组读取：read(char[] cbuf)\n\n```java\npublic static void main(String[] args) throws IOException {\n    //使用文件名称创建流对象\n    FileReader fr = new FileReader(\"read.txt\");\n    //定义变量，保存有效字符个数\n    int len;\n    //定义字符数组，作为装字符数据的容器\n    char[] cbuf = new char[2];\n    //循环读取\n    while ((len = fr.read(cbuf))!=-1) {\n        System.out.println(new String(cbuf,0,len));\n    }\n    fr.close();\n}\n```\n\n### 字符输出流(Writer)\n\n`java.io.Writer`抽象类是表示用于写出字符流的所有类的超类，将指定的字符信息写出到目的地。它定义了字节输出流的基本共性功能方法。\n\n- `void write(int c)` 写入单个字符。\n\n- `void write(char[] cbuf)`写入字符数组。 \n\n- `abstract  void write(char[] cbuf, int off, int len)`写入字符数组的某一部分,off数组的开始索引,len写的字符个数。 \n\n- `void write(String str)`写入字符串。 \n\n- `void write(String str, int off, int len)` 写入字符串的某一部分,off字符串的开始索引,len写的字符个数。\n\n- `void flush()`刷新该流的缓冲。  \n\n- `void close()` 关闭此流，但要先刷新它。\n\n> FileWriter类\n\n```java\npublic static void main(String[] args) throws IOException {\n    //使用File对象创建流对象\n    File file = new File(\"a.txt\");\n    FileWriter fw = new FileWriter(file);\n    //使用文件名称创建流对象\n    FileWriter fw = new FileWriter(\"b.txt\");\n}\n```\n\n> write(int b) 方法，每次可以写出一个字符数据\n\n```java\npublic static void main(String[] args) throws IOException {\n    //使用文件名称创建流对象\n    FileWriter fw = new FileWriter(\"fw.txt\");\n    //写出数据\n    fw.write(97);//写出第1个字符\n    fw.write('b');//写出第2个字符\n    fw.write('C');//写出第3个字符\n    fw.write(30000);//写出第4个字符，中文编码表中30000对应一个汉字。\n    /*【注意】关闭资源时,与FileOutputStream不同。\n    如果不关闭,数据只是保存到缓冲区，并未保存到文件。 */\n    // fw.close();\n}\n```\n\n> 关闭和刷新\n\n关闭的流对象，是无法继续写出数据的。如果我们既想写出数据，又想继续使用流，就需要`flush` 方法了。\n\n- `flush` ：刷新缓冲区，流对象可以继续使用。\n\n- `close`:先刷新缓冲区，然后通知系统释放资源。流对象不可以再被使用了。\n\n> 字符数组 \n\n```java\npublic static void main(String[] args) throws IOException {\n        //使用文件名称创建流对象\n        FileWriter fw = new FileWriter(\"fw.txt\");\n        //字符串转换为字节数组\n        char[] chars = \"中秋节快乐\".toCharArray();\n        //写出字符数组\n        fw.write(chars);\n        //关闭资源\n        fw.close();\n}\n```\n\n> 字符串\n\n```java\npublic static void main(String[] args) throws IOException {\n        //使用文件名称创建流对象\n        FileWriter fw = new FileWriter(\"fw.txt\");\n        //字符串转换为字节数组\n        String msg = \"中秋节快乐\";\n        //写出字符数组\n        fw.write(msg);\n    \tfw.write(msg,2,2);\n        //关闭资源\n        fw.close();\n}\n```\n\n> 续写和换行\n\n```java\npublic static void main(String[] args) throws IOException {\n        //使用文件名称创建流对象，可以续写数据\n        FileWriter fw = new FileWriter(\"fw.txt\",true);\n        //写出字符串\n        fw.write(\"中秋节\");\n        //写出换行\n        fw.write(\"\\r\\n\");\n        //写出字符串\n        fw.write(\"快乐\");\n        //关闭资源\n        fw.close();\n}\n```\n\n>字符流，只能操作文本文件，不能操作图片，视频等非文本文件。\n>\n>当我们单纯读或者写文本文件时 ,使用字符流 ,其他情况使用字节流\n\n### 字符缓冲流\n\n**构造方法**\n\n- `public BufferedReader(Reader in)` ：创建一个 新的缓冲输入流。 \n\n- `public BufferedWriter(Writer out)`： 创建一个新的缓冲输出流。\n\n```java\n//创建字符缓冲输入流\nBufferedReader br = new BufferedReader(new FileReader(\"br.txt\"));\n//创建字符缓冲输出流\nBufferedWriter bw = new BufferedWriter(new FileWriter(\"bw.txt\"));\n```\n\n**特有方法**\n\n字符缓冲流的基本方法与普通字符流调用方式一致，不再阐述，我们来看它们具备的特有方法。\n\n> BufferedReader：`public String readLine()`: 读一行文字。 \n\n```java\npublic static void main(String[] args) throws IOException {\n    //创建流对象\n    BufferedReader br = new BufferedReader(new FileReader(\"in.txt\"));\n    //定义字符串,保存读取的一行文字\n    String line = null;\n    //循环读取,读取到最后返回null\n    while ((line = br.readLine())!=null) {\n        System.out.print(line);\n        System.out.println(\"------\");\n    }\n    br.close();\n}\n```\n\n> BufferedWriter：`public void newLine()`: 写一行行分隔符,由系统属性定义符号。 \n\n```java\npublic static void main(String[] args) throws IOException  {\n    //创建流对象\n    BufferedWriter bw = new BufferedWriter(new FileWriter(\"out.txt\"));\n    //写出数据\n    bw.write(\"中秋\");\n    //写出换行\n    bw.newLine();\n    bw.write(\"节\");\n    bw.newLine();\n    bw.write(\"快乐\");\n    bw.newLine();\n    //释放资源\n    bw.close();\n}\n```\n\n## 转换流\n\n### InputStreamReader类  \n\n转换流`java.io.InputStreamReader`，是Reader的子类，是从字节流到字符流的桥梁。它读取字节，并使用指定的字符集将其解码为字符。它的字符集可以由名称指定，也可以接受平台的默认字符集。 \n\n- `InputStreamReader(InputStream in)`: 创建一个使用默认字符集的字符流。 \n\n- `InputStreamReader(InputStream in, String charsetName)`: 创建一个指定字符集的字符流。\n\n```java\nInputStreamReader isr = new InputStreamReader(new FileInputStream(\"in.txt\"));\nInputStreamReader isr2 = new InputStreamReader(new FileInputStream(\"in.txt\"),\"GBK\");\n```\n\n> 编码读取\n\n```java\npublic static void main(String[] args) throws IOException {\n     //定义文件路径,文件为gbk编码\n     String FileName = \"E:\\\\file_gbk.txt\";\n     //创建流对象,默认UTF8编码\n     InputStreamReader isr = new InputStreamReader(new FileInputStream(FileName));\n     //创建流对象,指定GBK编码\n     InputStreamReader isr2 = new InputStreamReader(new FileInputStream(FileName),\"GBK\");\n     //定义变量,保存字符\n     int read;\n     //使用默认编码字符流读取,乱码\n     while ((read = isr.read()) != -1) {\n         System.out.print((char)read);//��Һ�\n     }\n     isr.close();\n     //使用指定编码字符流读取,正常解析\n     while ((read = isr2.read()) != -1) {\n         System.out.print((char)read);//大家好\n     }\n     isr2.close();\n }\n```\n\n### OutputStreamWriter类\n\n转换流`java.io.OutputStreamWriter` ，是Writer的子类，是从字符流到字节流的桥梁。使用指定的字符集将字符编码为字节。它的字符集可以由名称指定，也可以接受平台的默认字符集。 \n\n- `OutputStreamWriter(OutputStream in)`: 创建一个使用默认字符集的字符流。 \n\n- `OutputStreamWriter(OutputStream in, String charsetName)`: 创建一个指定字符集的字符流。\n\n> 编码写出\n\n```java\npublic static void main(String[] args) throws IOException {\n    //定义文件路径\n    String FileName = \"E:\\\\out.txt\";\n    //创建流对象,默认UTF8编码\n    OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(FileName));\n    //写出数据\n    osw.write(\"你好\");//保存为6个字节\n    osw.close();\n    //定义文件路径\n    String FileName2 = \"E:\\\\out2.txt\";\n    //创建流对象,指定GBK编码\n OutputStreamWriter osw2 = new OutputStreamWriter(new FileOutputStream(FileName2),\"GBK\");\n// 写出数据\n    osw2.write(\"你好\");//保存为4个字节\n    osw2.close();\n}\n```\n\n## 序列化\n\n###  概述\n\nJava 提供了一种对象序列化的机制。用一个字节序列可以表示一个对象，该字节序列包含该对象的数据、对象的类型和对象中存储的属性等信息。字节序列写出到文件之后，相当于文件中持久保存了一个对象的信息。 \n\n反之，该字节序列还可以从文件中读取回来，重构对象，对它进行反序列化。对象的数据、对象的类型和对象中存储的数据信息，都可以用来在内存中创建对象\n\n### ObjectOutputStream类\n\n`java.io.ObjectOutputStream` 类，将Java对象的原始数据类型写出到文件,实现对象的持久存储。\n\n`public ObjectOutputStream(OutputStream out)`： 创建一个指定OutputStream的ObjectOutputStream。\n\n```java\nFileOutputStream fileOut = new FileOutputStream(\"employee.txt\");\nObjectOutputStream out = new ObjectOutputStream(fileOut);\n```\n\n> 序列化操作\n\n```java\npublic class Employee implements java.io.Serializable {\n    public String name;\n    public String address;\n    public transient int age;//transient瞬态修饰成员,不会被序列化\n    public void addressCheck() {\n        System.out.println(\"Address  check : \" + name + \" -- \" + address);\n    }\n}\n```\n\n```java\npublic class SerializeDemo{\n    public static void main(String [] args){\n        Employee e = new Employee();\n        e.name = \"zhangsan\";\n        e.address = \"zhengzhou\";\n        e.age = 20;\n            try {\n                //创建序列化流对象\n  ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\"employee.txt\"));\n                //写出对象\n                out.writeObject(e);\n                //释放资源\n                out.close();\n                fileOut.close();\n                System.out.println(\"Serialized data is saved\");\n                //姓名，地址被序列化，年龄没有被序列化。\n            } catch(IOException i)\n            {\n                i.printStackTrace();\n            }\n    }\n}\n```\n\n### ObjectInputStream类\n\nObjectInputStream反序列化流，将之前使用ObjectOutputStream序列化的原始数据恢复为对象。 \n\n`public ObjectInputStream(InputStream in)`： 创建一个指定InputStream的ObjectInputStream。\n\n`public final Object readObject ()` : 读取一个对象。\n\n```java\npublic class DeserializeDemo {\n    public static void main(String [] args){\n        Employee e = null;\n        try{\n            //创建反序列化流\n            FileInputStream fileIn = new FileInputStream(\"employee.txt\");\n            ObjectInputStream in = new ObjectInputStream(fileIn);\n            //读取一个对象\n            e = (Employee) in.readObject();\n            //释放资源\n            in.close();\n            fileIn.close();\n        }catch(IOException i){\n            //捕获其他异常\n            i.printStackTrace();\n            return;\n        }catch(ClassNotFoundException c){\n            //捕获类找不到异常\n            System.out.println(\"Employee class not found\");\n            c.printStackTrace();\n            return;\n        }\n        //无异常,直接打印输出\n        System.out.println(\"Name: \" + e.name);//zhangsan\n        System.out.println(\"Address: \" + e.address);//zhengzhou\n        System.out.println(\"age: \" + e.age);//0\n    }\n}\n```\n\n## 属性集\n\n### 概述\n\n`java.util.Properties` 继承于`Hashtable` ，来表示一个持久的属性集。它使用键值结构存储数据，每个键及其对应值都是一个字符串。该类也被许多Java类使用，比如获取系统属性时，`System.getProperties` 方法就是返回一个`Properties`对象。\n\n### Properties类\n\n`public Properties()` :创建一个空的属性列表。\n\n`public Object setProperty(String key, String value)` ： 保存一对属性。  \n\n`public String getProperty(String key)` ：使用此属性列表中指定的键搜索属性值。\n\n`public Set<String> stringPropertyNames()` ：所有键的名称的集合。\n\n```java\n public class ProDemo {\n     public static void main(String[] args) throws FileNotFoundException {\n         //创建属性集对象\n        Properties properties = new Properties();\n        //添加键值对元素\n        properties.setProperty(\"filename\", \"a.txt\");\n        properties.setProperty(\"length\", \"209385038\");\n        properties.setProperty(\"location\", \"D:\\\\a.txt\");\n        //打印属性集对象\n        System.out.println(properties);\n        // 通过键,获取属性值\n        System.out.println(properties.getProperty(\"filename\"));\n        System.out.println(properties.getProperty(\"length\"));\n        System.out.println(properties.getProperty(\"location\"));\n        //遍历属性集,获取所有键的集合\n        Set<String> strings = properties.stringPropertyNames();//打印键值对\n        for (String key : strings ){\n            System.out.println(key+\"--\"+properties.getProperty(key));\n        }\n     }\n }\n```\n\n> 与流相关的方法\n\n`public void load(InputStream inStream)`： 从字节输入流中读取键值对。 \n\n```java\n public class ProDemo2 {\n     public static void main(String[] args) throws FileNotFoundException {\n         //创建属性集对象\n         Properties pro = new Properties();\n         //加载文本中信息到属性集\n         pro.load(new FileInputStream(\"read.txt\"));\n         //遍历集合并打印\n         Set<String> strings = pro.stringPropertyNames();\n         for (String key : strings ){\n             System.out.println(key+\" -- \"+pro.getProperty(key));\n         }\n     }\n }\n```\n\n> 文本中的数据，必须是键值对形式，可以使用空格、等号、冒号等符号分隔。","tags":["IO流"],"categories":["学习之路"]},{"title":"Java","url":"/2022/09/13/Java/","content":"\n## Java简介\n\n### Java特性和优势\n\n- 简单性 \n\n  Java就是C++语法的简化版，我们也可以将Java称之为“C++-”。指的就是将C++的一些内容去掉；比如：头文件，指针运算，结构，联合，操作符重载，虚基类等等。\n\n  同时，由于语法基于C语言，因此学习起来完全不费力。\n\n- 面向对象 \n\n  面向对象是一种程序设计技术，非常适合大型软件的设计和开发。由于C++为了照顾大量C语言使用者而兼容了C，使得自身仅仅成为了带类的C语言，多少影响了其面向对象的彻底性！\n\n  Java则是完全的面向对象语言。\n\n- 可移植性 \n\n  这是Java的核心优势。Java在设计时就很注重移植和跨平台性。比如：Java的int永远都是32位。不像C++可能是16，32，可能是根据编译器厂商规定的变化。这样的话程序的移植就会非常麻烦。\n\n- 高性能 \n\n  Java最初发展阶段，总是被人诟病“性能低”；客观上，高级语言运行效率总是低于低级语言的，这个无法避免。Java语言本身发展中通过虚拟机的优化提升了几十倍运行效率。\n\n  比如，通过JIT(JUST IN TIME)即时编译技术提高运行效率。 将一些“热点”字节码编译成本地机器码，并将结果缓存起来，在需要的时候重新调用。这样的话，使Java程序的执行效率大大提高，\n\n  某些代码甚至接待C++的效率。因此，Java低性能的短腿，已经被完全解决了。业界发展上，我们也看到很多C++应用转到Java开发，很多C++程序员转型为Java程序员。\n\n- 分布式 \n\n  Java是为Internet的分布式环境设计的，因为它能够处理TCP/IP协议。事实上，通过URL访问一个网络资源和访问本地文件是一样简单的。Java还支持远程方法调用(RMI,Remote Method Invocation)，\n\n  使程序能够通过网络调用方法。\n\n- 多线程 \n\n  多线程的使用可以带来更好的交互响应和实时行为。 Java多线程的简单性是Java成为主流服务器端开发语言的主要原因之一。\n\n- 安全性 \n\n  Java适合于网络/分布式环境，为了达到这个目标，在安全性方面投入了很大的精力，使Java可以很容易构建防病毒，防篡改的系统。\n\n- 健壮性\n\n  Java是一种健壮的语言，吸收了C/C++ 语言的优点，但去掉了其影响程序健壮性的部分（如：指针、内存的申请与释放等）。Java程序不可能造成计算机崩溃。即使Java程序也可能有错误。\n\n  如果出现某种出乎意料之事，程序也不会崩溃，而是把该异常抛出，再通过异常处理机制加以处理。\n\n### Java三大版本\n\n- Write Once、Run Anywhere\n- JavaSE: 标准版(桌面程序,控制台开发......)\n- JavaME:嵌入式开发(手机,小家电...)\n- JavaEE :E企业级开发(web端，服务器开发...)\n\n### Java学习路线\n\n- 首先要学习Java SE，掌握Java语言本身、Java核心开发技术以及Java标准库的使用；\n- 如果继续学习Java EE，那么Spring框架、数据库开发、分布式架构就是需要学习的；\n- 如果要学习大数据开发，那么Hadoop、Spark、Flink这些大数据平台就是需要学习的，他们都基于Java或Scala开发；\n- 如果想要学习移动开发，那么就深入Android平台，掌握Android APP开发，学习Kotlin语言。Kotlin支持Android开发，并提供了一系列的Android开发插件。\n\n## Java环境配置\n\n### 下载jdk8\n\n[神谕|Java 8 (oracle.com)](https://www.oracle.com/java/technologies/downloads/)\n\n> 下载时需要同意协议，注册账号\n\n### Java 开发环境配置\n\n[Java 开发环境配置 | 菜鸟教程 (runoob.com)](https://www.runoob.com/java/java-environment-setup.html)\n\n> 跟着教程走\n\n **测试JDK是否安装成功**\n\n1、\"开始\"->\"运行\"，键入\"cmd\"；\n\n2、键入命令: **java -version**、**java**、**javac** 几个命令，出现信息，说明环境变量配置成功；\n\n### 下载IDEA\n\n[IntelliJ IDEA: The Capable & Ergonomic Java IDE by JetBrains](https://www.jetbrains.com/idea/)\n\n> 注：正版收费，破解教程如下查找\n\n[IDE激活网 (idejihuo.com)](http://blog.idejihuo.com/)\n\n### IDEA常用快捷鍵\n\n- 快速生成main方法和输出语句\n  - main方法：main或者psvm，回车\n  - 输出语句：sout，回车\n\n- 常用快捷键\n  - Ctrl+Y：删除所在行\n  - Ctrl+D：复制数据到下一行\n  - Ctrl+X：剪切数据，可以用来删除所在行\n  - Alt+enter：代码提示\n  - Alt+insert：快捷生成set、继承...等方法\n  - Ctrl+Alt+T：快捷生成if()、try{}...等语句\n  - Ctrl+Alt+L：格式化代码，建议自己写代码的时候就注意格式\n  - Ctrl+/：对选中的代码添加单行注释，如果想取消注释，再来一次即可\n  - Ctrl+Shift+/：对选中的代码添加多行注释，如果想取消注释，再来一次即可\n\n### 第一个Java程序\n\n这个定义被称为**class**（类），这里的类名是**Hello**，大小写敏感，class用来定义一个类，**public**表示这个类是公开的，public、class都是Java的**关键字**，必须小写，**Hello**是类的名字，按照习惯，首字母**H**要大写。而花括号**{}**中间则是类的定义。\n\n定义了一个名为**main**的方法：方法的代码每一行用**;**结束\n\n```java\npublic class Hello {\n    public static void main(String[] args) {\n        System.out.println(\"Hello, world!\");\n    }\n}\n```\n\n我们把代码保存为文件时，文件名必须是`Hello.java`，而且文件名也要注意大小写，因为要和我们定义的类名`Hello`完全保持一致。\n\n一个Java源码只能定义一个`public`类型的class，并且class名称和文件名要完全一致。\n\n## Java基础语法\n\n### 注释\n\n> 平时我们编写代码，在代码量比较少的时候，我们还可以看懂自己写的，但是当项目结构一旦复杂起来，我们就需要用到注释了。\n> 注释并不会被执行，是给我们写代码的人看的,书写注释是一个非常好的习惯平时写代码一定要注意规范。\n\nJava中的注释有三种:\n\n```java\n单行注释：//我是单行注释\n\n多行注释：/*我是多行注释*/\n\n文档注释：/**\n\t\t*我是文档注释\n\t\t*文档注释不可以随意使用\n\t\t*/\n```\n\n### 标识符\n\n- 所有的标识符都应该以字母(A-Z或者a-z),美元符($)、或者下划线(_）开始\n- 首字符之后可以是字母(A-Z或者a-z),美元符（$）、下划线（_）或数字的任何字符组合\n- 不能使用关键字作为变量名或方法名。\n- 标识符是大小写敏感的\n- 合法标识符举例: age、$salary._value、__1_value\n- 非法标识符举例:123abc、-salary、#abc\n- 可以使用中文命名，但是一般不建议这样去使用，也不建议使用拼音，很Low\n\n### 命名的规范\n\n**文件命名规范**\n\n①包名:所有字母都小写。如: xxx.yyy.zzz\n②类名、接名:若出现多个单词，每个单词首字母都大写。如: XxxYyyZzz\n③方法名、变量名:若出现多个单词，第一个单词的首字母小写，其余单词首字母都大写。如: xxxYyyZzz\n④常量名:所有字母都大写，每个单词之间以\"_”分隔。如:XXX_YYY_ZZZ\n\n**变量的命名规范**\n\n- 所有变量、方法、类名:见名知意\n- 类成员变量:首字母小写和驼峰原则\n- monthSalary局部变量:首字母小写和驼峰原则\n- 常量:大写字母和下划线:MAX_VALUE\n- 类名:首字母大写和驼峰原则: Man, GoodMan\n- 方法名:首字母小写和驼峰原则: run(), runRun()\n\n### 关键字\n\n| **关键字**   | **含义**                                                     |\n| ------------ | ------------------------------------------------------------ |\n| abstract     | 表明类或者成员方法具有抽象属性                               |\n| assert       | 断言，用来进行程序调试                                       |\n| boolean      | 基本数据类型之一，声明布尔类型的关键字                       |\n| break        | 提前跳出一个块                                               |\n| byte         | 基本数据类型之一，字节类型                                   |\n| case         | 用在switch语句之中，表示其中的一个分支                       |\n| catch        | 用在异常处理中，用来捕捉异常                                 |\n| char         | 基本数据类型之一，字符类型                                   |\n| class        | 声明一个类                                                   |\n| const        | 保留关键字，没有具体含义                                     |\n| continue     | 回到一个块的开始处                                           |\n| default      | 默认，例如，用在switch语句中，表明一个默认的分支。Java8 中也作用于声明接口函数的默认实现 |\n| do           | 用在do-while循环结构中                                       |\n| double       | 基本数据类型之一，双精度浮点数类型                           |\n| else         | 用在条件语句中，表明当条件不成立时的分支                     |\n| enum         | 枚举                                                         |\n| extends      | 表明一个类型是另一个类型的子类型。对于类，可以是另一个类或者抽象类；对于接口，可以是另一个接口 |\n| final        | 用来说明最终属性，表明一个类不能派生出子类，或者成员方法不能被覆盖，或者成员域的值不能被改变，用来定义常量 |\n| finally      | 用于处理异常情况，用来声明一个基本肯定会被执行到的语句块     |\n| float        | 基本数据类型之一，单精度浮点数类型                           |\n| for          | 一种循环结构的引导词                                         |\n| goto         | 保留关键字，没有具体含义                                     |\n| if           | 条件语句的引导词                                             |\n| implements   | 表明一个类实现了给定的接口                                   |\n| import       | 表明要访问指定的类或包                                       |\n| instanceof   | 用来测试一个对象是否是指定类型的实例对象                     |\n| int          | 基本数据类型之一，整数类型                                   |\n| interface    | 接口                                                         |\n| long         | 基本数据类型之一，长整数类型                                 |\n| native       | 用来声明一个方法是由与计算机相关的语言（如C/C++/FORTRAN语言）实现的 |\n| new          | 用来创建新实例对象                                           |\n| package      | 包                                                           |\n| private      | 一种访问控制方式：私用模式                                   |\n| protected    | 一种访问控制方式：保护模式                                   |\n| public       | 一种访问控制方式：共用模式                                   |\n| return       | 从成员方法中返回数据                                         |\n| short        | 基本数据类型之一,短整数类型                                  |\n| static       | 表明具有静态属性                                             |\n| strictfp     | 用来声明FP_strict（单精度或双精度浮点数）表达式遵循[IEEE 754](https://baike.baidu.com/item/IEEE 754?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2NjE5NDgwMjAsImZpbGVHVUlEIjoiMzREVEdzTVd4THcwQ1JXNyIsImlhdCI6MTY2MTk0NzcyMCwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjotNzExNDMyMTI5MH0.RHTMzQaOrUYxo_1wsxydlUk7Z0NakbUt6qBexRcDsdw)算术规范 |\n| super        | 表明当前对象的父类型的引用或者父类型的构造方法               |\n| switch       | 分支语句结构的引导词                                         |\n| synchronized | 表明一段代码需要同步执行                                     |\n| this         | 指向当前实例对象的引用                                       |\n| throw        | 抛出一个异常                                                 |\n| throws       | 声明在当前定义的成员方法中所有需要抛出的异常                 |\n| transient    | 声明不用序列化的成员域                                       |\n| try          | 尝试一个可能抛出异常的程序块                                 |\n| void         | 声明当前成员方法没有返回值                                   |\n| volatile     | 表明两个或者多个变量必须同步地发生变化                       |\n| while        | 用在循环结构中                                               |\n\n### 变量\n\n> 变量：用于保存数据（局部变量 & 成员变量）\n\n变量的格式：数据类型  变量名  =  值;\n\n```java\n声明一个变量;\n数据类型 变量名; 如 int a\n    \n为变量赋值;\n变量名 = 值；  如： a= 10;\n\n声明一个变量并赋值\nint var = 10;\n```\n\n> 变量的概念：\n\n①在内存中开辟一块内存空间\n\n②该空间有名称（变量名）有类型（数据类型）\n\n③变量可以在指定的范围内不断的变化\n\n> 变量的注意：\n\n①作用域：变量作用在所属的那对 {} 内\n\n②局部变量在使用前必须赋初始值\n\n③先声明，后使用\n\n\n### 数据类型\n\n> Java为强类型语言：要求变量的使用要严格符合规定，所有变量都必须先定义后才能使用\n\nJava 的两大数据类型:\n\n- 内置数据类型\n  - **byte** 数据类型是8位、有符号的，以二进制补码表示的整数；byte 类型用在大型数组中节约空间，主要代替整数\n  - **short** 数据类型是16位、有符号的以二进制补码表示的整数;\n  - **int** 数据类型是32位、有符号的以二进制补码表示的整数; 一般地整型变量默认为 int 类型；\n  - **long** 数据类型是 64 位、有符号的以二进制补码表示的整数；这种类型主要使用在需要比较大整数的系统上\n  - **float** 数据类型是单精度、32位、符合IEEE 754标准的浮点数；float 在储存大型浮点数组的时候可节省内存空间；\n  - **double** 数据类型是双精度、64 位、符合 IEEE 754 标准的浮点数；浮点数的默认类型为 double 类型；\n  - **char** 类型是一个单一的 16 位 Unicode 字符；char 数据类型可以储存任何字符；\n  - **boolean**数据类型表示一位的信息; 这种类型只作为一种标志来记录 true/false 情况；\n\n- 引用数据类型\n  - 在Java中，引用类型的变量非常类似于C/C++的指针。引用类型指向一个对象，指向对象的变量是引用变量。这些变量在声明时被指定为一个特定的类型，比如 Employee、Puppy 等。变量一旦声明后，类型就不能被改变了。\n  - 对象、数组都是引用数据类型。\n  - 所有引用类型的默认值都是null。\n  - 一个引用变量可以用来引用任何与之兼容的类型。\n\n#### 自动类型转换\n\n整型、实型（常量）、字符型数据可以混合运算。运算中，不同类型的数据先转化为同一类型，然后进行运算。\n\n```java\n转换从低级到高级\nbyte,short,char —> int —> long —> float —> double \n```\n\n数据类型转换必须满足如下规则：\n\n- 不能对**boolean**类型进行类型转换。\n\n- 不能把**对象类型**转换成不相关类的对象。\n\n- 在把容量大的类型转换为容量小的类型时必须使用**强制类型转换**。\n\n- 转换过程中可能导致溢出或损失精度。\n\n- 浮点数到整数的转换是通过舍弃小数得到，而不是四舍五入。\n\n```java\n  public class Zhuan{\n        public static void main(String[] args){\n            char c1='a';//定义一个char类型\n            int i1 = c1;//char自动类型转换为int\n            System.out.println(\"char自动类型转换为int后的值等于\"+i1);\n            char c2 = 'A';//定义一个char类型\n            int i2 = c2+1;//char 类型和 int 类型计算\n            System.out.println(\"char类型和int计算后的值等于\"+i2);\n        }\n}\n```\n\n#### 强制类型转换\n\n- 条件是转换的数据类型必须是兼容的。\n  - 高级到低级用强制类型转换\n  - 不能对布尔值进行转换\n  - 不能把对象类型转换为不相干的类型,\n  - 转换的时候可能存在内存溢出，或者精度问题!\n- 格式：(type)value   type是要强制类型转换后的数据类型。\n\n```java\npublic class Huan{\n    public static void main(String[] args){\n        int i1 = 123;\n        byte b = (byte)i1;//强制类型转换为byte\n        System.out.println(\"int强制类型转换为byte后的值等于\"+b);\n    }\n}\n```\n\n### 转义字符\n\n| 转义字符 | 意义                                | ASCII码值（十进制） |\n| -------- | ----------------------------------- | ------------------- |\n| \\a       | 响铃(BEL)                           | 007                 |\n| \\b       | 退格(BS) ，将当前位置移到前一列     | 008                 |\n| \\f       | 换页(FF)，将当前位置移到下页开头    | 012                 |\n| \\n       | 换行(LF) ，将当前位置移到下一行开头 | 010                 |\n| \\r       | 回车(CR) ，将当前位置移到本行开头   | 013                 |\n| \\t       | 水平制表(HT) （跳到下一个TAB位置）  | 009                 |\n| \\v       | 垂直制表(VT)                        | 011                 |\n| \\\\       | 代表一个反斜线字符''\\'              | 092                 |\n| \\'       | 代表一个单引号（撇号）字符          | 039                 |\n| \\\"       | 代表一个双引号字符                  | 034                 |\n| \\?       | 代表一个问号                        | 063                 |\n| \\0       | 空字符(NUL)                         | 000                 |\n| \\ddd     | 1到3位八进制数所代表的任意字符      | 三位八进制          |\n| \\xhh     | 十六进制所代表的任意字符            | 十六进制            |\n\n**注意：**\n\n1. 区分，斜杠：\"/\" 与 反斜杠：\"\\\" ,此处不可互换\n\n2. \\xhh 十六进制转义不限制字符个数 '\\x000000000000F' == '\\xF'\n\n### 运算符\n- 算术运算符:+， -，*，l， %，++， --*\n- 赋值运算符:=\n- 关系运算符:>，<，>=，<=，==，!= instanceof\n- 逻辑运算符: &&，||，!\n- 位运算符: &，|，^，~，>>，<<，>>>(了解! ! ! )\n- 条件运算符:?∶\n- 扩展赋值运算符:+=，-=，*=，/=\n\n#### 算术运算符\n\n在数学表达式中的使用方式与在代数中使用的方式相同。下表列出了算术运算符的使用示例\n\n假设整数类型变量`A`的值为：`10`，变量`B`的值为：`20`\n\n| 运算符 | 描述                                      | 示例                     |\n| ------ | ----------------------------------------- | ------------------------ |\n| `+`    | 加法运算符,第一个操作数加上第二个数操作数 | `A + B`结果为：`30`      |\n| `-`    | 减法运算符,从第一个操作数减去第二个操作数 | `A - B`结果为：`-10`     |\n| `*`    | 两个操作数相乘                            | `A * B`结果为：`200`     |\n| `/`    | 左操作数除以右操作数返回模值              | `B / A`结果为：`2`       |\n| `%`    | 左操作数除以右操作数返回余数              | `B / A`结果为：`0`       |\n| `++`   | 将操作数的值增加`1`                       | `A++`，则`A`的值为：`11` |\n| `--`   | 将操作数的值减`1`                         | `A--`，则`A`的值为：`9`  |\n\n#### 关系运算符\n\nJava语言支持以下关系运算符。假设变量`A`的值是`10`，变量`B`的值是`20`\n\n| 运算符 | 描述                                                         | 示例             |\n| ------ | ------------------------------------------------------------ | ---------------- |\n| `==`   | 等于运算符，检查两个操作数的值是否相等，如果相等，则条件变为真。 | `A==B`结果为假。 |\n| `!=`   | 不等于运算符，检查两个操作数的值是否不相等，如果不相等，则条件变为真。 | `A!=B`结果为真。 |\n| `>`    | 大于运算符，检查左操作数的值是否大于右操作数的值，如果大于，则条件变为真。 | `A>B`结果为假。  |\n| `<`    | 小于运算符，检查左操作数的值是否小于右操作数的值，如果小于，则条件变为真。 | `A<B`结果为真。  |\n| `>=`   | 大于或等于运算符，检查左操作数的值是否大于等于右操作数的值，如果大于或等于，则条件变为真。 | `A>=B`结果为假。 |\n| `<=`   | 小于或等于运算符，检查左操作数的值是否小于或等于右操作数的值，如果小于或等于，则条件变为真。 | `A<=B`结果为真。 |\n\n#### 逻辑运算符\n\n下表列出了逻辑运算符\n\n假设布尔变量`A`的值为：`true`，变量`B` 的值为：`false`\n\n| 运算符 | 描述                                                         | 示例                      |\n| ------ | ------------------------------------------------------------ | ------------------------- |\n| `&&`   | 逻辑AND运算符。 如果两个操作数都不为零，则条件成立。         | `(A && B)`结果为：`false` |\n| ΙΙ     | 逻辑OR运算符。 如果两个操作数中的任何一个非零，则条件变为真。 | (A ΙΙ B)结果为：`true`    |\n| `!`    | 逻辑非运算符。用于反转其操作数的逻辑状态。 如果条件为真，则口逻辑NOT运算符将为`false`。 | `!(A && B)`结果为：`true` |\n\n#### 赋值运算符\n\n以下是Java语言支持的赋值运算符 \n\n| 运算符 | 描述                                                         | 示例                                |\n| ------ | ------------------------------------------------------------ | ----------------------------------- |\n| `=`    | 简单赋值运算符。 将右侧操作数的值分配给左侧操作数。          | `C = A + B`将`A + B`的值分配给`C`。 |\n| `+=`   | 相加与赋值运算符。 它将右操作数相加到左操作数并将结果分配给左操作数。 | `C += A`等于`C = C + A`。           |\n| `-=`   | 减去与赋值运算符。 它从左操作数中减去右操作数，并将结果赋给左操作数。 | `C -= A`等于`C = C - A`。           |\n| `*=`   | 乘以与赋值运算符。 它将右操作数与左操作数相乘，并将结果赋给左操作数。 | `C *= A`等于`C = C * A`。           |\n| `/=`   | 除以与赋值运算符。 它将左操作数除以右操作数，并将结果赋给左操作数。 | `C /= A`等于`C = C / A`。           |\n| `%=`   | 模数与赋值运算符。 它使用两个操作数来计算获取模数，并将结果赋给左操作数。 | `C %= A`等于`C = C % A`。           |\n| `<<=`  | 左移与赋值运算符。                                           | `C <<= 2`与`C = C << 2`相同         |\n| `>>=`  | 右移与赋值运算符。                                           | `C >>= 2`与`C = C >> 2`相同         |\n| `&=`   | 按位与赋值运算符。                                           | `C &= 2`与`C = C & 2`相同           |\n| `^=`   | 按位异或和赋值运算符。                                       | `C ^= 2`与`C = C ^ 2`相同           |\n| Ι=     | 按位包含或与赋值运算符。                                     | C Ι= 2与C = C Ι=2相同               |\n\n#### 三元运算符\n\n```java\n(关系表达式)?表达式1:表达式2;\nint x = 10;\nint y = 5;\nint z;\n如果x大于y则是true，将x赋值给z;\n如果x不大于y则是false，将y赋值给z;\nz =(x >y)?x : y;\nsystem.out.println( \"x =\" + x);\n```\n\n## Java流程控制\n\n### Scanner类\n\n之前我们学的基本语法中我们并没有实现程序和人的交互，但是Java给我们提供了这样一个工具类，我们可以获取用户的输入。我们可以通过Scanner类来获取用户的输入\n基本语法:\n\n```java\nScanner s = new Scanner(System.in);\n```\n\n通过Scanner类的`next()`与`nextLine()`方法获取输入的字符串，在读取前我们一般需要使`hasNext()`与`hasNextLine()`判断是否还有输入的数据。\n\n```java\n\t\t//创建一个扫描器对象，用于接收键盘数据\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"使用next方式接收: \");\n        //判断用户有没有输入字符串\n        if (scanner.hasNext()){\n            //使用next方式接收\n            String str = scanner.next();\n            System.out.println(\"输出的内容为:\"+str);\n        }\n\t\tscanner.close();//关闭资源(scanner) 同时释放内存\n```\n\n> next():\n\n1、一定要读取到有效字符后才可以结束输入。\n\n2、对输入有效字符之前遇到的空白，next()方法会自动将其去掉。\n\n3、只有输入有效字符后才将其后面输入的空白作为分隔符或者结束符。\n\n4、next()不能得到带有空格的字符串。\n\n> nextLine():\n\n1、以Enter为结束符,也就是说nextLine()方法返回的是输入回车之前的所有字符。\n\n2、可以获得空白。\n\n### 顺序结构\n\n> JAVA的基本结构就是顺序结构除非特别指明，否则就按照顺序一句一句执行。\n>\n> 顺序结构是最简单的算法结构。\n\n> 语句与语句之间，框与框之间是按从上到下的顺序进行的，它是由若干个依次执行的处理步骤组成的，它是任何一个算法都离不开的一种基本算法结构。\n\n### 选择结构\n\n#### if单选择结构\n\n```java\npublic static void main(String[] args) {\n        //创建一个扫描器对象，用于接收键盘数据\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"输出考试分数\");\n        int sum = scanner.nextInt();\n        ///考试分数小于60分就不及格。\n        if (sum<60){\n\n            System.out.println(\"不及格:\"+sum);\n        }\n   \n        scanner.close();\n  }\n```\n\n#### if双选择结构\n\n```java\npublic static void main(String[] args) {\n        //创建一个扫描器对象，用于接收键盘数据\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"输出考试分数\");\n        int sum = scanner.nextInt();\n        ///考试分数小于60分就不及格，考试分数大于60就是及格\n        if (sum<60){\n            System.out.println(\"不及格:\"+sum);\n        }else{\n            System.out.println(\"及格:\"+sum);\n        }\n        \n        scanner.close();\n      \n    }\n```\n\n#### 嵌套的if结构\n\n```java\npublic static void main(String[] args) {\n        //创建一个扫描器对象，用于接收键盘数据\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"输入考试分数\");\n        int sum = scanner.nextInt();\n        ///考试分数小于60分就不及格。\n        if (sum<60){\n            System.out.println(\"不及格:\"+sum);\n        }else if (sum<=70 && sum>=60){\n            System.out.println(\"及格:\" + sum);\n        } else if (sum<=80 && sum>70) {\n            System.out.println(\"良好:\" + sum);\n        }else if (sum<=90 && sum>80){\n            System.out.println(\"优:\" + sum);\n        }else {\n            System.out.println(\"完美:\" + sum);\n        }\n        scanner.close();\n      \n    }\n```\n\n#### switch多选择结构\n\n````java\npublic static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"输入一个数\");\n        int age = scanner.nextInt();\n        switch(age){\n            case 10:\n                System.out.println(\"10\");\n                break;\n            case 9:\n                System.out.println(\"9\");\n                break;\n            case 8:\n                System.out.println(\"8\");\n                break;\n            //除上述条件，执行default:\n            default:\n                System.out.println(\"数\");\n                break;\n        }\n        scanner.close();\n\n    }\n````\n\n> **break** :在循环的过程中，在满足某些条件的情况下，中断循环的执行。\n>\n> 注意: switch 中的break用于结束某个分支。而循环中的 break 是中断循环的。\n\n```java\nfor (int i = 1; i <= 10; i++) {\n            if (i == 5) {\n                //中断循环 \n                break;\n            }\n        System.out.println(i);\n    }\nSystem.out.println(\"循环结束\");\n```\n\n> **continue** :在循环的过程中，在满足某些条件的情况下，跳过循环中的部分代码不执行，直接进入下次循环。\n\n```java\nfor (int i = 1; i <= 10; i++) {\n            if (i == 5) {\n                //跳过continue后面的代码，进入循环的下一步 \n                continue;\n            } \n    \tSystem.out.println(i);\n\t}\nSystem.out.println(\"循环结束\");\n```\n\n### 循环结构\n\n> 只要布尔表达式为true，循环就会一直执行下去。\n> 我们大多数情况是会让循环停止下来的，我们需要一个让表达式失效的方式来结束循环。少部分情况需要循环一直执行，比如服务器的请求响应监听等。\n> 循环条件一直为true就会造成无限循环【死循环】，我们正常的业务编程中应该尽量避免死循环。会影响程序性能或者造成程序卡死奔溃!\n\n#### while\n\n```java\nint age=0;\nwhile(age<10){\n    age++;\n    System.out.println(age);\n}\n```\n\n#### do while\n\n> 对于while语句而言，如果不满足条件，则不能进入循环。但有时候我们需要即使不满足条件，也至少执行一次。\n> do...while循环和while循环相似，不同的是，do...while循环至少会执行一次。\n\n```java\npublic static void main(String[] args) {\n        int age =0;\n        do{\n            age++;\n            System.out.println(age);\n        }\n        while(age<10);\n}\n```\n\n> **While和do-While的区别:**\n> while先判断后执行。dowhile是先执行后判断!\n> Do...while总是保证循环体会被至少执行一次!这是他们的主要差别。\n\n### for循环\n\n> 虽然所有循环结构都可以用while或者do...while表示，但Java提供了另一种语句—— for循环，使一些循环结构变得更加简单。\n> for循环语句是支持迭代的一种通用结构，是最有效、最灵活的循环结构。\n\n```java\npublic static void main(String[] args) {\n        int a = 1; //初始化条件\n        while (a<=100){//条件判断\n            System.out.println(a); //循环体\n            a+=2; //迭代\n        }\n        System.out.println( \"while循环结束!\");//初始化I/条件判断//迭代\n        for (int i=1;i<=100;i++){\n            System.out.println(i) ;\n        }\n        System.out.println( \"for循环结束! \");\n\n}\n```\n\n> **关于for循环有以下几点说明;**\n> 最先执行初始化步骤。可以声明一种类型，但可初始化一个或多个循环控制变量，也可以是空语句。\n> 然后，检测布乐表达式的值。如果为 true，循环体被执行。如果为false，循环终止，开始执行循环体后面的语句。执行一次循环后，更新循环控制变量(迭代因子控制循环变量的增减)。\n> 再次检测布尔表达式。循环执行上面的过程。\n\nJava**增强for循环语法**格式如下:\n\n```java\nfor(声明语句:表达式){\n{\n\t//代码句子\n}\n```\n\n**声明语句:**声明新的局部变量，该变量的类型必须和数组元素的类型匹配。其作用域限定在循环语句块，其值与此时数组元素的值相等。\n**表达式:**表达式是要访问的数组名，或者是返回值为数组的方法。\n\n```java\npublic static void main(String[] args) {\n        int[] numbers = {10,20,30,40,50}; //定义了一个数组\n        //遍历数组的元素\n        for (int x :numbers){\n            System.out.println(x);\n        }\n    \tSystem.out.println(\"--------------\");\n        //等于for(i)循环\n        for (int i = 0;i<5;i++){\n            System.out.println( numbers[i]);\n        }\n\n}\n```\n\n### goto关键字\n\ngoto关键字很早就在程序设计语言中出现。尽管goto仍是Java的一个保留字，但并未在语言中得到正式使用;Java没有goto。然而，在break和continue这两个关键字的身上，我们仍然能看出一些goto的影子---带标签的break和continue。\n“标签”是指后面跟一个冒号的标识符，例如: label:\n对Java来说唯一用到标签的地方是在循环语句之前。而在循环之前设置标签的唯一理由是:我们希望在其中嵌套另个循环，由于break和continue关键字通常只中断当前循环，但若随同标签使用，它们就会中断到存在标签的地方。**很少使用！**\n\n> 说白了，就是跳转到指定的循环继续执行;\n\n## Java方法\n\n> **Java方法是语句的集合**，它们在一起执行一个功能。\n> 方法是解决一类问题的步骤的有序组合\n> **方法包含**于类或对象中\n> 方法在程序中被创建，在其他地方被引用\n> **设计方法的原则:**方法的本意是功能块，就是实现某个功能的语句块的集合。\n> 我们设计方法的时候，最好保持方法的原子性，就是一个方法只完成1个功能，这样利于我们后期的扩展。\n\n```java\npublic static void main(String[] args) {\n    \t//main方法\n        int sum = add(1,2);\n        System.out.println(sum);\n    \t//调用test()\n        test();\n    }\n\t//创建add()方法 static关键字\n    public static int add(int a,int b){\n        return a+b;//return 返回值（a+b）\n    }\n\t//创建test()方法\n\tpublic static void test() {\n    for (int i=0;i<=1000;i++){\n        if (i%5==0) {\n            System.out.println(i+\"\\t\");\n        }\n        if (i%(5*3)==0) {\n            System.out.println(\"\");\n            //System.out.println(\"\\n\");\n        }\n        //println输出完会换行\n        //print输出完不会换行\n    }\n```\n\n#### 方法的定义\n\nJava的方法类似于其它语言的函数，是一段用来完成特定功能的代码片段，一般情况下，定义\n一个方法包含以下语法:\n\n```java\n修饰符 返回值类型 方法名(参数类型 参数名){\n   \n\t//方法体\n\treturn返回值;\n}\n```\n\n\n\n**方法包含一个方法头和一个方法体**。下面是一个方法的所有部分:\n**修饰符: ** 这是可选的，告诉编译器如何调用该方法。定义了该方法的访问类型。\n**返回值类型︰**方法可能会返回值。returnValueType是方法返回值的数据类型。有些方法执行所需的操作，但没有返回值。在这种情况下，returnValueType是关键字void。\n**方法名: ** 是方法的实际名称。方法名和参数表共同构成方法签名。\n**参数类型:**  参数像是一个占位符。当方法被调用时，传递值给参数。这个值被称为实参或变量。参数列表是指方法的参数类型、顺序和参数的个数。参数是可选的，方法可以不包含任何参数。\n\n- 形式参数:在方法被调用时用于接收外界输入的数据。\n- 实参:调用方法时实际传给方法的数据。\n\n**方法体:**方法体包含具体的语句，定义该方法的功能。\n\n#### 方法调用\n\n**调用方法:** 对象名.方法名(实参列表)\nJava支持两种调用方法的方式，根据方法是否返回值来选择。\n\n- 当方法返回一个值的时候，方法调用通常被当做一个值。例如:\n  int larger = max( 30，40);\n- 如果方法返回值是void，方法调用一定是一条语句。\n  system.out.print1n(\"Hello,kuangshen ! \");\n\n```java\npublic class TextDemo {\n    public static void main(String[] args) {\n            Demo sum = new Demo();//调用class Demo内的方法\n            sum.haha();\n            sum.add(1,2);\n            System.out.println(sum.adds(1,2));\n    }\n}\n//两个class类,为两个独立的class文件\npublic class Demo {\n\tpublic void haha() {\n        System.out.println(\"哈哈哈\");\n    }\n    public void add(int a, int b) {\n        System.out.println(a+b);\n    }\n    public int adds(int a, int b) {\n        return a+b;\n    }\n}\n```\n\n#### 方法的重载\n\n重载就是在一个类中，有相同的函数名称，但形参不同的函数。\n**方法的重载的规则:**\n\n- 方法名称必须相同。\n\n- 数列表必须不同（个数不同、或类型不同、参数排列顺序不同等)。\n\n- 方法的返回类型可以相同也可以不相同。\n\n- 仅仅返回类型不同不足以成为方法的重载。\n\n**实现理论**:\n\n方法名称相同时，编译器会根据调用方法的参数个数、参数类型等去逐个匹配，以选择对应的方法，如果匹配失败，则编译器报错。\n\n```java\npublic class Demo {\n\n    public String Demo(){\n        String sc=\"哈哈哈\";\n        return sc;\n    }\n\n    public void Demo(int b) {\n        System.out.println(b);\n    }\n    public void Demo(int a, int b) {\n        System.out.println(a+b);\n    }\n    //调用Demo()\n   \tpublic static void main(String[] args) {\n      Demo sum =  new Demo();\n      System.out.println(sum.Demo());\n      sum.Demo(2);\n      sum.Demo(1,2);\n    }\n}\n```\n\n#### 可变参数\n\nJDK 1.5开始,Java支持传递同类型的可变参数给一个方法。\n在方法声明中，在指定参数类型后加一个省略岁(.….)。\n一个方法中只能指定一个可变参数它必须是方法的`最后一个参数` ，任何普通的参数必须在它之前声明。\n\n```java\npublic static void main(String[] args) {\n        Demo demo = new Demo();\n        Demo.test(1,2,3,4);\n\n    }\n    public void test(int ...i){\n        System.out.println(i[2]);\n    }\n```\n\n#### 递归\n\n- A方法调用B方法，我们很容易理解\n\n- 递归就是:A方法调用A方法!就是自己调用自己\n\n  递归结构包括两个部分:\n\n- 递归头:什么时候不调用自身方法。如果没有头，将陷入死循环。\n- 递归体:什么时候需要调用自身方法。\n\n利用递归可以用简单的程序来解决一些复杂的问题。它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解，递归策略只需少量的程序就可描述出解题过程所需要的多次重复计算，大大地减少了程序的代码量。递归的能力在于用有限的语句来定义对象的无限集合。\n\n```java\npublic static void main(String[] args) {\n        System.out.println(text(5));\n    }\n\t//5*4*3*2*1 =120;\n    public static int text(int n){\n        if (n==1){\n            return 1;\n        }else {\n            return n*text(n-1);\n        }\n    }\n```\n\n## Java数组\n\n### 数组的定义\n\n- 数组是相同类型数据的有序集合.\n- 数组描述的是相同类型的若干个数据,按照一定的先后次序排列组合而成。\n- 其中,每一个数据称作一个数组元素,每个数组元素可以通过一个下标来访问它们\n\n**三种初始化**\n静态初始化\n\n```java\nint[] a = {1,2,3};\nMan[] mans = {new Man(1,1),new Man(2,2)};\n```\n\n动态初始化\n\n```java\nint[] a = new int[2];\na[0]=1;\na[1]=2;\n```\n\n数组的默认初始化\n\n数组是引用类型，它的元素相当于类的实例变量，因此数组一经分配空间，其中的每个元素也被按照实例变量同样的方式被隐式初始化。\n\n### 数组声明创建\n\n首先必须声明数组变量，才能在程序中使用数组。下面是声明数组变量的语法:\n\n```java\ndataType[] arrayRefVar;//首选的方法\n//或\ndataType arrayRefVar[];//效果相同，但不是首选方法\n```\nJava语言使用new操作符来创建数组，语法如下:\n\n```java\ndataType[] arrayRefVar = new dataType[arraySize];\n//数组的元素是通过索引访问的，数组索引从0开始。\n//获取数组长度: arrayRefVar.length\n```\n\n> for循环遍历数组\n\n```java\npublic static void main(String[] args) {\n    \t//声明数组变量\n        int[] arr = new int[10];\n        int num =0;\n    \t////数组赋值\n        arr[0] = 1;\n        arr[1] = 2;\n        arr[2] = 3;\n        arr[3] = 4;\n        arr[4] = 5;\n        arr[5] = 6;\n        arr[6] = 7;\n        arr[7] = 8;\n        arr[8] = 9;\n        arr[9] = 10;\n    \t//for循环遍历数组\n    \t//1+2+3+4+...+10;\n        for (int i =0 ;i<arr.length;i++) {\n          num += arr[i];\n        }\n        System.out.println(num);\n    }\n```\n\n> for each遍历数组\n\n```java\npublic static void main(String[] args) {\n    \t//声明数组变量和赋值\n    \tint num =0;\n        int[] arr = {12,5,324,6,3,2};\n        for (int i:arr) {\n            num +=i;\n            System.out.println(i);\n        }\n    \tSystem.out.println(num);\n    }\n```\n\n### 数组的特点\n\n- 其长度是确定的数组一旦被创建，它的大小就是不可以改变的\n- 其元素必须是相同类型,不允许出现混合类型。\n- 数组中的元素可以是任何数据类型，包括基本类型和引用类型。\n- 数组变量属引用类型，数组也可以看成是对象，数组中的每个元素相当于该对象的成员变量。数组本身就是对象，Java中对象是在堆中的，因此数组无论保存原始类型还是其他对象类型,数组对象本身是在堆中的。\n\n### 数组边界\n\n下标的合法区间:[0, length-1]，如果越界就会报错;\n\n```java\npublic static void main(String[ ] args) {\n\tint[] a=new int[2];\n\tsystem.out.println(a[2]);\n}\n```\n\nArraylndexOutOfBoundsException:数组下标越界异常!\n**小结:**\n\n- 数组是相同数据类型(数据类型可以为任意类型)的有序集合数组也是对象。\n- 数组元素相当于对象的成员变量\n- 数组长度的确定的，不可变的。如果越界，则报:ArrayllndexOutofBounds\n\n### 数组使用\n\n> 数组for循环的简单使用\n\n```java\npublic static void main(String[] args) {\n\n        int[] arr = {2,43,1,5,3};\n        //打印全部的数组元素\n        for (int i = 0 ; i < arr.length;i++ ){\n            System.out.println(arr[i]);\n        }\n        System.out.println(\"------\");\n        //计算所有元素的和\n        int num = 0;\n        for (int i = 0 ; i < arr.length;i++ ){\n            num +=arr[i];\n        }\n        System.out.println(num);\n        System.out.println(\"------\");\n        //查找最大元素\n        int max = arr[0];\n        for (int i = 1; i < arr.length ; i++) {\n            if (arr[i]>max){\n                max = arr[i];\n            }\n        }\n        System.out.println( \"max=\"+max );\n\n    }\n```\n\n> 数组for each循环的简单使用\n\n```java\n//没有下标\npublic static void main(String[] args) {\n\n        int[] arr = {2,43,1,5,3};\n        //打印全部的数组元素\n        for (int arrs:arr) {\n            System.out.println(arrs);\n        }\n        System.out.print(\"---------\");\n        printArray(arr);\n        System.out.print(\"---------\");\n        printArray(reverse(arr));\n    }\n//打印数组元素\n    public static void printArray(int[ ]arrays){\n        for (int i = 0; i < arrays. length; i++) {\n            System.out.print(arrays[i]+\" \");\n        }\n    }\n//反转数组\n    public static int[] reverse(int[] arrays) {\n        int[] result = new int[arrays.length];\n        //反转的操作\n        for (int i = 0,j = result.length-1; i < arrays.length; i++,j--) {\n            result[j] = arrays[i];\n        }\n        return result;\n    }\n```\n\n### 多维数组\n\n多维数组可以看成是数组的数组，比如二维数组就是一个特殊的一维数组，其每一个元素都是一个一维数组。\n二维数组\n\n```java\nint a[][] = new int[2][5];\n```\n\n解析:以上二维数组a可以看成一个两行五列的数组。\n\n```java\npublic static void main(String[] args) {\n    int[][] array = {{1,2},{3,4},{5,6}}\n    \n    System.out.println(array.length);\n    System.out.println(array[0].length);\n    \n    for (int i = 0; i < array . length ; i++) {\n            for (int j =0; j <array[i].length ; j++){\n                System.out.println(array[i][j]);\n            }\n\n    }\n}\n```\n\n### Arrays类\n\n- 数组的工具类java.util.Arrays\n- 由于数组对象本身并没有什么方法可以供我们调用,但API中提供了一个工具类Arrays供我们使用,从而可以对数据对象进行一些基本的操作。\n- Arrays类中的方法都是static修饰的静态方法,在使用的时候可以直接使用类名进行调用,而\"不用\"使用对象来调用(注意:是\"不用”而不是\"不能\")\n- 具有以下常用功能:\n  - 给数组赋值:通过fill方法。\n  - 对数组排序:通过sort方法,按升序。\n  - 比较数组:通过equals方法比较数组中元素值是否相等。\n  - 查找数组元素:通过binarySearch方法能对排序好的数组进行二分查找法操作。\n\n> **Arrays.toString**()\n\n```java\npublic static void main(String[] args) {\n        int[] a = {1,2,3,4,9090,31231,543,21,3,23};\n        System.out.println(a); //[I@1b6d3586\n    \t//打印数组元素Arrays.toString\n        //数组进行排序:升序Arrays.sort()\n        Arrays.sort(a);\n        System.out.println(Arrays.toString(a));\n\t\tArrays.fill(a,0);\n        System.out.println(Arrays.toString(a));\n    }\n```\n\n> **Arrays.fill();**\n\n**参数：**\n\n- a - 要填充的数组\n- fromIndex - 要使用指定值填充的第一个元素的索引（包括）\n- toIndex - 要使用指定值填充的最后一个元素的索引（不包括）\n- val - 要存储在数组的所有元素中的值\n\n**抛出：**\n\n- IllegalArgumentException - 如果 fromIndex > toIndex\n- ArrayIndexOutOfBoundsException - 如果 fromIndex < 0 或 toIndex > a.length\n- ArrayStoreException - 如果指定值不是可存储在指定数组中的运行时类型\n\n### 冒泡排序\n\n冒泡排序无疑是最为出名的排序算法之一，总共有八大排序!\n\n冒泡的代码还是相当简单的，两层循环，外层冒泡轮数，里层依次比较。\n\n```java\npublic static void main(String[] args) {\n        //冒泡排序\n        //1．比较数组中两个相邻的元素，如果第一个数比第二个数大，我们就交换他们的位置\n        //2.每一次比较，都会产生出一个最大，或者最小的数字;\n        //3.下一轮可以少一次排序!\n        //4、依次循环，直到结束!\n        int[] a ={23,53,5,15,34,27,35,23};\n        int[] arr = sort(a);\n        System.out.println(Arrays.toString(arr));\n\n    }\n    public static int[] sort(int[] array) {\n        //临时变量\n        int temp = 0;\n        //外层循环，判断我们这个要走多少次;\n        for (int i = 0; i < array.length - 1; i++) {\n            //内层循环，判断两个数，如果第一个数，比第二个数大，则交换位置\n            for (int j = 0; j < array.length - 1; j++) {\n                if (array[j + 1] < array[j]) {\n                    temp = array[j];\n                    array[j] = array[j + 1];\n                    array[j + 1] = temp;\n                }\n            }\n        }\n        return array;\n    }\n```\n\n### 稀疏数组\n\n> 当一个数组中大部分元素为0，或者为同一值的数组时，可以使用稀疏数组来保存该数组。\n\n稀疏数组的处理方式是:\n\n- 记录数组一共有几行几列，有多少个不同值\n- 把具有不同值的元素和行列及值记录在一个小规模的数组中，从而缩小程序的规模\n\n```java\npublic static void main(String[] args) {\n        //1.创建一个二维数组11*11:没有棋子，1:黑棋2:白棋\n        int[][] arr1 = new int[11][11];\n        arr1[1][2] =1;\n        arr1[2][3] =2;\n        //1.1输出原始的数组\n        for (int[] ints : arr1){\n            for (int intes : ints) {\n                System.out.print(intes+\"\\t\");\n            }\n            System.out.println();\n        }\n        //1.2转换为稀疏数组保存\n        //1.3获取有效值的个数\n        int num =0;\n        for (int i =0; i<11; i++){\n            for (int j = 0; j < 11; j++) {\n                if (arr1[i][j] != 0){\n                    num++;\n                }\n            }\n        }\n        System.out.println(\"有效值的个数:\"+num);\n        System.out.println( \"=====================\");\n        //2.创建一个稀疏数组的数组\n        int[][] arr2 = new int[num+1][3];\n        arr2[0][0] = 11;\n        arr2[0][1] = 11;\n        arr2[0][2] = num;\n        //2.1遍历二维数组，将非零的值，存放稀疏数组中\n        int count = 0;\n        for (int i = 0; i < arr1.length ; i++) {\n            for (int j = 0; j < arr1[i].length; j++) {\n                if (arr1[i][j]!=0){\n                    count++;\n                    arr2[count][0] =i;\n                    arr2[count][1] =j;\n                    arr2[count][2] =arr1[i][j];\n                }\n            }\n        }\n        //2.2输出稀疏数组\n        System.out.println(\"稀疏数组\");\n        for (int i = 0; i < arr2.length ; i++) {\n            System.out.println( arr2[i][0]+\"\\t\"+\n                                arr2[i][1]+\"\\t\"+\n                                arr2[i][2]+\"\\t\");\n        }\n        System.out.println( \"=====================\");\n        System.out.println(\"还原\");\n        //3.读取稀疏数组\n        int[][] arr3 = new int[arr2[0][0]][arr2[0][1]];\n        //3.1给其中的元素还原它的值\n        for (int i = 1; i < arr2.length; i++) {\n            arr3[arr2[i][0]][arr2[i][1]] = arr2[i][2];\n        }\n        //3.2打印\n        System.out.println(\"输出还原的数组\"+\"\\n\");\n        for (int[] ints : arr3){\n            for (int intes : ints) {\n                System.out.print(intes+\"\\t\");\n            }\n            System.out.println();\n        }\n\n    }\n```\n\n## Java面向对象\n\n### 什么是面向对象\n\n**面向过程&面向对象**\n\n面向过程思想\n\n- 步骤清晰简单，第一步做什么，第二步做什么...\n- 面对过程适合处理一些较为简单的问题\n\n面向对象思想\n\n- 物以类聚，分类的思维模式，思考问题首先会解决问题需要哪些分类，然后对这些分类进行单独思考。最后，才对某个分类下的细节进行面向过程的思索。\n- 面向对象适合处理复杂的问题，适合处理需要多人协作的问题!\n\n对于描述复杂的事物，为了从宏观上把握、从整体上合理分析,我们需要使用面向对象的思路来分析整个系统。但是，具体到微观操作，仍然需要面向过程的思路去处理。\n\n**什么是面向对象**\n面向对象编程(Object-Oriented Programming, OOP)\n面向对象编程的**本质**就是: 以类的方式组织代码，以对象的组织(封装)数据。\n\n抽象\n\n三大特性:\n\n- 封装\n- 继承\n- 多态\n\n从认识论角度考虑是先有对象后有类。对象，是具体的事物。类，是抽象的，是对对象的抽象\n\n从代码运行角度考虑是先有类后有对象。类是对象的模板。\n\n### 对象的创建\n\n**类与对象的关系**\n类是一种抽象的数据类型,它是对某一类事物整体描述/定义,但是并不能代表某一个具体的事物\n\n- 动物、植物、手机、电脑.....\n- Person类、Pet类、Car类等，这些类都是用来描述/定义某一类具体的事物应该具备的特点和行为\n\n对象是抽象概念的具体实例\n\n- 张三就是人的一个具体实例,张三家里的旺财就是狗的一个具体实例\n- 能够体现出特点,展现出功能的是具体的实例,而不是一个抽象的概念\n\n**创建与初始化对象**\n使用new关键字创建对象\n使用new关键字创建的时候，除了分配内存空间之外，还会给创建好的对象进行默认的初始化以及对类中构造器的调用。\n类中的构造器也称为构造方法，是在进行创建对象的时候必须要调用的。并且构造器有以下俩个特点:\n\n- 必须和类的名字相同\n- 必须没有返回类型,也不能写void\n\n构造器必须要掌握\n\n```java\n//一个项目应该只存一个main方法\npublic class Demo {\n    public static void main( String[] args) {\n\t\t//类:抽象的，实例化\n        //类实例化后会返回一个自己的对象!\n        //student对象就是一个Student类的具体实例!\n        Student xiaoming = new Student();\n        Student xh = new Student();\n        xiaoming.name = \"小明\";\n        xiaoming.age = 3;\n        System.out.println(xiaoming.name);\n        System.out.println(xiaoming.age);\n        xh.name =\"小红\";\n        xh.age = 3;\n        System.out.println(xh.name);\n        System.out.println(xh.age);\n    }\n}\n```\n\n```java\n//学生类\n    public class Student {\n        //属性:字段\n        String name;//NULL\n        int age;//0\n\n        //方法\n        public void study() {\n            System.out.println(this.name + \"在学习\");\n        }\n\n    }\n```\n\n### 构造器\n\n> 无参构造\n\n\n```java\npublic class Student {\n      \n\t\t//一个类即使什么都不写，它也会存在一个方法\n        public Student(){\n            \n        }\n\n}\n```\n\n```java\npublic class Demo {\n        //类实例化后会返回一个自己的对象!\n        Student xiaoming = new Student();\n    }\n}\n```\n\n> 有参构造\n\n```java\npublic class Student {\n      \tString name;\n\t\t//一个类即使什么都不写，它也会存在一个方法\n        public Student(String name){\n            this.name = name;\n        \tSystem.out.println(\"我是：\"+name);    \n        }\n\n}\n```\n\n```java\npublic class Demo {\n    public static void main( String[] args) {\n        //类实例化后会返回一个自己的对象!\n        Student xiaoming = new Student(\"xiaoming\");\n    }\n}\n```\n\n构造器:\n\n- 和类名相同\n- 没有返回值\n\n作用:\n\n- new本质在调用构造方法\n- 初始化对象的值\n\n注意点: 定义有参构造之后，如果想使用无参构造，显示的定义一个无参的构造\n\n### 封装\n\n该露的露，该藏的藏\n我们程序设计要追求“高内聚，低耦合”。\n高内聚: 类的内部数据操作细节自己完成，不允许外部干涉;\n低耦合: 仅暴露少量的方法给外部使用。\n\n封装（数据的隐藏)\n通常，应禁止直接访问一个对象中数据的实际表示，而应通过操作接口来访问，这称为信息隐藏。\n\n> 记住这句话就够了:属性私有，get/set\n\n```java\npublic class Student {\n    //private 私有\n    private String name;\n    private int id;\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setId(int id) {\n        //封装可以加判断\n        if (id>120||id<0) {\n            System.out.println(\"不合法\");\n        }else {\n            this.id = id;\n        }\n    }\n\n    public int getId() {\n        return id;\n    }\n}\n```\n\n```java\npublic class Demo {\n    public static void main( String[] args) {\n        /*1.提高程序的安全性，保护数据\n          2.隐藏代码的实现细节\n          3.统一接口\n          4.系统可维护增加了*/\n      Student student =  new Student();\n        \n      student.setName(\"xiaoming\");\n      System.out.println(student.getName());\n      student.setId(38);\n      System.out.println(student.getId());\n    }\n}\n```\n\n### 继承\n\n继承的本质是对某一批类的抽象，从而实现对现实世界更好的建模。\n\nextands的意思是“扩展”。子类是父类的扩展。\n\nJAVA中类只有单继承，没有多继承!\n\n继承是类和类之间的一种关系。除此之外,类和类之间的关系还有依赖、组合、聚合等。\n继承关系的俩个类，一个为子类(派生类).一个为父类(基类)。\n子类继承父类,使用关键字extends来表示。子类和父类之间,从意义上讲应该具有\"is a\"的关系.\n\n```java\n//在Java中，所有的类，都默认直接或者间接继承object\npublic class Person {\n    public void say(){\n        System.out.println(\"说了一句话\");\n    }\n}\n```\n\n```java\n///学生 is 人\npublic class Student extends Person{\n   \t//子类继承了父类，就会拥有父类的全部方法!\n\t//ctrl+h Idea继承树\n}\n```\n\n```java\npublic class Demo {\n    public static void main( String[] args) {\n      Student student =  new Student();\n      student.say();\n    }\n}\n```\n\n> **super**\n\n**super注意点:**\n\n- super调用父类的构造方法，必须在构造方法的第一个\n- super必须只能出现在子类的方法或者构造方法中!\n- super和 this不能同时调用构造方法!\n\n```java\n//父类\npublic class Person {\n    //private  私有的东西无法被继承!\n    public String name = \"xiaoming\";\n    public Person(){\n        System.out.println(\"Person无参执行了\");\n    }\n    public void print(){\n        System.out.println(\"Person\");\n    }\n}\n```\n\n```java\n///学生 is 人\n//子类继承了父类，就会拥有父类的全部方法!\npublic class Student extends Person{\n    public String name = \"zhengzi\";\n    //隐藏代码;调用了父类的无参构选\n    //super()调用父类的构选器，必须要在子类构造器的第一行\n    public Student(){\n        System.out.println(\"Student无参执行了\");\n    }\n    public void print(){\n        System.out.println(\"Students\");\n    }\n    public void test1(){\n        print();\n        this.print();\n        super.print();\n    }\n    public void test(String name){\n        System.out.println(name);\n        System.out.println(this.name);\n        System.out.println(super.name);\n    }\n\n}\n```\n\n```java\npublic class Demo {\n    public static void main( String[] args) {\n        //类实例化后会返回一个自己的对象!\n        Student student =  new Student();\n        System.out.println(\"========\");\n        student.test1();\n        System.out.println(\"========\");\n        student.test(\"wulin\");\n    }\n}\n```\n\n**vs this:**\n\n代表的对象不同:\n\n- this: 本身调用者这个对象\n- super: 代表父类对象的应用\n\n前提\n\n- this: 没哟继承也可以使用\n- super: 只能在继承条件才可以使用\n\n构造方法\n\n- this(); 本类的构造\n- super(): 父类的构造!\n\n### 方法重写\n\n> 静态的方法\n\n```java\n//重写都是方法的重写,和属性无关\npublic class B {\n    //static\n    public static void test(){\n        System.out.println(\"B=>test()\");\n    }\n}\n```\n\n```java\n//继承\npublic class A extends B{\n    //static\n    public static void test(){\n        System.out.println(\"A=>test()\");\n    }\n}\n```\n\n```java\npublic class Demo {\n    public static void main( String[] args) {\n        //方法的调用只和左边，定义的数据类里有关\n        A a = new A();\n        a.test();//A\n\n        //父类的引用指向了子类\n        B b = new A();\n        b.test();//B\n    }\n}\n```\n\n> 非静态的方法(重写)\n\n```java\npublic class B {\n    public void test(){\n        System.out.println(\"B=>test()\");\n    }\n}\n```\n\n```java\n//继承\npublic class A extends B{\n    //Override 重写\n    //A|t + Insert 选中 Override\n    @Override//注解:有功能的注释!\n    public void test(){\n        System.out.println(\"A=>test()\");\n    }\n}\n```\n\n```java\npublic class Demo {\n    public static void main( String[] args) {\n        //静态的方法和非静态的方法区别很大!\n        //方法的调用只和左边，定义的数据类里有关\n        A a = new A();\n        a.test();//A\n\n        //父类的引用指向了子类\n        B b = new A();\n        //子类重写了父类的方法\n        //子类重写了父类的方法，执行子类的方法\n        b.test();//B\n    }\n\n```\n\n**重写:**需要有继承关系，子类重写父类的方法!\n\n- 方法名必须相同\n- 参数列表列表必须相同\n- 修饰符:范围可以扩大但不能缩小:public>Protected>Default>private\n- 抛出的异常:范围，可以被缩小，但不能扩大;ClassNotFoundException --> Exception(大)重写异常抛出范围不能大于父类\n\n重写，子类的方法和父类必要一致;方法体不同!\n\n为什么需要重写: 父类的功能，子类不一定需要，或者不一定满足!\n\n### 多态\n\n即同一方法可以根据发送对象的不同而采用多种不同的行为方式。\n\n一个对象的实际类型是确定的，但可以指向对象的引用的类型有很多\n\n多态存在的条件\n\n- 有继承关系\n- 子类重写父类方法\n- 父类引用指向子类对象\n\n注意:多态是方法的多态，属性没有多态性。\n\n```java\n//父类\npublic class Person {\n    public void run(){\n        System.out.println(\"run\");\n    }\n}\n```\n\n```java\n//学生 is 人\n//子类继承了父类，就会拥有父类的全部方法!\npublic class Student extends Person{\n    @Override\n    public void run() {\n        System.out.println(\"son\");\n    }\n    public void eat(){\n        System.out.println(\"eat\");\n    }\n}\n\n```\n\n```java\npublic class Demo {\n    //静态的方法和非静态的方法区别很大!\n    public static void main( String[] args) {\n        //一个对象的实际类型是确定的\n        //new Student();\n        //new Person();\n        //可以指向的引用类型就不确定了:父类的引用指向子类\n        //student能调用的方法都是自已的或者继承父类的!\n        Student s1 = new Student();\n        //Person父类型，可以指向子类，但是不能调用子类独有的方法\n        Person s2 = new Student();\n        Object s3 = new Student();\n        s2.run();\n        s1.run();\n        //对象能执行哪些方法，主要看对象左边的类型，和右边关系不大!\n        //类重写了父类的方法，执行子类的方法\n        //(Student(s2)).eat();\n        s1.eat();\n\n    }\n}\n```\n\n多态注意事项:\n\n1. 多态是方法的多态，属性没有多态\n2. 父类和子类，有联系   类型转换异常: cLasscastException !\n3. .存在条件:继承关系，方法需要重写，父类引用指向子类对象!\n\n不能重写：static方法，属于类，它属于实例 ;  final 常量;  private方法;\n\n> instanceof 判断一个对象是什么类型(俗称亲子鉴定)\n>\n> 父类-子类 A instance B B的prototype是否在A的原型链上\n\n类型之间的转化:  子类转换为父类，可能丢失自己的本来的一些方法!\n\n- 把子类转换为父类,  向上转型;\n- 把父类转换为子类，向下转型;强制转换 B b = (B)A\n- 方便方法的调用，减少重复的代码\n\n### 抽象类\n\n`abstract`修饰符可以用来修饰方法也可以修饰类,如果修饰方法,那么该方法就是抽象方法;如果修饰类,那么该类就是抽象类。\n抽象类中可以没有抽象方法,但是有抽象方法的类一定要声明为抽象类。\n\n抽象类,不能使用new关键字来创建对象,它是用来让子类继承的。\n抽象方法,只有方法的声明,没有方法的实现,它是用来让子类实现的。\n\n子类继承抽象类,那么就必须要实现抽象类没有实现的抽象方法,否则该子类也要声明为抽象类。\n\n```java\n// abstract 抽象类: 类extends:单继承~ (接口可以多继承)\npublic abstract class Action {\n    //约束~有人帮我们实现~\n    //abstract ，抽象方法，只有方法名字，没有方法的实现!\n    public abstract void something();\n    //正常方法\n    public void text(){\n        \n    }\n}\n```\n\n```java\n//抽象类的所有方法，然承了它的子类，都必须要实现,除非加abstract 让子子类实现\npublic class A extends Action{\n    @Override\n    public void something() {\n\n    }\n}\n```\n\n- 不能new这个抽象类，只能靠子类去实现它;约束!\n- 抽象类中可以写普通的方法\n- 抽象方法必须在抽象类中\n\n### 接口\n\n普通类: 只有具体实现\n抽象类: 具体实现和规范(抽象方法)都有!\n接口: 只有规范!\n\n接口就是规范，定义的是一组规则，体现了现实世界中“如果你是...则必须能..”的思想。如果你是天使，则必须能飞。如果你是汽车，则必须能跑。如果你好人，则必须干掉坏人;如果你是坏人，则必须欺负好人。\n**接口的本质是契约**，就像我们人间的法律一样。制定好后大家都遵守。\nOO的精髓，是对对象的抽象，最能体现这一点的就是接口。为什么我们讨论设计模式都只针对具备了抽象能力的语言(比如c++、java、c#等)，就是因为设计模式所研究的，实际上就是如何合理的去抽象。\n\n> 声明类的关键字是class, 声明接口的关键字是interface\n\n```java\n//interface定义的关键字\npublic interface UsersService {\n    //按口中的所有定义其实都是抽象的public abstract\n    void add(String name);\n    void delete(String name);\n    void update(String name);\n    void query(String name);\n/*作用:\n约束定义一些方法，让不同的人实现\n public abstract void add(String name)\n public static final int i =99;\n接口不能被实例化心，接口中没有构造方法~\nimplements可以实现多个接口\n必须要重写接口中的方法*/\n}\n```\n\n```java\npublic interface TimeService {\n    void timer();\n}\n```\n\n```java\n//类可以实现接口 implements接口\n//实现了按口的类，就需要重写按口中的方法~\n//多继承~利用接口实现多继承~\npublic class UserServiceImpl implements UsersService,TimeService {\n\n    @Override\n    public void add(String name) {\n\n    }\n\n    @Override\n    public void delete(String name) {\n\n    }\n\n    @Override\n    public void update(String name) {\n\n    }\n\n    @Override\n    public void query(String name) {\n\n    }\n\n    @Override\n    public void timer() {\n\n    }\n}\n```\n\n### 内部类\n\n> 一个Java类中可以有多个class类，但是只能有一个public class\n>\n> 没有名字初始化类,不用把实例保存到变量中~new Apple().eat();\n\n```java\npublic class Person {\n    private static int id=10;\n    \n    public void out(){\n        System.out.println(\"这是外部类的方法\");\n    }\n    \n    public static class Inner{\n        public void in(){\n            System.out.println(\"这是内部类的方法\");\n        }\n        //获得外部类的私有属性~static\n        public void getID(){\n            System.out.println(id);\n        }\n    }\n}\n```\n\n```java\npublic class Demo {\n\n    public static void main(String[] args) {\n        Person person = new Person();\n        //通过这个外部类来实例化内部类~\n        Person.Inner inner = new Person.Inner();\n        inner.in();\n        inner.getID();\n    }\n}\n```\n\n## java异常\n\n**什么是异常**\n\n实际工作中，遇到的情况不可能是非常完美的。比如:你写的某个模块，用户输入不一定符合你的要求、你的程序要打开某个文件，这个文件可能不存在或者文件格式不对，你要读取数据库的数据，数据可能是空的等。我们的程序再跑着，内存或硬盘可能满了。等等。\n\n软件程序在运行过程中，非常可能遇到刚刚提到的这些异常问题，我们叫异常，英文是:`Exception`，意思是例外。这些，例外情况，或者叫异常，怎么让我们写的程序做出合理的处理。而不至于程序崩溃。\n\n异常指程序运行中出现的不期而至的各种状况,如:文件找不到、网络连接失败、非法参数等。\n异常发生在程序运行期间,它影响了正常的程序执行流程。\n\n**简单分类**\n要理解Java异常处理是如何工作的，你需要掌握以下三种类型的异常:\n\n检查性异常: 最具代表的检查性异常是用户错误或问题引起的异常，这是程序员无法预见的。例如要打开一个不存在文件时，一个异常就发生了，这些异常在编译时不能被简单地忽略。\n\n运行时异常: 运行时异常是可能被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略。\n\n错误: 错误不是异常，而是脱离程序员控制的问题。错误在代码中通常被忽略。例如，当栈溢出时，一个错误就发生了，它们在编译也检查不到的。\n\n> Error\n\nError类对象由Java意拟机生成并抛出大多数错误与代码编写者所执行的操作无关。\n\nJava虚拟机运行错误(Virtual MachineError) ，当JVM不下再有继续执行操作所需的内存资源时，将出现 OutOfMemoryError。这些异常发生时、Java虚拟机(JV)一般会选择线程终止;\n\n还有发生在虚拟机试图执行应用时，如类定义错误(NoClass8DefFoundError)、链接错误(LinkageError)，这些错误是不可查的，因为它们在应用程序的控制和处理能力之外，而且绝大多数是程序运行时不允许出现的状况。\n\n> Exception\n\n在Exception分支中有一个重要的子类RuntimeException(运行时异常)\n\n- ArraylndexOutOfBoundsException(数组下标越界)\n- NullPointerException(空指针异常)\n- ArithmeticException(算术异常)\n- MissingResourceException(丢失资源)\n- ClassNotFoundException(找不到类)等异常，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。\n\n这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生;\n\nError和Exception的区别: Error通常是灾难性的致命的错误,是程序无法控制和处理的，当出现这些异常时，Java虚拟机(JVM)一般会选择终止线程;Exception通常情况下是可以被程序处理的，并且在程序中应该尽可能的去处理这些异常。\n\n### 异常处理机制\n- 抛出异常\n- 捕获异常\n\n异常处理五个关键字：try、catch、finally、throw、throws\n\n```java\npublic static void main(String[] args) {\n        int a = 1;\n        int b = 0;\n\t\t//ctrl + Alt + T\n\t\t//Idea 快捷键\n        try {\n            //try监控区域\n            System.out.println(a/b);\n        }catch (ArithmeticException e){\n            //catch(想要捕获的异常类型!)捕获异常\n            System.out.println(\"程序出现异常，变量b不能为0\");\n        } finally {\n            //处理善后工作\n            System.out.println( \"finally\") ;\n        }\n        //finally 可以不finally，假设Io，资源，关闭!\n}\n```\n\n> 捕获多个异常\n\n```java\n//假设要捕获多个异常:从小到大!\n\t\ttry {\n            //try监控区域\n            System.out.println(a/b);\n        }catch (ArithmeticException e){\n            //catch(想要捕获的异常类型!)捕获异常\n            System.out.println(\"程序出现异常，变量b不能为0\");\n        }catch(Exception e){\n            System.out.println(\"Exception\");\n        }catch(Throwable e){\n            System.out.println(\"Throwable\");\n        }finally {\n            //处理善后工作\n            System.out.println( \"finally\") ;\n        }\n```\n\n> 主动的抛出异常-throw\n\n```java\n\tpublic static void main(String[] args){\t\n\t\tin(120);\n    }\n\t//假设这方法中，处理不了这个异常。方法上抛出异常\n\tpublic static void in(int age){\n        if (age>100){\n            throw new ArithmeExcepption(\"异常\");\n            //主动的抛出异常，一殷在方法中使用\n        }else {\n            System.out.println(age);\n        }\n    }\n```\n\n> 假设这方法中，处理不了这个异常。方法上抛出异常-throws\n\n```java\n\tpublic static void main(String[] args){\t\n\t\ttry{\n           in(120);\n        }catch (ArithmeExcepption e){\n            e.printStackTrace();\n       \t}\n    }\n\t//假设这方法中，处理不了这个异常。方法上抛出异常\n\tpublic static void in(int age) throw ArithmeExcepption{\n        if (age>100){\n            throw new ArithmeExcepption(\"异常\");\n            //主动的抛出异常，一殷在方法中使用\n        }else {\n            System.out.println(age);\n        }\n    }\n```\n\n### 自定义异常\n\n使用Java内置的异常类可以描述在编程时出现的大部分异常情况。除此之外，用户还可以自定义异常。用户自定义异常类，只需继承Exception类即可。\n\n在程序中使用自定义异常类，大体可分为以下几个步骤:\n1．创建自定义异常类。\n2．在方法中通过throw关键字抛出异常对象。\n3．如果在当前抛出异常的方法中处理异常，可以使用try-catch语句捕获并处理;否则在方法的声明处通过throws关键字指明要抛出给方法调用者的异常，继续进行下一步操作。\n4．在出现异常方法的调用者中捕获并处理异常。\n\n```java\n//自定义的异常类\npublic class ArithmeException extends Exception{\n    private int num ;\n    public ArithmeException(){}\n    public ArithmeException(int i){\n        this.num =i;\n    }\n    //tostring:异常的打印信息\n    @Override\n    public String toString() {\n        return \"ArithmeException{\"+num+\"}\";\n    }\n}\n```\n\n```java\n//可能会存在异常的方法\npublic class Runtime {\n    public static void main(String[] args) {\n        try {\n            test(11);\n        }catch (ArithmeException e){\n            e.printStackTrace();//打印异常\n            System.out.println(\"ArithmeException=>\"+e);\n        }\n    }\n    public static void test(int i) throws ArithmeException {\n        if (i>10){\n            throw new ArithmeException(i);\n        }\n        System.out.println(\"ok\");\n    }\n\n}\n```\n\n**实际应用中的经验总结**\n\n处理运行时异常时，采用逻辑去合理规避同时辅助try-catch处理\n在多重catch块后面，可以加一个catch(Exceptior）来处理可能会被遗漏的异常\n对于不确定的代码，也可以加上 try-catch，处理潜在的异常\n尽量去处理异常，切忌只是简单地调用printStackTrace()去打印输出\n具体如何处理异常，要根据不同的业务需求和异常类型去决定\n尽量添加finally语句块去释放占用的资源","tags":["java"],"categories":["学习之路"]},{"title":"JavaScript","url":"/2022/08/29/JavaScript/","content":"\n## 快速入门\n\n### 引入JavaScript\n\n1. script标签内，写与javascript代码\n\n   ```html\n   <script type=\"text/javascript\"> \n       alwrt('hello,world');\n   </script>\n   ```\n\n2. 外部引入\n\n   ```html\n   <script src=\"./index.js\"> </script>\n   ```\n\n### 基本语法入门\n\n```html\n<script>\n    // 1．定义变量 变量类型 变量名=变量值;\n    var score = 71;\n    // alert(score);\n    //2．条件控制\n    if (score>60 && score<70){\n    \talert(\"60~70\")\n    }else if(score>70 && score<80){\n    \talert(\"70~80\")\n    }else{\n    \talert(\"other\")\n    }\n\t//console.log(score）在浏览器的控制台打印变量!system.out.println();\n</script>\n```\n\n## 数据类型\n\n### 字符串\n\n1. number    \n\n   js不区分小数和整数\n\n2. 字符  \"abc\"\n\n3. 布尔值  2>1 true\n\n   true false\n\n4. **逻辑运算  &&     ||   !**\n\n- &&两边都是真，结果才是真: true\n\n- 或 ||有一个是真  结果就是真\n\n- 非 ！取反\n\n5. **比较运算符**\n\n- = =等于（类型不一样，值一样，也会判断为true)\n\n- === 绝对等于\n\n- NaN===NaN，这个与所有的数值都不相等，包括自己\n-  只能通过isNaN(NaN)来判断这个数是否是NaN\n   \n6. null和undefined\n- null空 \n- undefined未定义\n\n7. Java的数组必须是相同类型的对象~，JS中不需要这样!\n\n   ```javascript\n   var arr = [1,2,3,4,5 , 'hello ' ,null,true];\n   \n   //取数组下标:如果越界了，就会undefined   console.log(arr[7]）\n   ```\n\n8. 对象是大括号，数组是中括号\n\n   每个属性之间使用逗号隔开，最后一个不需要添加\n\n   ``` javascript\n   var person = {\n       name: \"wzc\",\n       age: \"12\",\n       tage: ['js','java','web']\n   }\n   //person.name\n   ```\n\n### 数组\n\n **Array可以包含任意的数据类型**\n\n```javascript\n  var arr = [1,2,3,4,5,6];\n  arr[0]\n//arr[0] = 1\n```\n\n1、长度\n\n```javascript\n//arr.length\n```\n\n注意:加入给arr.length赋值，数组大小就会发生变化~，如果赋值过小，元素就会丢失\n\n2、indexOf,通过元素获得下标索引   \n\n```javascript\n  arr.indexOf(2)\n//1\n```\n\n字符串的“1”和数字1是不同的\n\n3、**slice () **截取Array的一部分，返回一个新数组，类似于String中的substring\n\n4、push(),pop() 尾部\n\n```javascript\narr.push(元素)//压入到尾部\narr.pop(元素)//弹出尾部的一个元素\n```\n\n5、unshift(),shift() 头部\n\n```javascript\narr.unshift(元素)//压入到头部\narr.shift(元素)//弹出头部的一个元素\n```\n\n6、排序sort()\n\n```javascript\narr.sort(元素)\n```\n\n7、includes 查找字符串是否包含\n\n```html\n<script>\n        var arr = new Array()\n        for( var i =0;i<50;i++){\n            //Math.ceil(Math.random( )*100)1到100的随机数\n            // arr[i] = Math.ceil(Math.random( )*100)\n            var anyNum = Math.ceil(Math.random()*100)\n            if(arr.includes(anyNum)){\n                i--\n                continue\n            }\n            arr.push(anyNum)\n        }\n        console.log(arr)\n</script>\n```\n\n\n\n8、元素反转reverse()\n\n```javascript\n  arr.reverse()\n//['1','2','3']\n//['3','2','1']\n```\n\n9、concat()\n\n```javascript\n//[1,2,3]\n  arr.concat([\"A\",\"B\",\"C\"])\n//[1,2,3,\"A\",'B','C']\n  arr\n//[1,2,3]\n```\n\n注意: concat ()并没有修改数组，只是会返回一个新的数组\n\n10、连接符join\n\n打印拼接数组，使用特定的字符串连接\n\n```javascript\n//[\"C\",\"B\",\"A\"]\n  arr.join('-')\n//\"C-B-A\"\n```\n\n11、多维数组\n\n```javascript\n  arr = [[1,2],[3,4],[\"5\",\"6\"]];\n  arr[1][0]\n//3\n```\n\n数组:存储数据(如何存，如和取，方法都可以自己实现!)\n\n### 对象\n\n```javascript\nvar 对象名= {\n    属性名:属性值,\n\t属性名:属性值,\n}\n\nvar person = {\n    name: \"wzc\",\n    age: 22,\n    email: \"3285458564\"\n}\n```\n\nJs中对象，{..…}表示一个对象，键值对描述属性xxx: xx，多个属性之间使用逗号隔开，最后一个属性不加逗号!\n\nJavaScript中的所有的键都是字符串，值是任意对象!\n\n1、对象赋值\n\n```javascript\nperson.name = \"www\"\n```\n\n2、使用一个不存在的对象属性，不会报错!\n\n```javascript\n  person.haha\n//undefined\n```\n\n3、动态的删减属性\n\n```javascript\n  delete person.name\n//true\n//person\n```\n\n4、动态的添加\n\n```javascript\n  person.fafa = \"fafa\"\n//\"fafa\"\n  person\n```\n\n5、判断属性值是否在这个对象中!xxx in xxx!\n\n```javascript\n  'age' in person\n//true\n//继承\n  'toString' in person\n//true\n```\n\n6、判断一个属性是否是这个对象自身拥有的hasOwnProperty()\n\n```javascript\n  person.hasOwnProperty('toString')\n//false\n  person.hasOwnProperty('age')\n//true\n```\n\n### 流程控制\n\n1、if判断\n\n```javascript\nvar age = 3;\nif(age>3){\n    alert(\"haha\");\n}else if(age<5){\n    alert(\"kuku\");     \n}else{\n    alert(\"yuyu\");\n}\n\nlet money = prompt(\"你有钱吗?\")\n//\t\t\t\t\t\ttrue\tfalse\nlet ren = money > 100 ? \"有钱\" : \"没钱\"\n```\n\n2、while循环，避免程序死循环\n\n```javascript\nwhile(age<10){\n    age = age++;\n    console.log(age)\n}\n```\n\n3、for循环\n\n```javascript\nfor(let i = 0; i < 100; i++){\n    console.log(i)\n}\n```\n\n4、forEach循环\n\n```javascript\nvar age = [22,54,52,12,6,23]\nage.forEach(function (value){\n    console.log(value)\n})\n```\n\n5、for....in\n\n```javascript\n//for(var index in object){}\n//for in 下标\nfor(var num in age){\n    if(age.hasOwnProperty(num)){\n        console.log(num)//console.log(age[num])\n    }\n}\n//for of 数值\nfor(var x of age){\n    console.log(x)\n}   \n```\n\n6、switch\n\n```javascript\nage = 10;\nswitch(age){\n    case 10:\n        console.log(\"pbq\")\n    break;\n    case 9:\n        console.log(\"p\")\n    break;\n    case 8:\n        console.log(\"b\")\n    break;\n    default:\n        console.log(\"q\")\n    break;\n}\n```\n\n7、 break和continue\n\n**break** :在循环的过程中，在满足某些条件的情况下，中断循环的执行。\n\n注意: switch 中的break用于结束某个分支。而循环中的 break 是中断循环的。\n\n```javascript\nfor (var i = 1; i <= 10; i++) {\n            if (i == 5) {\n                //中断循环 \n                break;\n            }\n        document.write(i + \"<br/>\");\n    }\ndocument.write(\"循环结束\");\n```\n\n\n\n**continue** :在循环的过程中，在满足某些条件的情况下，跳过循环中的部分代码不执行，直接进入下次循环。\n\n```javascript\nfor (var i = 1; i <= 10; i++) {\n            if (i == 5) {\n                //跳过continue后面的代码，进入循环的下一步 \n                continue;\n            } \n    \tdocument.write(i + \"<br/>\");\n\t}\ndocument.write(\"循环结束\");\n```\n\n\n\n### Map和Set\n\n1、map\n\n```javascript\nvar map = new Map([['www',63],['qqq',87],['eee',89]]);\nvar name = map.get('www');//通过key获得value\nmap.set('rrr'.36);//新增或修改\nmap.delete(\"qqq\")////删除\nconsole.log(name);\n```\n\n2、Set:无序不重复的集合\n\n```javascript\nvar set = new Set([3,1,1,1,1]); //set可以去重\nset.add (2);//增加\nset.delete(\"1\");//删除\nconsole.log(set.has(3));//true ||false\n```\n\n### iterator\n\n1、遍历数组\n\n```javascript\nvar arr = [3,4,5];\nfor(var x of arr){\n    console.log(x)\n}\n```\n\n2、遍历map\n\n```javascript\nvar map = new Map([[\"tom\",100],[\"jack\",90],[\"haha\",80]]);\nfor(let x of map){\n    console.log(x)\n}\n```\n\n3、遍历set\n\n```javascript\nvar set = new Set([5,6,7]);\nfor(let x of set){\n    console.log(x)\n}\n```\n\n## 函数\n\n### 定义函数\n\n```javascript\npublic 返回值类型 方法名(){\n\treturn 返回值;\n}\n```\n\n**绝对值函数**\n\n> 定义方式一\n\n```javascript\nfunction abs(x){\n    if(x>=0){\n\t\treturn x;\n    }else{\n        return -x;\n    }\n}\n```\n\n一旦执行到return代表函数结束，返回结果!\n\n如果没有执行return，函数执行完也会返回结果，结果就是undefined\n\n> 定义方式二\n\n```javascript\nvar abs = function(x){\n    if(x>=0){\n\t\treturn x;\n    }else{\n        return -x;\n    }\n}\n```\n\n> 定义方式三\n\n```javascript\nvar abs = (x)=>{\n    if(x>=0){\n\t\treturn x;\n    }else{\n        return -x;\n    }\n}\n```\n\n常规函数，**this** 表示调用该函数的对象：\n\n```javascript\n// 常规函数：\nhello = function() {\n  document.getElementById(\"demo\").innerHTML += this;\n}\n\n// window 对象调用该函数：\nwindow.addEventListener(\"load\", hello);\n\n// button 对象调用该函数：\ndocument.getElementById(\"btn\").addEventListener(\"click\", hello);\n```\n\n箭头函数， **this** 则表示函数的拥有者：\n\n```javascript\n// 箭头函数：\nhello = () => {\n  document.getElementById(\"demo\").innerHTML += this;\n}\n\n// window 对象调用该函数：\nwindow.addEventListener(\"load\", hello);\n\n// button 对象调用该函数：\ndocument.getElementById(\"btn\").addEventListener(\"click\", hello);\n```\n\nfunction(x) {...}这是一个匿名函数。但是可以把结果赋值给abs，通过abs就可以调用函数!\n\n> 调用函数\n\n```javascript\nabs(10)\nabs(-10)\n```\n\n> 假设不存在参数，如果规避?\n\n```javascript\nvar abs = function(x){\n    //手动抛出异常来判断\n    if (typeof x !== 'number'){\n    \tthrow \"Not a Number';\n\t}\n    if(x>=0){\n\t\treturn x;\n    }else{\n        return -x;\n    }\n}\n```\n\n> arguments是一个JS免费赠送的关键字;\n> 代表，传递进来的所有的参数，是一个数组!\n\n```javascript\nvar abs = function(x){\n    \n    console.log(\"x=>\"+x);\n    for(var i = 0; i < arguments.length; i++){\n        console.log(arguments[i]);\n    }\n    \n    if (typeof x !=  'number'){\n    \tthrow \"Not a Number';\n\t}\n    \n}\n```\n\n问题: arguments包含所有的参数，我们有时候想使用多余的参数来进行附加操作。需要排除已有参数\n\n> rest ES6引入的新特性 arguments 升级版，获取除了已经定义的参数之外的所有参数...\n\n```javascript\nfunction aaa(a,b, ...rest) {\n\tconsole.log( \"a=>\"+a);\n    console.log( \"b=>\"+b);\n    console.log(rest);\n}\n```\n\nrest参数只能写在最后面，**必须用...标识**。\n\n### 变量的作用域\n\n在javascript中, var定义变量实际是有作用域的。\n\n1、假设在函数体中声明，则在函数体外不可以使用\n\n```javascript\nfunction qi(){\n    var x =1;\n    x = x+1;\n}\nx = x+2;//Uncaught ReferenceError: x is not defined\n```\n\n2、如果两个函数使用了相同的变量名，只要在函数内部，就不冲突\n\n```javascript\nfunction qi(){\n    var x = 1;\n    x = x + 1;\n}\nfunction qi2(){\n    var x = 'A';\n    x = x +1 ;\n}\n```\n\n3、内部函数可以访问外部函数的成员，反之则不行\n\n```javascript\nfunction qj() {\n\tvar x= 1;\n\t//内部函数可以访问外部的成员，反之则不行\n    function qj2(){\n\t\tvar y = x + 1;// 2\n\t}\n\tvar z = y + 1; // Uncaught ReferenceError: y is not defined\n}\n\n```\n\n假设，内部函数变量和外部函数的变量，重名!\n\n假设在JavaScript中函数查找变量从自身函数开始，由“内”向“外”查找\n\n```javascript\nfunction qj() {\n\tvar x= 1;\n    function qj2(){\n\t\tvar x = 'A';\n        console.log('a'+x);\n\t}\n\tconsole.log('1'+x);\n    qj2()\n}\n```\n\n> 提升变量的作用域\n\n```javascript\nfunction qi(){\n    var x = \"x\" + y;\n    console.log(x);\n    var y = 'y';\n}\n```\n\n结果: xundefined\n说明: js执行引擎，自动提升了y的声明，但是不会提升变量y的赋值;\n\n```javascript\nfunction qi(){\n    var x = \"x\",\n        y = 2,\n        z,v;\n    z = 5;\n}\n```\n\n这个是在JavaScript建立之初就存在的特性。\n\n养成规范:所有的变量定义都放在函数的头部，不要乱放，便于代码维护;\n\n> 全局函数\n\n```javascript\n//全局函数\nx = 1;\nfunction qi(){\n    console.log(x);\n}\nqi();\nconsole.log(x);\n```\n\n全局对象 window\n\n```javascript\nvar x = 'xxx';\nalert(x);\nalert(window.x);//默认所有的全局变量，都会自动绑定在 window对象下;\n```\n\nalert()这个函数本身也是一个 window 变量\n\n```javascript\nvar x='XXX';\nwindow. alert(x);\nvar o1d_alert = window.alert;\n//o1d_alert(x);\nwindow.alert = function(){\n    \n};\n//发现alert(失效了\nwindow.alert(123);\n//恢复\nwindow.alert = o1d_alert;window.alert(456);\n```\n\nJavascript实际上只有一个全局作用域，任何变量（函数也可以视为变量)，假设没有在函数作用范围内找到，就会向外查找，如果在全局作用域都没有找到，报错RefrenceError\n\n> 由于我们所有的全局变量都会绑定到我们的window 上。如果不同的js文件，使用了相同的全局变量，冲突~>如果能够减少冲突?\n\n```javascript\n//唯一全局变量\nvar App = {};\n//定义全局变量\nApp.name = ' haha ' ;\nApp.add = function (a,b) {\n\treturn a + b;\n}\n```\n\n减少冲突: 把自己的代码全部放入自己定义的唯一空间名字中，降低全局命名冲突的问题~\n\n> 局部作用域let \n\n```javascript\nfunction aaa(){\n\tfor (var i = 0; i < 100;i++) {\n\t\tconsole.log(i)\n\t}\nconsole.log(i+1);//问题 i 出了这个作用域还可以使用\n}\n```\n\nlet关键字，解决局部作用域冲突问题!\n\n```javascript\nfunction aa(){\n\tfor (let i = 0; i < 100; i++) {\n\t\tconsole.log(i)\n\t}\nconso1e.log(i+1);//uncaught ReferenceError: i is not defined\n}\n```\n\n建议大家都是用let去定义局部作用域的变量;\n\n> 常量const\n\n在ES6之前，怎么定义常量: 只有用全部大写字母命名的变量就是常量;建议不要修改这样的值?\n\n```javascript\nvar PI = '3.14';\nconsole.log(PI);\nPI = '213'; //可以改变这个值conso1e.log(PI);\nconsole.log(PI);\n```\n在ES6后用常量const\n```javascript\nconst PI = '3.14'; //只读变量\nconsole.log(PI);\nPI = '123';\n```\n\n### 方法\n\n> 定义方法\n\n方法就是把函数放在对象的里面，对象只有两个东西: 属性和方法\n\n```javascript\nvar haha = {\n\tname: '哈哈哈',\n\tbitrh: 2000,\n\t//方法\n\tage: function(){\n\t\t//今年 –出生的年\n\t\tvar now = new Date().getFullYear();\n        return now-this.bitrh;\n\t}\n}\n//属性\n////方法一定要带()\nalert(haha.age())\n```\n\nthis. 代表什么?\n\n```javascript\nfunction getAge(){\n\t\t//今年 –出生的年\n\t\tvar now = new Date().getFullYear();\n        return now-this.bitrh;\n\t}\nvar haha = {\n\tname: '哈哈哈',\n\tbitrh: 2000,\n\tage: getAge\n}\nalert(haha.age())\n```\n\nthis是无法指向的，是默认指向调用它的那个对象;\n\n>apply\n\n在js中可以控制this指向\n\n```javascript\nfunction getAge() {\n    //今年 –出生的年\n    var now = new Date().getFullYear();\n    return now - this.bitrh;\n}\nvar haha = {\n    name: '哈哈哈',\n    bitrh: 2000,\n    age: getAge\n};\n  \tgetAge.apply(haha, []); //this，指向了haha，参数为空\n    alert(haha.age())\n```\n\nonclick :元素的单击事件\n\n```html\n<div id=\"dl\">\n\n</div>\n<script>\ndl.onclick = function(){\n    alert(\"111\")\n}\n</script>\n```\n\nonload :页面加载完成事件\n\n```html\n<script>\ndl.onload = function(){\n    alert(\"222\")\n}\n</script>\n<div id=\"dl\">\n\n</div>\n```\n\n## 内部对象\n\n> 标椎对象  object\n\n### Date\n\n基本使用\n\n````javascript\nvar now = new Date();\nconsole.log(now)//Thu Aug 18 2022 17:00:52 GMT+0800 (中国标准时间)\nnow.getFullYear();//年\nnow.getMonth();//月\nnow.getDate();//日\nnow.getDay();//星期\nnow.getHours();//时\nnow.getMinutes();//分\nnow.getSeconds();//秒\nnow.getTime();//时间戳\nconsole.log(new Date(1578106175991))//时间戳转为时间\n````\n\n转换\n\n```javascript\nnow.toLocalesString(); 注意，调用是一个方式，不是一个属性!\nnow.toGMTString();\n```\n\n### JSON\n\n> jsonjson是什么\n\n早期，所有数据传输习惯使用XML文件!\n\n- <u>JSON</u>(JavaScript Object Notation, JS对象简谱)是一种轻量级的数据交换格式。\n- 简洁和清晰的**层次结构**使得JSON成为理想的数据交换语言。\n- 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。\n\n在JavaScript一切皆为对象、任何js支持的类型都可以用JSON来表示格式\n\n- 对象都用{}\n- 数组都用[]\n- 所有的键值对都是用 key:value\n\n> JSON字符串和JS对象的转化\n\n```javascript\nvar user = {\n            name: \"xiaoming\",\n            age: 3,\n            sex: '男'\n  }\n//对象转化为json字符串 { \"name\" : \"xiaoming\" , \"age\" : 3, \"sex\":\"男\"}\nvar jsonuser = JSON.stringify(user);\n//json字符串转化为对象参数为json字符串\nvar obj = JSON.parse('{\"name\" : \"xiaoming\" , \"age\" : 3, \"sex\" :\"男\"}');\n```\n\n### Ajax\n\n- 原生的js写法  xhr异步请求\n- jQuey封装好的方法 $(\"#name\").ajax(\"\")\n- axios请求\n\n## 面向对象编程\n\n> 什么是面向对象\n\njavascript、Java、c#......面向对象;javascript有些区别!·\n\n- 类:模板\n\n- 对象:具体的实例\n\n在JavaScript这个需要大家换一下思维方式!\n\n> 面向对象原型继承\n\n```javascript\nvar student = {\n            name: \"xiaoming\",\n            age: 3,\n            run: function () {\n                console.log(this.name + \" run. . ..\");\n            }\n        };\n\n        student.run();\n\n        var xiao = {\n            name: \"xiao\"\n        };\n\t\t//原型对象\n        xiao.__proto__ = student;\n        \n        xiao.run();\n\n\t\tvar Bird = {\n            f1y: function () {\n                console.log(this.name + \" f1y.. .. \");\n            }\n        };\n        //小的原型是student\n        xiaoming.__proto__ = Bird;\n\n        xiaoming.f1y();\n```\n\n```javascript\nfunction student(name) {\n            this.name = name;\n        }\n        //给student新增一个方法\n        student.prototype.hello = function (){\n            alert('Hello')\n        };\n```\n\n\n\n> 面向对象class继承\n\nclass关健字，是在ES6引入的\n1、定义一个类，属性，方法\n\n```javascript\n//ES6之后=========EEEE\n//定义一个学生的类\n        class student {\n            constructor(name) {\n                this.name = name\n            }\n            hello() {\n                alert(\" hello\")\n            }\n        }\n\tvar xiaoming = new student(\"xiaoming\");\n    var xiaohong = new student(\"xiaohong\");\nxiaoming.hello()\n```\n\n2、继承\n\n```javascript\nclass student {\n            constructor(name) {\n                this.name = name\n            }\n            hello() {\n                alert(\" hello\")\n            }\n        }\n        class xiaostudent extends student {\n            constructor(name, grade) {\n                super(name);\n                this.grade = grade;\n            }\n            myGrade() {\n                alert('我是一名小学生')\n            }\n        }\n\n        var xiaoming = new student(\"xiaoming\");\n        var xiaohong = new xiaostudent(\"xiaohong\",1);\n```\n\n本质:查看对象原型  __ proto__\n\n> 原型链\n\n简单的回顾一下构造函数、原型和实例的关系:每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。那么假如我们让原型对象等于另一个类型的实例，结果会怎样?显然，此时的原型对象将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型又是另一个类型的实例，那么上述关系依然成立。如此层层递进，就构成了实例与原型的链条。这就是所谓的原型链的基本概念。——摘自《javascript高级程序设计》\n\n## 操作BOM对象(重点)\n> 浏览器介绍\n\nJavaScript和浏览器关系?\n\njavaScript 诞生就是为了能够让他在浏览器中运行!\n\nBOM:浏览器对象模型\n\n- IE 6~12\n- Chrome\n- Safai\n- FireFox\n\n>window\n\nwindow代表浏览器窗口\n```javascript\n//大家可以调整浏览器窗口\nwindow.alert(1)\nundefined\nwindow.innerHeight\n258\nwindow.innerwidth\n919\nwindow.outerHeight\n994\nwindow.outerwidth\n919\nwin = window.open(\"https: / / cn.bing.com\" , \"\" , \"width=300 , height=300\")\n//打开子窗口\nwin.close()//关闭窗口\n```\n\n> Navigator\n\nNavigator 封装了浏览器的信息\n\n```javascript\nnavigator.appName\n\"Netscape\"\nnavigator.appversion\n\"5.o\"\nnavigator.userAgent\n\"Mozi11a/5.o (windowsGecko) chrome/63.0.32:\"\nnavigator.platform\n\"win32\"\n```\n\n大多数时候，我们不会使用navigator对象，因为会被人为修改!\n不建议使用这些属性来判断和编写代码\n\n> screen\n\n代表屏幕尺寸\n\n```javascript\nscreen.width\n1920\nscreen.height\n1080\n```\n\n> location(重要)\n\nlocation代表当前页面的URL信息)\n\n```javascript\nhost: \"www.baidu. com\"\nhref: \"https : / /www.baidu. com/\"\nprotocol : \"https : \"\nreload:f reload() //刷新网页//设置新的地址\nlocation.assign('https: //b1og.kuangstudy. com/ ')\n```\n\n> document\n\ndocument代表当前的页面，HTML  DOM文档树\n\n```javascript\n  document.title\n//\"百度一下，你就知道\"\n  document.title='Aobayu'\n//\"Aobayu\"\n```\n\n获取具体的文档树节点\n\n```html\n<dl id=\"app\">\n    <dt>Java</dt>\n    <dd>JavasE</dd>\n    <dd>JavaEE</dd>\n</dl>\n<script>\n\tvar dl = document.getElementById( 'app');\n</script>\n```\n\n获取cookie\n\n```javascript\n  document.cookie\n//\"__guid=111872281.88375976493059340.1578110638877.133;monitor_count=1\"\n```\n\n劫持cookie原理\n\n```html\n<script src=\"aa.js\"></script>\n<!--恶意人员;获取你的cookie上传到他的服务器-->\n```\n\n服务器端可以设置cookie: httpOnly\n\n> history  (不建议使用)\n\nhistory代表浏览器的历史记录\n\n```javascript\nhistory.back()//后退\nhistory.forward()//前进\nhistory.go(1)\n```\n\n> window.open 用于打开一个新的浏览器窗口或查找一个已命名的窗口\n\n```html\n <!--history历史记录对象  -->\n    <div>\n        <h1>春天</h1>\n        <a href=\"summer.html\">访问夏天</a>\n        <a href=\"javascript:history.forward()\">下一页</a>\n    </div>\n\n<!--summer.html-->\n\t<h1>夏天</h1>\n    <a href=\"javascript:history.back()\">上一页</a>\n<!-- location地址栏对象 -->\n    <div>\n        <select id=\"we\" onchange=\"goWe()\">\n            <option value=\"\">请选择</option>\n            <option value=\"http://www.baidu.com\">百度</option>\n            <option value=\"http://www.taobao.com\">淘宝</option>\n            <option value=\"http://www.jd.com\">京东</option>\n        </select>\n    </div>\n    <script type=\"text/javascript\">\n\n        function goWe() {\n            var site = document.getElementById(\"we\").value;\n            if (site != \"\") {\n                window.location.href = site\n            }\n\n        }\n\n    </script>\n<!--window.open('新窗口的页面路径','新窗口的名称','新窗口的属性设置')  -->\n    <button type=\"button\" onclick=\"openWin()\">打开窗口</button>\n    <button type=\"button\" onclick=\"closeWin()\">关闭窗口</button>\n    <script>\n        var subWin;\n        let openWin = () => {\n            subWin = window.open(\"http://www.baidu.com\", \"\",\"width=650,height=400\")\n        }\n\n        let closeWin = () => {\n            subWin.close();\n        }\n    </script>\n    <!-- \n        setTimeout(函数名,延时时间) :延迟指定的时间后，执行一次函数\n        var t = setInterval(函数名,延迟时间) :每隔指定的延迟时间，就执行一次函数\n\t\t将定时器对象清除，结束定时器效果\n\t\tclearTimeout(t);\n    -->\n```\n\n> event 绑定函数\n\n```html\n\t//当鼠标移动时，显示鼠标的坐标位置 \n    //event:封装了事件发生时相关信息的事件对象 \n    //\t\t:这个对象有浏览器在事件发生时自动创建出来。\n    // \t\t:并通过函数参数的方式，传给函数。\n    <script type=\"text/javascript\">\n        let eve = (e) => {\n            let div = document.getElementById(\"dl\");\n            //通过事件对象可以获取事件中存储的鼠标位置：x,y\n            div.innerHTML=e.clientX +\" \"+ e.clientY;\n            //通过事件对象可以获取事件中存储的鼠标位置：x,y\n            div.style.left = e.clientX + \"px\";\n            div.style.top = e.clientY + \"px\";\n        }\n        document.onmousemove = eve;\n\t\t//绑定鼠标移动事件\n    </script>\n\n    <div id=\"dl\" style=\"position:absolute; border: 1px solid red;\">\n    </div>\n```\n\n\n\n## 操作DOM对象(重点)\n\nDOM:文档对象模型\n\n> 核心\n\n浏览器网页就是一个Dom树形结构!\n\n- 更新:更新Dom节点\n- 遍历dom节点:得到Dom节点\n- 删除:删除一个Dom节点\n- 添加:添加一个新的节点\n\n要操作一个Dom节点，就必须要先获得这个Dom节点\n\n```html\n<div id=\"father\">\n\t<h1>标题一</ h1>\n\t<p id=\"p1\">p1</p>\n    <p class=\"p2\">p2</p>\n</div>\n\n//对应 css选择器\n<script>\nvar h1 = document.getElementsByTagName( 'h1');\nvar p1 = document.getElementById( 'p1');\nvar p2 = document.getElementsByc1assName( 'p2 ');\nvar father = document.getElementById( 'father ');\nvar childrens = father.children;\n//获取父节点下的所有子节点\n// father.firstchild\n// father.lastchild\n</script>\n```\n\n这是原生代码，之后我们尽量都是用jQuery();\n\n> 更新节点\n\n操作文本\n\n- id.innerText='456'  修改文本的值\n- id.innerHTML='<strong>123</strong>'  可以解析HTML文本\n\n操作js\n\n```javascript\nid.style.color = 'red' //属性使用字符串包裹\nid.style.fontSize = '20px'\n```\n\n> 删除节点\n\n删除节点的步骤:  先获取父节点，在通过父节点删除自己\n\n```html\n<div id=\"father\">\n\t<h1>标题一</ h1>\n\t<p id=\"p1\">p1</p>\n    <p class=\"p2\">p2</p>\n</div>\n<script>\n    var self = document.getElementById( 'p1');\n    var father = self.parentElement;\n\tfather. removechild(self)\n    //删除是一个动态的过程;\n\tfather.removechild(father.children[0])\n</script>\n```\n\n注意: 删除多个节点的时候，children是在时刻变化的，删除节点的时候一定要注意!\n\n>插入节点\n\n我们获得了某个Dom节点,假设这个dom节点是空的，我们通过innerHTML 就可以增加一个元素了，但是这个DOM节点已经存在元素了，我们就不能这么干了\n\n追加\n\n```html\n<p id=\"js\">Javascript</p>\n<div id=\"list\">\n\t<p id=\"se\">avaSE</p>\n    <p id=\"ee\">avaEE</p>\n    <p id=\"me\">avaME</p>\n</div>\n<script>\n\tvar js = document.getE1ementById('js');\n    var list = document.getE1ementById('list');\n    list.appendchild(js);//追加到后面\n</script>\n\n```\n创建节点\n\n```html\n<p id=\"newP\"></p>\n<div id=\"list\">\n\t<p id=\"se\">avaSE</p>\n    <p id=\"ee\">avaEE</p>\n    <p id=\"me\">avaME</p>\n</div>\n<script>\n//通过js创建一个新的节点\nvar newP = document.createElement('p');//创建一个p标签\n    newP.id = 'newP' ;\n\tnewP.innerText = 'Hello,Kuangshen' ;\n    List.appendchild(newP);//把创建好的p添加List上\n\n</script>\n```\n\n创建一个标签节点\n\n```html\n<style>\n    \n</style>\n<script type=\"text/javascript\" src=\"\">\n    \n</script>\n\n<script>\n//创建一个标签节点\nvar myscript = document.createElement('script');\n    myScript.setAttribute( 'type','text/javascript')\n    \n//可以创建一个Style标签\nvar myStyle= document.createElement( 'style');//创建了一个空styLe标签\n    myStyle.setAttribute( 'type' ,'text/css' );\nmyStyLe.innerHTML = 'body{ background-color: chartreuse;}';//设置标签内容\n    document.getElementsByTagName( 'head')[0].appendChild(myStyle)\n\n</script>\n```\n\n> insert 向某个标签中添加数据行\n\n```html\n<p id=\"js\">javaScript</p>\n\t<div id=\"list\">\n\t\t<p id=\"se\">JavaSE</p>\n        <p id=\"ee\" >avaEE</p>\n        <p id=\"me\" >avaME</p>\n\t</div>\n<script>\n\tvar ee = document.getElementById( 'ee' ) ;\n    var js = document.getElementById( 'js' );\n    var list = document.getElementById( 'list ' );\n    //要包含的节点.insertBefore(newNode,targetNode)\n    list.insertBefore(js,ee);\n</script>\n```\n\n## 操作表单(验证)\n\n> 表单是什么form DOM树\n\n- 文本框text\n- 下拉框< select >\n- 单选框radio\n- 多选框checkbox\n- 隐藏域hidden\n- 密码框password\n\n表单的目的:提交信息\n\n> 获得要提交的信息\n\n```html\n</p>\n    <input type=\"text\" id=\"username\" value=\"hahaha\">\n    绑定同一个\n    <p>\n        <span>性别: </span>\n        <!--多选框的值，就是定义好的value -->\n        <input type=\"radio\" name=\"sex\" value=\"man\" id=\"boy\">男\n        <input type=\"radio\" name=\"sex\" value=\"women\" id=\"gir1\">女\n    </P>\n    </form>\n    <script>\n        var input_text = document.getElementById(\"username\");\n        var boy_radio = document.getElementById(\"boy\");\n        var gir1_radio = document.getElementById(\"gir1\");\n        //得到输入框的值\n        input_text.value\n        //修改输入框的值\n        input_text.value = '123'\n        //对于单选框，多选框等等固定的值，boy_radio.value只能取到当前的值\n        boy_radio.checked;\n        //查看返回的结果，是否为true，如果为true，则被选中~\n        //赋值\n        boy_radio.checked = 'true'\n    </script>\n```\n\n> 提交表单\n\n```html\n<form action=\"https://fanyi.baidu.com/\" method=\"post\" onsubmit=\"return get()\">\n<div>\n  <span>用户名:</span> <input type=\"text\" id=\"username\"  name=\"username\">\n</div>\n  \n     <div>\n          <span>密码:</span> <input type=\"password\" id=\"password\">\n      </div>\n      <input type=\"hidden\" id=\"md5-password\" name=\"password\">\n  \n          <!--绑定事件onclick被点击-->\n      <input type=\"submit\"  value=\"提交\" >\n    <!--<input type=\"submit\"  value=\"提交\" onclick=\"get()\">-->\n          \n          \n      </form>\n      <script type=\"text/javascript\">\n          function get(){\n              let user = document.getElementById(\"username\")\n              let pass = document.getElementById(\"password\")\n              let md5pwd = document.getElementById(\"md5-password\")\n              md5pwd.value = md5(pass.value);//md5加密\n              return true\n          }\n      </script>\n\t<!--MD5在线链接-->\n<script src=\"https://cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.min.js\"></script>\n```\n\n> 简单实例\n\n```html\n<form action=\"\" method=\"get\" onsubmit=\"return submits()\">\n        <input type=\"text\" id=\"name\">账号\n        <br>\n        <input type=\"password\" name=\"\" id=\"password\">密码\n        <br>\n        <input type=\"email\" name=\"\" id=\"email\">email\n        <br><hr>\n        <input type=\"submit\" value=\"提交\" id=\"submit\">\n    </form>\n<script>\n    function $(e){\n        return document.getElementById(e)\n    }\n\n    function submits(){\n        //账号\n        let name = $(\"name\").value;\n        var nameNode =\t/^[a-z0-9_-]{3,16}$/;\n        if( nameNode.exec(name) == null ){\n            alert(\"用户名不能为空，必须是字母和数字\");\n            return false\n        }\n        //密码\n        let password = $(\"password\").value;\n        var passwordNode = /^(?![0-9]+$)(?![a-zA-Z]+$)[0-9A-Za-z]{6,18}$/;\n        if(passwordNode.exec(password) == null){\n            alert(\"密码必须是大于6位的字母加数字\");\n            return false\n        }\n        //email\n        let email = $(\"email\").value;\n        var emails = /^([a-z0-9_\\.-]+)@([\\da-z\\.-]+)\\.([a-z\\.]{2,6})$/\n        if(emails.exec(email)==null){\n            alert(\"邮箱有误\");\n            return false\n        }\n        \n    }\n</script>\n```\n\n## Ajax\n\n**AJAX = Asynchronous JavaScript and XML(异步的JavaScript和XML)。**\n\n**Ajax 不是一种新的编程语言，而是一种用于创建更好更快以及交互性更强的Web应用程序的技术。**\n\n> 增加**BS**(**浏览器/服务器**)的体验性 \n>\n> B/S: 未来的主流，并且会爆发式的持续增长;\n\n> 产品链: H5＋网页＋客户端＋手机端( Android . lOS )+小程序\n\njQuery在全局对象`jQuery`（也就是`$`）绑定了`ajax()`函数，可以处理AJAX请求。`ajax(url, settings)`函数需要接收一个URL和一个可选的`settings`对象，常用的选项如下：\n\n- async：是否异步执行AJAX请求，默认为`true`，千万不要指定为`false`；\n- method：发送的Method，缺省为`'GET'`，可指定为`'POST'`、`'PUT'`等；\n- contentType：发送POST请求的格式，默认值为`'application/x-www-form-urlencoded; charset=UTF-8'`，也可以指定为`text/plain`、`application/json`；\n- data：发送的数据，可以是字符串、数组或object。如果是GET请求，data将被转换成query附加到URL上，如果是POST请求，根据contentType把data序列化成合适的格式；\n- headers：发送的额外的HTTP头，必须是一个object；\n- dataType：接收的数据格式，可以指定为`'html'`、`'xml'`、`'json'`、`'text'`等，缺省情况下根据响应的`Content-Type`猜测。\n\n**伪造Ajax**\n\n纯jS实现Ajax不推荐，直接使用jquery提供的，更方便学习,\n\n```html\n <script type=\"text/javascript\">\n\n        window.onload = function f() {\n            var myDate = new Date();\n            document.getElementById('currentTime').innerText = myDate.getTime();\n        }\n\n        function loadPage() {\n            var targetURL = document.getElementById('url').value;\n            console.log(targetURL);\n            document.getElementById('iframePosition').src = targetURL;\n        }\n\n</script>\n\n    <div>\n        <p>请输入要加载的地址:<span id=\"currentTime\"></span></p>\n        <p>\n            <input type=\"text\" id=\"url\" value=\"https://www.aobayu.cn/\">\n            <input type=\"button\" value=\"提交\" onclick=\"loadPage()\">\n        </p>\n    </div>\n    <div>\n        <div>\n            <h3> 加载页面的位置:</h3>\n        </div>\n        <iframe src=\"\" id=\"iframePosition\" width=\"100%\" height=\"550px\">\n\n        </iframe>\n    </div>\n```\n\n> jQuery提供多个与AJAX有关的方法。通过jQuery AJAX方法，您能够使用HTTP Get和HTTP Post从远程服务器上请求文本、HTML、XML或JSON同时您能够把这些外部数据直接载入网页的被选元素中。jQuery Ajax本质就XMLHttpRequest，对他进行了封装，方便调用!\n\nAjax的核心是XMLHttpRequest对象(XHR)。XHR为向服务器发送请求和解析服务器响应提供了接口。能够以异步方式从服务器获取新数据。\n\n## jQuery\nJavaScript\njQuery库，里面存在大量的Javascript函数\n\n[Download jQuery | jQuery下载](https://jquery.com/download/)\n\n [jQuery API 中文文档 | jQuery API 中文在线手册 | jquery api 下载 | jquery api chm (cuishifeng.cn)](https://jquery.cuishifeng.cn/)\n\n> 获取jQuery\n\n```html\n<!--cdn引入-->\n<script src=\"https://cdn.bootcss.com/jquery/3.4.1/core.js\"></script>\n<!--在线引入-->\n<script src=\"lib/jquery-3.4.1.js\"></script>\n```\n\n>使用:  $ (selector).action()\n\n```html\n\t<!-- 公式:$ (selector).action() -->\n\n    <a href=\"\" id=\"test-jquery\">点我</a>\n\t<script>\n        //选择器就是css的选择器\n        $('#test-jquery').click(function () {\n            alert('hello,jQuery');\n        })\n\t</script>\n```\n\n>选择器\n\n```javascript\n//原生js，选择器少，麻烦不好记\n//标签\ndocument.getElementsByTagName();//id\ndocument.getE1ementById();//类\ndocument.getE1ementsByclassName();\n\n//jQuery css中的选择器它全部都能用!\n$('p').click(); //标签选择器\n$('#id1').click(); //id选择器ssss\n$('.c1ass1').click(); //class选择器\n```\n\n> jQuery事件\n\n```html\n \t<!--要求:获取鼠标当前的一个坐标-->\n    mouse : <span id=\"mouseMove\"></span>\n    <div id=\"divMove\" style=\"border:1px solid red ; height: 300px;\">\n        在这里移动鼠标试试\n    </div>\n\n    <script>\n    //当网页元素加载完毕之后，响应事件\n    $( function () {\n        $('#divMove').mousemove(function (e) {\n            $('#mouseMove').text( 'x : '+e.pageX + 'y : '+e.pageY)\n        })\n    });\n        // 当网页元素加载完华之后，响应事件\n        // 两种写法\n        // $(document).ready( function(){\n\n        // });\n        \n        // $(function(){\n\n        // });\n        </script>\n    </script>\n```\n\n> 操作DOM\n\n节点文本操作\n\n ```html\n<script>\n$('#test-ul li[name=python]' ).text();//获得值\n$('#test-u1 li[name=python]' ).text('设置值');//设置值\n$('#test-ul').html();//获得值\n$('#test-ul').html('<strong>123<strong>');//设置值\n</script>\n ```\n\ncss的操作\n\n```html\n<script>$('#test-ul li[name=python]' ).css({\"color\",\"red\"})</script>\n```\n\n元素的显示和隐藏: 本质display : none\n\n```html\n<script>\n$('#test-ul li[name=python]').show()//显示\n$('#test-ul li[name=python]').hide()//隐藏\n//$(window).width()\n</script>\n```\n","tags":["JavaScript","JQuery"],"categories":["学习之路"]},{"title":"不哭","url":"/2021/05/20/不哭/","content":"\n## 不哭\n\n------\n\n- 戏剧并不是风度，微笑也不是孤独\n- 滑稽的面具下面，黑色的默装剧悄然上演\n- 红唇点缀的是我，只是我不曾见过的角度\n- 黑色西装搭泪点，往往让笑容不至于太冷\n- 他只是从来不风度，这场雨下的太孤独\n- 只是听起来太世俗，他不哭\n- 他只是笑得太麻木，阳光也避开他身影\n- 谁给他微笑的包袱，他不哭\n- 世人判他没有天赋，他看世人皆没风骨\n- 面具下面他看不透，谁戴上\n- 我曾拿下红颜妆，笑他不懂泪珠连\n- 不见风雨伊人下，笑我独酌竟是他","tags":["诗歌"],"categories":["个人随笔"]},{"title":"黄昏静好","url":"/2021/04/28/黄昏静好/","content":"\n## 黄昏静好\n\n------\n\n\n\n- 时间一点 一点的流逝\n- 回些一些 一些的划过\n- 太阳从天边缓缓落下\n- 城市已经布满金黄\n- 寂静的夜色前的那一秒\n- 黑暗中的一道曙光\n- 熟悉街道中的一片黄芒\n- 那是属于你的微笑\n- 时间穿梭 阳光正好\n- 你还在那个原处\n- 太阳依旧 黄昏静好\n- 你还会记得我吗\n- 时光一点 一点拉扯\n- 我已都变了模样\n- 陌生巷道 你还在吗\n- 你还是原来的吗\n- 我会默默静静守护\n- 守护 你的约定","tags":["诗歌"],"categories":["个人随笔"]},{"title":"不存在的人偶","url":"/2020/11/13/不存在的人偶/","content":"\n### 不存在的人偶\n\n“知了–知了”\n\n蝉鸣声仿佛又在宣告，夏天是多么的喧闹。接近七月，又快到来啦！一年中最期待的安宁时光。可不知为何，总是心神不安。\n\n“莫之言，你听说了吗？隔壁班的秋怜听说昨天夜里在教学楼自杀啦！” 白晓生问道。他撅起眉毛，那双明亮的眼睛渴望我知道些什么。\n\n“你问我？你知道的，我一向对那些不关心。”\n\n白晓生正如他的名字一样，也许是因为他是警察局长的儿子。他总是能得到第一手消息。在学校也有很高的人气，总能很好的处理和别人的关系，是我为数不多的朋友。在别人看来我和他总是格格不入。我总是喜欢一个人待着。\n\n“哎！可是我昨天还看见你和她说话，以为你们俩认识。”白晓生又问道。\n\n“昨天吗？我好像是和一个女生说过话，但是我不认识她。因为她在走廊上四处避，撞到了我。神情很慌张的样子，我感觉她好像在害怕什么？”\n\n“可是我听说，她在班里面很有威望。但是做事有些执拗，也得罪了不少人。你说会不会不是自杀呀？”他说。\n\n“叮–叮”上课铃声响起。我并没有理他，直接回到了教室。\n\n我本以为这件事就算过去了。但第二天晚上，白晓生是拉着我去了五楼的地理准备教室。“今天我在教室打听啦。这里就是那位跳楼同学最后待的地方。昨天夜里好像发生了闹鬼。”\n\n我说：“闹鬼怎么可能？世上没有鬼。有也只是某种科学反应。本质就是自己吓自己。”\n\n月亮早已悄无声息地升到了头顶，凄惨的月光正照耀在这间教室。耳边吵闹的声音突兀消失，莫名的安宁使我心跳加速。我回头看他。发现他脸色苍白，手指着一个方向。我顺着手指往那边看，一阵寒颤。不自觉的寒芒而立。月光下，一个穿着白衣的女生披头散发身上染着斑斓血迹，漂浮在对面五楼教室，空洞的眼神正对着我们。不免张开嘴巴，但喉咙却发不出声。\n\n白晓生拉扯着我。虽然他仍脸色苍白，但同时我也感觉到他心中那一丝的兴奋——或许是身为警察的儿子。等我们赶到对面的时候，已经看不到她的踪影。\n\n“咔嗒——”隔壁教室传出声响。我怀着惊恐的表情，跟着白晓生来到隔壁的教室，打开教室的灯。虽然声音断断续续，我还是听到是从柜子里发出的声响。这是我小时候就具备的天赋。总是能敏锐察觉周围的环境。我叫住白晓生，慢慢靠近，就在他伸手要打开柜子的时候。突然柜子被冲开，一个身影撞到他的怀里。\n\n我被吓了一跳，白晓生也是，边喊着，你不要过来啊，急忙推开。\n\n百晓生看清后，“叶之云！是你呀。”白晓生说。\n\n可我却感到很熟悉，白晓生跟我说，你是不是以为她是秋怜，我也是。但她们俩平时都不见面，不然我还以为她俩有血缘关系。\n\n叶之云也是隔壁班的。听说是秋怜最好的闺蜜。我偶然听过。她好像是本校的校花，为人特别友善。我的初次感觉她只是太过于软弱。\n\n“为什么你会在这里？”\n\n“今天有社团活动，所以回家有些晚。” 叶之云惊恐的回答。\n\n“我听说这里有秋怜的鬼魂，刚准备离开。便在窗外看见了她。我就躲进了柜子里。”带着哭腔回答。\n\n我突然想起这是话剧社。观望四周。猛的看见在屋子的角落，有着一只等人高的人偶。我问叶之云，你在我们来之前还发现什么没？她回答道很害怕没注意到什么，但我好像听到了沉重的脚步声。\n\n我不断思索，推断窗外的身影可能就是有人用这只人偶故意而为。脚步声也是他搬动人偶发出的。\n\n叶之云情绪有所缓解。看见我望着人偶，便回答说。听说这是上届社团演出的时候用的。\n\n我问道：“你是否看见有其他人进间教室？这只人偶是否一直在这里？”\n\n“我很害怕，也没有注意这只人偶是否一直在这里。躲进柜子后，就一直闭着眼睛。” 她回答道。\n\n但不知为何我总觉得有些怪异。\n\n好啦，回去吧！我提议道。\n\n第二天，一个男生找我，向我道谢。他是叶之云的男友。同时，也是话剧社的副社长，名叫云棠景。他向我问了很多昨天的事。但我不知为何总感觉他的目的好像不是如此。说起来也奇怪，不知为何秋怜的死反而逐渐消沉下去。没有人在讨论这件事。\n\n但在中午，我却发现我竟然已不知何时，已扯不开关系。白晓生跟我说。秋怜的死被某个学生强压下去，有人找我要我不要多事。可我清楚他的性格。他肯定是要追查下去。\n\n放学后他邀请我到一个咖啡馆，说要找我商量同时也请了另一个人过来。他在调查的时候，找上门来的。来的是个女生。她叫席雨晴，自称是秋怜的朋友。情绪很激动，跟白晓生说秋怜绝不是自杀。肯定的说道绝对是有人谋杀。还说凶手一定是叶之云。恳请我们一定查出来。白晓生心中的好奇更是膨胀。他认为，肯定和闹鬼有关。决定今天要查清闹鬼的真相。\n\n席雨晴却让我生疑，我怎么从来没有听说过，虽然可能因为我朋友很少吧。不爱说话的我，好像也并不认识多少人。可这个关头，怎么会找到我们呢？\n\n夜晚不知不觉中降临，席雨晴也跟着我们埋伏在地理准备室。突然她猛然跑向对面。我抬头看，又见到了那个熟悉的鬼影。我和白晓生跟上她的脚步。又一次来到了话剧社。却发现她早已不见了踪影。突然白晓生惊呼，指着我的背后，一把推开我。我听见砰的一声，同时看见，我背后一个带着鬼面的身影。白晓生果然不愧是警察的儿子。与那个鬼面动起手来不落下风。鬼面发现偷袭不成冲出门，逃走。\n\n我正打算起来，突然抓到一个东西，发现是一根结实的绳子。突然间，我好像明白了什么？喊着白晓生跟着我。来到了四楼，一个与楼梯相邻的教室。他抬头望着门牌，上面写着美术教室。我打开门进去。看见角落果然有一堆画布。这时，席雨晴来啦。白晓生向她询问刚才去了哪里，向她走去下。我急忙拉走他。\n\n“席雨晴，是不是你与秋怜的死有关。”白晓生充满疑惑的望着我。\n\n“我就觉得，从来没有听说过你。恐怕你不是学校里的人吧？你突然自称是秋怜的朋友。我就感觉有些异常。这事过去不算久。可在有人授意打压下。怎么会有人偏偏这个时候会来找我们。”\n\n“你既然知道了，我也就坦白了。反正你们今天也离不开这里了。”\n\n“可是你不知道的是，就在刚刚我已经偷偷报警了。”\n\n这时，鬼面突然来到，把门口占据。正当我不知怎么办的时候。鬼面突然卧倒在地。门口多了一个黑影，身披白衣，双脚离地。还大声喊道，我来复仇了。席雨晴面露惊恐，说到你不可能还活着。我和白晓生顺势将她打晕。检查发现鬼面身上有一根麻醉针。\n\n“出来吧！叶之云” 我说道。\n\n“你怎么知道是我？”\n\n“我已经明白了事情的经过。其实你是秋怜的妹妹吧。”\n\n鬼面人也就是云棠景，也正是他，杀害了秋怜。他和席雨晴应该是情侣吧。我想起来席雨晴他原来是我校学生，同时也是隔壁班的。因为她和云棠景成为情侣，而你姐姐知道啦！就开始威胁她，让她离开云棠景。因为你深深爱着他。最后她受不了你姐姐的威胁，办了休学手续，并深深憎恨着她。于是联合云棠景杀了你姐姐。\n\n我猜测你早就知道了，于是演闹鬼希望引起注意。因为你太软弱，始终下不去手去举报，同时，也是因为没有证据。因为你同时也是美术社成员，所以你画画的功底不弱。你通过美术室里的颜料，可以轻易的做成血的颜色。然后用白色的画布披在人偶身上进行化妆。再用绳子拴住人偶，打开窗户，挂在教室里。由于是夜晚，且相隔这么远，很容易看成一个人。在加上谣言四起，更提高成功的几率。可是在云棠景有意打压下，没有起什么作用。毕竟是人偶，虚构的。\n\n警鸣声响起, 红蓝的灯光中, 仿佛一切都尘埃落地。\n\n“莫之言，你听说了吗？叶之云转学走啦！好像连人偶也带走啦。听说是她求院领导的。也不知道她为什么要那个人偶。”\n\n“听说拿到人偶很开心。她姐姐的尸体也不知道被谁盗走了，真的是太过分了。希望她不要悲伤啊！”\n\n“莫之言，你她们俩然是姐妹，又长那么像，为什么不公开呢”\n\n“莫之言，你说她那个人偶怎么会那么重呢？用什么材料做成的呀？”\n\n“莫之言，要去看人偶剧吗？”白晓生问道。“好像叫做不存在的人偶！”","tags":["悬疑","推理"],"categories":["个人随笔"]}]